// package: routerprotocol.routerchain.crosschain
// file: routerchain/crosschain/crosschain_ack_receipt.proto

import * as jspb from "google-protobuf";
import * as routerchain_crosschain_crosschain_ack_receipt_tx_status_pb from "../../routerchain/crosschain/crosschain_ack_receipt_tx_status_pb";

export class CrosschainAckReceipt extends jspb.Message {
  getAckreceiptsrcchainid(): string;
  setAckreceiptsrcchainid(value: string): void;

  getContract(): string;
  setContract(value: string): void;

  getAckReceiptIdentifier(): number;
  setAckReceiptIdentifier(value: number): void;

  getAckReceiptBlockheight(): number;
  setAckReceiptBlockheight(value: number): void;

  getAckReceiptTxhash(): string;
  setAckReceiptTxhash(value: string): void;

  getRelayerrouteraddress(): string;
  setRelayerrouteraddress(value: string): void;

  getRequestidentifier(): number;
  setRequestidentifier(value: number): void;

  getStatus(): routerchain_crosschain_crosschain_ack_receipt_tx_status_pb.CrosschainAckReceiptTxStatusMap[keyof routerchain_crosschain_crosschain_ack_receipt_tx_status_pb.CrosschainAckReceiptTxStatusMap];
  setStatus(value: routerchain_crosschain_crosschain_ack_receipt_tx_status_pb.CrosschainAckReceiptTxStatusMap[keyof routerchain_crosschain_crosschain_ack_receipt_tx_status_pb.CrosschainAckReceiptTxStatusMap]): void;

  getAcksrcchainid(): string;
  setAcksrcchainid(value: string): void;

  getAckrequestidentifier(): number;
  setAckrequestidentifier(value: number): void;

  getAckexecdata(): Uint8Array | string;
  getAckexecdata_asU8(): Uint8Array;
  getAckexecdata_asB64(): string;
  setAckexecdata(value: Uint8Array | string): void;

  getAckexecstatus(): boolean;
  setAckexecstatus(value: boolean): void;

  getFeeconsumed(): number;
  setFeeconsumed(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): CrosschainAckReceipt.AsObject;
  static toObject(includeInstance: boolean, msg: CrosschainAckReceipt): CrosschainAckReceipt.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: CrosschainAckReceipt, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): CrosschainAckReceipt;
  static deserializeBinaryFromReader(message: CrosschainAckReceipt, reader: jspb.BinaryReader): CrosschainAckReceipt;
}

export namespace CrosschainAckReceipt {
  export type AsObject = {
    ackreceiptsrcchainid: string,
    contract: string,
    ackReceiptIdentifier: number,
    ackReceiptBlockheight: number,
    ackReceiptTxhash: string,
    relayerrouteraddress: string,
    requestidentifier: number,
    status: routerchain_crosschain_crosschain_ack_receipt_tx_status_pb.CrosschainAckReceiptTxStatusMap[keyof routerchain_crosschain_crosschain_ack_receipt_tx_status_pb.CrosschainAckReceiptTxStatusMap],
    acksrcchainid: string,
    ackrequestidentifier: number,
    ackexecdata: Uint8Array | string,
    ackexecstatus: boolean,
    feeconsumed: number,
  }
}

export class CrosschainAckReceiptClaimHash extends jspb.Message {
  getAckreceiptsrcchainid(): string;
  setAckreceiptsrcchainid(value: string): void;

  getContract(): string;
  setContract(value: string): void;

  getAckReceiptIdentifier(): number;
  setAckReceiptIdentifier(value: number): void;

  getAckReceiptBlockheight(): number;
  setAckReceiptBlockheight(value: number): void;

  getAckReceiptTxhash(): string;
  setAckReceiptTxhash(value: string): void;

  getRelayerrouteraddress(): string;
  setRelayerrouteraddress(value: string): void;

  getRequestidentifier(): number;
  setRequestidentifier(value: number): void;

  getAcksrcchainid(): string;
  setAcksrcchainid(value: string): void;

  getAckrequestidentifier(): number;
  setAckrequestidentifier(value: number): void;

  getAckexecdata(): Uint8Array | string;
  getAckexecdata_asU8(): Uint8Array;
  getAckexecdata_asB64(): string;
  setAckexecdata(value: Uint8Array | string): void;

  getAckexecstatus(): boolean;
  setAckexecstatus(value: boolean): void;

  getFeeconsumed(): number;
  setFeeconsumed(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): CrosschainAckReceiptClaimHash.AsObject;
  static toObject(includeInstance: boolean, msg: CrosschainAckReceiptClaimHash): CrosschainAckReceiptClaimHash.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: CrosschainAckReceiptClaimHash, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): CrosschainAckReceiptClaimHash;
  static deserializeBinaryFromReader(message: CrosschainAckReceiptClaimHash, reader: jspb.BinaryReader): CrosschainAckReceiptClaimHash;
}

export namespace CrosschainAckReceiptClaimHash {
  export type AsObject = {
    ackreceiptsrcchainid: string,
    contract: string,
    ackReceiptIdentifier: number,
    ackReceiptBlockheight: number,
    ackReceiptTxhash: string,
    relayerrouteraddress: string,
    requestidentifier: number,
    acksrcchainid: string,
    ackrequestidentifier: number,
    ackexecdata: Uint8Array | string,
    ackexecstatus: boolean,
    feeconsumed: number,
  }
}

