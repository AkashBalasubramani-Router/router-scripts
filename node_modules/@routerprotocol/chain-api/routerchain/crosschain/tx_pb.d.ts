// package: routerprotocol.routerchain.crosschain
// file: routerchain/crosschain/tx.proto

import * as jspb from "google-protobuf";
import * as multichain_chain_type_pb from "../../multichain/chain_type_pb";
import * as cosmos_base_v1beta1_coin_pb from "../../cosmos/base/v1beta1/coin_pb";
import * as gogoproto_gogo_pb from "../../gogoproto/gogo_pb";

export class MsgCrosschainRequest extends jspb.Message {
  getOrchestrator(): string;
  setOrchestrator(value: string): void;

  getSrcChainId(): string;
  setSrcChainId(value: string): void;

  getContract(): string;
  setContract(value: string): void;

  getRequestIdentifier(): number;
  setRequestIdentifier(value: number): void;

  getBlockHeight(): number;
  setBlockHeight(value: number): void;

  getSourceTxHash(): string;
  setSourceTxHash(value: string): void;

  getSrcTimestamp(): number;
  setSrcTimestamp(value: number): void;

  getSrcTxOrigin(): string;
  setSrcTxOrigin(value: string): void;

  getRouteAmount(): string;
  setRouteAmount(value: string): void;

  getRouteRecipient(): string;
  setRouteRecipient(value: string): void;

  getDestChainId(): string;
  setDestChainId(value: string): void;

  getRequestSender(): string;
  setRequestSender(value: string): void;

  getRequestMetadata(): Uint8Array | string;
  getRequestMetadata_asU8(): Uint8Array;
  getRequestMetadata_asB64(): string;
  setRequestMetadata(value: Uint8Array | string): void;

  getRequestPacket(): Uint8Array | string;
  getRequestPacket_asU8(): Uint8Array;
  getRequestPacket_asB64(): string;
  setRequestPacket(value: Uint8Array | string): void;

  getSrcChainType(): multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap];
  setSrcChainType(value: multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap]): void;

  getDestChainType(): multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap];
  setDestChainType(value: multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap]): void;

  getEthsigner(): string;
  setEthsigner(value: string): void;

  getSignature(): string;
  setSignature(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgCrosschainRequest.AsObject;
  static toObject(includeInstance: boolean, msg: MsgCrosschainRequest): MsgCrosschainRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgCrosschainRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgCrosschainRequest;
  static deserializeBinaryFromReader(message: MsgCrosschainRequest, reader: jspb.BinaryReader): MsgCrosschainRequest;
}

export namespace MsgCrosschainRequest {
  export type AsObject = {
    orchestrator: string,
    srcChainId: string,
    contract: string,
    requestIdentifier: number,
    blockHeight: number,
    sourceTxHash: string,
    srcTimestamp: number,
    srcTxOrigin: string,
    routeAmount: string,
    routeRecipient: string,
    destChainId: string,
    requestSender: string,
    requestMetadata: Uint8Array | string,
    requestPacket: Uint8Array | string,
    srcChainType: multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap],
    destChainType: multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap],
    ethsigner: string,
    signature: string,
  }
}

export class MsgCrosschainRequestResponse extends jspb.Message {
  getRequestIdentifier(): number;
  setRequestIdentifier(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgCrosschainRequestResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgCrosschainRequestResponse): MsgCrosschainRequestResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgCrosschainRequestResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgCrosschainRequestResponse;
  static deserializeBinaryFromReader(message: MsgCrosschainRequestResponse, reader: jspb.BinaryReader): MsgCrosschainRequestResponse;
}

export namespace MsgCrosschainRequestResponse {
  export type AsObject = {
    requestIdentifier: number,
  }
}

export class MsgConfirmCrosschainRequest extends jspb.Message {
  getOrchestrator(): string;
  setOrchestrator(value: string): void;

  getSourcechainid(): string;
  setSourcechainid(value: string): void;

  getRequestIdentifier(): number;
  setRequestIdentifier(value: number): void;

  getClaimhash(): Uint8Array | string;
  getClaimhash_asU8(): Uint8Array;
  getClaimhash_asB64(): string;
  setClaimhash(value: Uint8Array | string): void;

  getEthsigner(): string;
  setEthsigner(value: string): void;

  getSignature(): string;
  setSignature(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgConfirmCrosschainRequest.AsObject;
  static toObject(includeInstance: boolean, msg: MsgConfirmCrosschainRequest): MsgConfirmCrosschainRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgConfirmCrosschainRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgConfirmCrosschainRequest;
  static deserializeBinaryFromReader(message: MsgConfirmCrosschainRequest, reader: jspb.BinaryReader): MsgConfirmCrosschainRequest;
}

export namespace MsgConfirmCrosschainRequest {
  export type AsObject = {
    orchestrator: string,
    sourcechainid: string,
    requestIdentifier: number,
    claimhash: Uint8Array | string,
    ethsigner: string,
    signature: string,
  }
}

export class MsgConfirmCrosschainRequestResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgConfirmCrosschainRequestResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgConfirmCrosschainRequestResponse): MsgConfirmCrosschainRequestResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgConfirmCrosschainRequestResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgConfirmCrosschainRequestResponse;
  static deserializeBinaryFromReader(message: MsgConfirmCrosschainRequestResponse, reader: jspb.BinaryReader): MsgConfirmCrosschainRequestResponse;
}

export namespace MsgConfirmCrosschainRequestResponse {
  export type AsObject = {
  }
}

export class MsgCrosschainAckRequest extends jspb.Message {
  getOrchestrator(): string;
  setOrchestrator(value: string): void;

  getAckSrcChainId(): string;
  setAckSrcChainId(value: string): void;

  getContract(): string;
  setContract(value: string): void;

  getAckRequestIdentifier(): number;
  setAckRequestIdentifier(value: number): void;

  getBlockheight(): number;
  setBlockheight(value: number): void;

  getDesttxhash(): string;
  setDesttxhash(value: string): void;

  getRelayerrouteraddress(): string;
  setRelayerrouteraddress(value: string): void;

  getAckDestChainId(): string;
  setAckDestChainId(value: string): void;

  getRequestSender(): string;
  setRequestSender(value: string): void;

  getRequestidentifier(): number;
  setRequestidentifier(value: number): void;

  getAckSrcChainType(): multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap];
  setAckSrcChainType(value: multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap]): void;

  getAckDestChainType(): multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap];
  setAckDestChainType(value: multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap]): void;

  getFeeconsumed(): number;
  setFeeconsumed(value: number): void;

  getExecdata(): Uint8Array | string;
  getExecdata_asU8(): Uint8Array;
  getExecdata_asB64(): string;
  setExecdata(value: Uint8Array | string): void;

  getExecstatus(): boolean;
  setExecstatus(value: boolean): void;

  getEthsigner(): string;
  setEthsigner(value: string): void;

  getSignature(): string;
  setSignature(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgCrosschainAckRequest.AsObject;
  static toObject(includeInstance: boolean, msg: MsgCrosschainAckRequest): MsgCrosschainAckRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgCrosschainAckRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgCrosschainAckRequest;
  static deserializeBinaryFromReader(message: MsgCrosschainAckRequest, reader: jspb.BinaryReader): MsgCrosschainAckRequest;
}

export namespace MsgCrosschainAckRequest {
  export type AsObject = {
    orchestrator: string,
    ackSrcChainId: string,
    contract: string,
    ackRequestIdentifier: number,
    blockheight: number,
    desttxhash: string,
    relayerrouteraddress: string,
    ackDestChainId: string,
    requestSender: string,
    requestidentifier: number,
    ackSrcChainType: multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap],
    ackDestChainType: multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap],
    feeconsumed: number,
    execdata: Uint8Array | string,
    execstatus: boolean,
    ethsigner: string,
    signature: string,
  }
}

export class MsgCrosschainAckRequestResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgCrosschainAckRequestResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgCrosschainAckRequestResponse): MsgCrosschainAckRequestResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgCrosschainAckRequestResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgCrosschainAckRequestResponse;
  static deserializeBinaryFromReader(message: MsgCrosschainAckRequestResponse, reader: jspb.BinaryReader): MsgCrosschainAckRequestResponse;
}

export namespace MsgCrosschainAckRequestResponse {
  export type AsObject = {
  }
}

export class MsgConfirmCrosschainAckRequest extends jspb.Message {
  getOrchestrator(): string;
  setOrchestrator(value: string): void;

  getAckSrcChainId(): string;
  setAckSrcChainId(value: string): void;

  getAckrequestidentifier(): number;
  setAckrequestidentifier(value: number): void;

  getClaimhash(): Uint8Array | string;
  getClaimhash_asU8(): Uint8Array;
  getClaimhash_asB64(): string;
  setClaimhash(value: Uint8Array | string): void;

  getEthsigner(): string;
  setEthsigner(value: string): void;

  getSignature(): string;
  setSignature(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgConfirmCrosschainAckRequest.AsObject;
  static toObject(includeInstance: boolean, msg: MsgConfirmCrosschainAckRequest): MsgConfirmCrosschainAckRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgConfirmCrosschainAckRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgConfirmCrosschainAckRequest;
  static deserializeBinaryFromReader(message: MsgConfirmCrosschainAckRequest, reader: jspb.BinaryReader): MsgConfirmCrosschainAckRequest;
}

export namespace MsgConfirmCrosschainAckRequest {
  export type AsObject = {
    orchestrator: string,
    ackSrcChainId: string,
    ackrequestidentifier: number,
    claimhash: Uint8Array | string,
    ethsigner: string,
    signature: string,
  }
}

export class MsgConfirmCrosschainAckRequestResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgConfirmCrosschainAckRequestResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgConfirmCrosschainAckRequestResponse): MsgConfirmCrosschainAckRequestResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgConfirmCrosschainAckRequestResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgConfirmCrosschainAckRequestResponse;
  static deserializeBinaryFromReader(message: MsgConfirmCrosschainAckRequestResponse, reader: jspb.BinaryReader): MsgConfirmCrosschainAckRequestResponse;
}

export namespace MsgConfirmCrosschainAckRequestResponse {
  export type AsObject = {
  }
}

export class MsgCrosschainAckReceipt extends jspb.Message {
  getOrchestrator(): string;
  setOrchestrator(value: string): void;

  getAckreceiptsrcchainid(): string;
  setAckreceiptsrcchainid(value: string): void;

  getContract(): string;
  setContract(value: string): void;

  getAckReceiptIdentifier(): number;
  setAckReceiptIdentifier(value: number): void;

  getAckReceiptBlockheight(): number;
  setAckReceiptBlockheight(value: number): void;

  getAckReceiptTxhash(): string;
  setAckReceiptTxhash(value: string): void;

  getRelayerrouteraddress(): string;
  setRelayerrouteraddress(value: string): void;

  getRequestidentifier(): number;
  setRequestidentifier(value: number): void;

  getAcksrcchainid(): string;
  setAcksrcchainid(value: string): void;

  getAckrequestidentifier(): number;
  setAckrequestidentifier(value: number): void;

  getAckexecdata(): Uint8Array | string;
  getAckexecdata_asU8(): Uint8Array;
  getAckexecdata_asB64(): string;
  setAckexecdata(value: Uint8Array | string): void;

  getAckexecstatus(): boolean;
  setAckexecstatus(value: boolean): void;

  getFeeconsumed(): number;
  setFeeconsumed(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgCrosschainAckReceipt.AsObject;
  static toObject(includeInstance: boolean, msg: MsgCrosschainAckReceipt): MsgCrosschainAckReceipt.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgCrosschainAckReceipt, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgCrosschainAckReceipt;
  static deserializeBinaryFromReader(message: MsgCrosschainAckReceipt, reader: jspb.BinaryReader): MsgCrosschainAckReceipt;
}

export namespace MsgCrosschainAckReceipt {
  export type AsObject = {
    orchestrator: string,
    ackreceiptsrcchainid: string,
    contract: string,
    ackReceiptIdentifier: number,
    ackReceiptBlockheight: number,
    ackReceiptTxhash: string,
    relayerrouteraddress: string,
    requestidentifier: number,
    acksrcchainid: string,
    ackrequestidentifier: number,
    ackexecdata: Uint8Array | string,
    ackexecstatus: boolean,
    feeconsumed: number,
  }
}

export class MsgCrosschainAckReceiptResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgCrosschainAckReceiptResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgCrosschainAckReceiptResponse): MsgCrosschainAckReceiptResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgCrosschainAckReceiptResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgCrosschainAckReceiptResponse;
  static deserializeBinaryFromReader(message: MsgCrosschainAckReceiptResponse, reader: jspb.BinaryReader): MsgCrosschainAckReceiptResponse;
}

export namespace MsgCrosschainAckReceiptResponse {
  export type AsObject = {
  }
}

