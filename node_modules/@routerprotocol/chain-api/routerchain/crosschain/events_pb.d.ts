// package: routerprotocol.routerchain.crosschain
// file: routerchain/crosschain/events.proto

import * as jspb from "google-protobuf";
import * as multichain_chain_type_pb from "../../multichain/chain_type_pb";
import * as cosmos_base_v1beta1_coin_pb from "../../cosmos/base/v1beta1/coin_pb";
import * as gogoproto_gogo_pb from "../../gogoproto/gogo_pb";

export class EventCrosschainRequestCreated extends jspb.Message {
  getAttestationId(): Uint8Array | string;
  getAttestationId_asU8(): Uint8Array;
  getAttestationId_asB64(): string;
  setAttestationId(value: Uint8Array | string): void;

  getSrcChainId(): string;
  setSrcChainId(value: string): void;

  getRequestIdentifier(): number;
  setRequestIdentifier(value: number): void;

  getBlockHeight(): number;
  setBlockHeight(value: number): void;

  getSourceTxHash(): string;
  setSourceTxHash(value: string): void;

  getSrcTimestamp(): number;
  setSrcTimestamp(value: number): void;

  getSrcTxOrigin(): string;
  setSrcTxOrigin(value: string): void;

  getRouteAmount(): string;
  setRouteAmount(value: string): void;

  getRouteRecipient(): string;
  setRouteRecipient(value: string): void;

  getDestChainId(): string;
  setDestChainId(value: string): void;

  getRequestSender(): string;
  setRequestSender(value: string): void;

  getRequestMetadata(): Uint8Array | string;
  getRequestMetadata_asU8(): Uint8Array;
  getRequestMetadata_asB64(): string;
  setRequestMetadata(value: Uint8Array | string): void;

  getRequestPacket(): Uint8Array | string;
  getRequestPacket_asU8(): Uint8Array;
  getRequestPacket_asB64(): string;
  setRequestPacket(value: Uint8Array | string): void;

  getSrcChainType(): multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap];
  setSrcChainType(value: multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap]): void;

  getDestChainType(): multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap];
  setDestChainType(value: multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventCrosschainRequestCreated.AsObject;
  static toObject(includeInstance: boolean, msg: EventCrosschainRequestCreated): EventCrosschainRequestCreated.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventCrosschainRequestCreated, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventCrosschainRequestCreated;
  static deserializeBinaryFromReader(message: EventCrosschainRequestCreated, reader: jspb.BinaryReader): EventCrosschainRequestCreated;
}

export namespace EventCrosschainRequestCreated {
  export type AsObject = {
    attestationId: Uint8Array | string,
    srcChainId: string,
    requestIdentifier: number,
    blockHeight: number,
    sourceTxHash: string,
    srcTimestamp: number,
    srcTxOrigin: string,
    routeAmount: string,
    routeRecipient: string,
    destChainId: string,
    requestSender: string,
    requestMetadata: Uint8Array | string,
    requestPacket: Uint8Array | string,
    srcChainType: multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap],
    destChainType: multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap],
  }
}

export class EventCrosschainRequestConfirm extends jspb.Message {
  getSourceChainId(): string;
  setSourceChainId(value: string): void;

  getRequestIdentifier(): number;
  setRequestIdentifier(value: number): void;

  getClaimHash(): Uint8Array | string;
  getClaimHash_asU8(): Uint8Array;
  getClaimHash_asB64(): string;
  setClaimHash(value: Uint8Array | string): void;

  getEthSigner(): string;
  setEthSigner(value: string): void;

  getSignature(): string;
  setSignature(value: string): void;

  getOrchestrator(): string;
  setOrchestrator(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventCrosschainRequestConfirm.AsObject;
  static toObject(includeInstance: boolean, msg: EventCrosschainRequestConfirm): EventCrosschainRequestConfirm.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventCrosschainRequestConfirm, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventCrosschainRequestConfirm;
  static deserializeBinaryFromReader(message: EventCrosschainRequestConfirm, reader: jspb.BinaryReader): EventCrosschainRequestConfirm;
}

export namespace EventCrosschainRequestConfirm {
  export type AsObject = {
    sourceChainId: string,
    requestIdentifier: number,
    claimHash: Uint8Array | string,
    ethSigner: string,
    signature: string,
    orchestrator: string,
  }
}

export class EventHandleNativeTransfer extends jspb.Message {
  getSourceChainId(): string;
  setSourceChainId(value: string): void;

  getRequestIdentifier(): number;
  setRequestIdentifier(value: number): void;

  getRouteAmount(): string;
  setRouteAmount(value: string): void;

  getRouteRecipient(): string;
  setRouteRecipient(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventHandleNativeTransfer.AsObject;
  static toObject(includeInstance: boolean, msg: EventHandleNativeTransfer): EventHandleNativeTransfer.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventHandleNativeTransfer, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventHandleNativeTransfer;
  static deserializeBinaryFromReader(message: EventHandleNativeTransfer, reader: jspb.BinaryReader): EventHandleNativeTransfer;
}

export namespace EventHandleNativeTransfer {
  export type AsObject = {
    sourceChainId: string,
    requestIdentifier: number,
    routeAmount: string,
    routeRecipient: string,
  }
}

export class EventCrosschainReadyToExecute extends jspb.Message {
  getSourceChainId(): string;
  setSourceChainId(value: string): void;

  getRequestIdentifier(): number;
  setRequestIdentifier(value: number): void;

  getClaimHash(): Uint8Array | string;
  getClaimHash_asU8(): Uint8Array;
  getClaimHash_asB64(): string;
  setClaimHash(value: Uint8Array | string): void;

  getFeePayer(): string;
  setFeePayer(value: string): void;

  hasDestTxFeeInRoute(): boolean;
  clearDestTxFeeInRoute(): void;
  getDestTxFeeInRoute(): cosmos_base_v1beta1_coin_pb.Coin | undefined;
  setDestTxFeeInRoute(value?: cosmos_base_v1beta1_coin_pb.Coin): void;

  getDestGasLimit(): number;
  setDestGasLimit(value: number): void;

  getDestGasPrice(): number;
  setDestGasPrice(value: number): void;

  hasRelayerIncentiveInRoute(): boolean;
  clearRelayerIncentiveInRoute(): void;
  getRelayerIncentiveInRoute(): cosmos_base_v1beta1_coin_pb.Coin | undefined;
  setRelayerIncentiveInRoute(value?: cosmos_base_v1beta1_coin_pb.Coin): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventCrosschainReadyToExecute.AsObject;
  static toObject(includeInstance: boolean, msg: EventCrosschainReadyToExecute): EventCrosschainReadyToExecute.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventCrosschainReadyToExecute, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventCrosschainReadyToExecute;
  static deserializeBinaryFromReader(message: EventCrosschainReadyToExecute, reader: jspb.BinaryReader): EventCrosschainReadyToExecute;
}

export namespace EventCrosschainReadyToExecute {
  export type AsObject = {
    sourceChainId: string,
    requestIdentifier: number,
    claimHash: Uint8Array | string,
    feePayer: string,
    destTxFeeInRoute?: cosmos_base_v1beta1_coin_pb.Coin.AsObject,
    destGasLimit: number,
    destGasPrice: number,
    relayerIncentiveInRoute?: cosmos_base_v1beta1_coin_pb.Coin.AsObject,
  }
}

export class EventCrosschainExecuted extends jspb.Message {
  getAttestationId(): Uint8Array | string;
  getAttestationId_asU8(): Uint8Array;
  getAttestationId_asB64(): string;
  setAttestationId(value: Uint8Array | string): void;

  getSrcChainId(): string;
  setSrcChainId(value: string): void;

  getRequestIdentifier(): number;
  setRequestIdentifier(value: number): void;

  getExecResponse(): Uint8Array | string;
  getExecResponse_asU8(): Uint8Array;
  getExecResponse_asB64(): string;
  setExecResponse(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventCrosschainExecuted.AsObject;
  static toObject(includeInstance: boolean, msg: EventCrosschainExecuted): EventCrosschainExecuted.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventCrosschainExecuted, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventCrosschainExecuted;
  static deserializeBinaryFromReader(message: EventCrosschainExecuted, reader: jspb.BinaryReader): EventCrosschainExecuted;
}

export namespace EventCrosschainExecuted {
  export type AsObject = {
    attestationId: Uint8Array | string,
    srcChainId: string,
    requestIdentifier: number,
    execResponse: Uint8Array | string,
  }
}

export class EventCrosschainExecutionFailed extends jspb.Message {
  getAttestationId(): Uint8Array | string;
  getAttestationId_asU8(): Uint8Array;
  getAttestationId_asB64(): string;
  setAttestationId(value: Uint8Array | string): void;

  getSrcChainId(): string;
  setSrcChainId(value: string): void;

  getRequestIdentifier(): number;
  setRequestIdentifier(value: number): void;

  getExecErrResponse(): Uint8Array | string;
  getExecErrResponse_asU8(): Uint8Array;
  getExecErrResponse_asB64(): string;
  setExecErrResponse(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventCrosschainExecutionFailed.AsObject;
  static toObject(includeInstance: boolean, msg: EventCrosschainExecutionFailed): EventCrosschainExecutionFailed.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventCrosschainExecutionFailed, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventCrosschainExecutionFailed;
  static deserializeBinaryFromReader(message: EventCrosschainExecutionFailed, reader: jspb.BinaryReader): EventCrosschainExecutionFailed;
}

export namespace EventCrosschainExecutionFailed {
  export type AsObject = {
    attestationId: Uint8Array | string,
    srcChainId: string,
    requestIdentifier: number,
    execErrResponse: Uint8Array | string,
  }
}

export class EventCrosschainFeePayerUpdated extends jspb.Message {
  getSrcChainId(): string;
  setSrcChainId(value: string): void;

  getRequestIdentifier(): number;
  setRequestIdentifier(value: number): void;

  getClaimHash(): Uint8Array | string;
  getClaimHash_asU8(): Uint8Array;
  getClaimHash_asB64(): string;
  setClaimHash(value: Uint8Array | string): void;

  getFeePayer(): string;
  setFeePayer(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventCrosschainFeePayerUpdated.AsObject;
  static toObject(includeInstance: boolean, msg: EventCrosschainFeePayerUpdated): EventCrosschainFeePayerUpdated.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventCrosschainFeePayerUpdated, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventCrosschainFeePayerUpdated;
  static deserializeBinaryFromReader(message: EventCrosschainFeePayerUpdated, reader: jspb.BinaryReader): EventCrosschainFeePayerUpdated;
}

export namespace EventCrosschainFeePayerUpdated {
  export type AsObject = {
    srcChainId: string,
    requestIdentifier: number,
    claimHash: Uint8Array | string,
    feePayer: string,
  }
}

export class EventCrosschainDestGasIncremented extends jspb.Message {
  getSrcChainId(): string;
  setSrcChainId(value: string): void;

  getRequestIdentifier(): number;
  setRequestIdentifier(value: number): void;

  getClaimHash(): Uint8Array | string;
  getClaimHash_asU8(): Uint8Array;
  getClaimHash_asB64(): string;
  setClaimHash(value: Uint8Array | string): void;

  getFeePayer(): string;
  setFeePayer(value: string): void;

  getDestGasLimit(): number;
  setDestGasLimit(value: number): void;

  getDestGasPrice(): number;
  setDestGasPrice(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventCrosschainDestGasIncremented.AsObject;
  static toObject(includeInstance: boolean, msg: EventCrosschainDestGasIncremented): EventCrosschainDestGasIncremented.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventCrosschainDestGasIncremented, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventCrosschainDestGasIncremented;
  static deserializeBinaryFromReader(message: EventCrosschainDestGasIncremented, reader: jspb.BinaryReader): EventCrosschainDestGasIncremented;
}

export namespace EventCrosschainDestGasIncremented {
  export type AsObject = {
    srcChainId: string,
    requestIdentifier: number,
    claimHash: Uint8Array | string,
    feePayer: string,
    destGasLimit: number,
    destGasPrice: number,
  }
}

export class EventCrosschainRequestFeeSettlement extends jspb.Message {
  getSrcChainId(): string;
  setSrcChainId(value: string): void;

  getRequestIdentifier(): number;
  setRequestIdentifier(value: number): void;

  hasRelayerFeeInRoute(): boolean;
  clearRelayerFeeInRoute(): void;
  getRelayerFeeInRoute(): cosmos_base_v1beta1_coin_pb.Coin | undefined;
  setRelayerFeeInRoute(value?: cosmos_base_v1beta1_coin_pb.Coin): void;

  hasRefundFeeInRoute(): boolean;
  clearRefundFeeInRoute(): void;
  getRefundFeeInRoute(): cosmos_base_v1beta1_coin_pb.Coin | undefined;
  setRefundFeeInRoute(value?: cosmos_base_v1beta1_coin_pb.Coin): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventCrosschainRequestFeeSettlement.AsObject;
  static toObject(includeInstance: boolean, msg: EventCrosschainRequestFeeSettlement): EventCrosschainRequestFeeSettlement.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventCrosschainRequestFeeSettlement, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventCrosschainRequestFeeSettlement;
  static deserializeBinaryFromReader(message: EventCrosschainRequestFeeSettlement, reader: jspb.BinaryReader): EventCrosschainRequestFeeSettlement;
}

export namespace EventCrosschainRequestFeeSettlement {
  export type AsObject = {
    srcChainId: string,
    requestIdentifier: number,
    relayerFeeInRoute?: cosmos_base_v1beta1_coin_pb.Coin.AsObject,
    refundFeeInRoute?: cosmos_base_v1beta1_coin_pb.Coin.AsObject,
  }
}

export class EventCrosschainRequestCompleted extends jspb.Message {
  getSrcChainId(): string;
  setSrcChainId(value: string): void;

  getRequestIdentifier(): number;
  setRequestIdentifier(value: number): void;

  getClaimHash(): Uint8Array | string;
  getClaimHash_asU8(): Uint8Array;
  getClaimHash_asB64(): string;
  setClaimHash(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventCrosschainRequestCompleted.AsObject;
  static toObject(includeInstance: boolean, msg: EventCrosschainRequestCompleted): EventCrosschainRequestCompleted.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventCrosschainRequestCompleted, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventCrosschainRequestCompleted;
  static deserializeBinaryFromReader(message: EventCrosschainRequestCompleted, reader: jspb.BinaryReader): EventCrosschainRequestCompleted;
}

export namespace EventCrosschainRequestCompleted {
  export type AsObject = {
    srcChainId: string,
    requestIdentifier: number,
    claimHash: Uint8Array | string,
  }
}

export class EventCrosschainAckRequestCreated extends jspb.Message {
  getAttestationId(): Uint8Array | string;
  getAttestationId_asU8(): Uint8Array;
  getAttestationId_asB64(): string;
  setAttestationId(value: Uint8Array | string): void;

  getAckSrcChainId(): string;
  setAckSrcChainId(value: string): void;

  getAckRequestIdentifier(): number;
  setAckRequestIdentifier(value: number): void;

  getBlockHeight(): number;
  setBlockHeight(value: number): void;

  getDestTxHash(): string;
  setDestTxHash(value: string): void;

  getRelayerRouterAddress(): string;
  setRelayerRouterAddress(value: string): void;

  getAckDestChainId(): string;
  setAckDestChainId(value: string): void;

  getRequestSender(): string;
  setRequestSender(value: string): void;

  getRequestIdentifier(): number;
  setRequestIdentifier(value: number): void;

  getAckSrcChainType(): multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap];
  setAckSrcChainType(value: multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap]): void;

  getAckDestChainType(): multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap];
  setAckDestChainType(value: multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap]): void;

  getExecData(): Uint8Array | string;
  getExecData_asU8(): Uint8Array;
  getExecData_asB64(): string;
  setExecData(value: Uint8Array | string): void;

  getExecStatus(): boolean;
  setExecStatus(value: boolean): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventCrosschainAckRequestCreated.AsObject;
  static toObject(includeInstance: boolean, msg: EventCrosschainAckRequestCreated): EventCrosschainAckRequestCreated.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventCrosschainAckRequestCreated, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventCrosschainAckRequestCreated;
  static deserializeBinaryFromReader(message: EventCrosschainAckRequestCreated, reader: jspb.BinaryReader): EventCrosschainAckRequestCreated;
}

export namespace EventCrosschainAckRequestCreated {
  export type AsObject = {
    attestationId: Uint8Array | string,
    ackSrcChainId: string,
    ackRequestIdentifier: number,
    blockHeight: number,
    destTxHash: string,
    relayerRouterAddress: string,
    ackDestChainId: string,
    requestSender: string,
    requestIdentifier: number,
    ackSrcChainType: multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap],
    ackDestChainType: multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap],
    execData: Uint8Array | string,
    execStatus: boolean,
  }
}

export class EventCrosschainAckRequestConfirm extends jspb.Message {
  getAckSrcChainId(): string;
  setAckSrcChainId(value: string): void;

  getAckRequestIdentifier(): number;
  setAckRequestIdentifier(value: number): void;

  getClaimHash(): Uint8Array | string;
  getClaimHash_asU8(): Uint8Array;
  getClaimHash_asB64(): string;
  setClaimHash(value: Uint8Array | string): void;

  getEthSigner(): string;
  setEthSigner(value: string): void;

  getSignature(): string;
  setSignature(value: string): void;

  getOrchestrator(): string;
  setOrchestrator(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventCrosschainAckRequestConfirm.AsObject;
  static toObject(includeInstance: boolean, msg: EventCrosschainAckRequestConfirm): EventCrosschainAckRequestConfirm.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventCrosschainAckRequestConfirm, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventCrosschainAckRequestConfirm;
  static deserializeBinaryFromReader(message: EventCrosschainAckRequestConfirm, reader: jspb.BinaryReader): EventCrosschainAckRequestConfirm;
}

export namespace EventCrosschainAckRequestConfirm {
  export type AsObject = {
    ackSrcChainId: string,
    ackRequestIdentifier: number,
    claimHash: Uint8Array | string,
    ethSigner: string,
    signature: string,
    orchestrator: string,
  }
}

export class EventCrosschainAckReadyToExecute extends jspb.Message {
  getAckSrcChainId(): string;
  setAckSrcChainId(value: string): void;

  getAckRequestIdentifier(): number;
  setAckRequestIdentifier(value: number): void;

  getClaimHash(): Uint8Array | string;
  getClaimHash_asU8(): Uint8Array;
  getClaimHash_asB64(): string;
  setClaimHash(value: Uint8Array | string): void;

  getFeePayer(): string;
  setFeePayer(value: string): void;

  hasTxFeeInRoute(): boolean;
  clearTxFeeInRoute(): void;
  getTxFeeInRoute(): cosmos_base_v1beta1_coin_pb.Coin | undefined;
  setTxFeeInRoute(value?: cosmos_base_v1beta1_coin_pb.Coin): void;

  getAckGasLimit(): number;
  setAckGasLimit(value: number): void;

  getAckGasPrice(): number;
  setAckGasPrice(value: number): void;

  hasAckRelayerIncentiveInRoute(): boolean;
  clearAckRelayerIncentiveInRoute(): void;
  getAckRelayerIncentiveInRoute(): cosmos_base_v1beta1_coin_pb.Coin | undefined;
  setAckRelayerIncentiveInRoute(value?: cosmos_base_v1beta1_coin_pb.Coin): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventCrosschainAckReadyToExecute.AsObject;
  static toObject(includeInstance: boolean, msg: EventCrosschainAckReadyToExecute): EventCrosschainAckReadyToExecute.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventCrosschainAckReadyToExecute, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventCrosschainAckReadyToExecute;
  static deserializeBinaryFromReader(message: EventCrosschainAckReadyToExecute, reader: jspb.BinaryReader): EventCrosschainAckReadyToExecute;
}

export namespace EventCrosschainAckReadyToExecute {
  export type AsObject = {
    ackSrcChainId: string,
    ackRequestIdentifier: number,
    claimHash: Uint8Array | string,
    feePayer: string,
    txFeeInRoute?: cosmos_base_v1beta1_coin_pb.Coin.AsObject,
    ackGasLimit: number,
    ackGasPrice: number,
    ackRelayerIncentiveInRoute?: cosmos_base_v1beta1_coin_pb.Coin.AsObject,
  }
}

export class EventCrosschainAckExecuted extends jspb.Message {
  getAttestationId(): Uint8Array | string;
  getAttestationId_asU8(): Uint8Array;
  getAttestationId_asB64(): string;
  setAttestationId(value: Uint8Array | string): void;

  getAckSrcChainId(): string;
  setAckSrcChainId(value: string): void;

  getAckRequestIdentifier(): number;
  setAckRequestIdentifier(value: number): void;

  getAckExecResponse(): Uint8Array | string;
  getAckExecResponse_asU8(): Uint8Array;
  getAckExecResponse_asB64(): string;
  setAckExecResponse(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventCrosschainAckExecuted.AsObject;
  static toObject(includeInstance: boolean, msg: EventCrosschainAckExecuted): EventCrosschainAckExecuted.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventCrosschainAckExecuted, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventCrosschainAckExecuted;
  static deserializeBinaryFromReader(message: EventCrosschainAckExecuted, reader: jspb.BinaryReader): EventCrosschainAckExecuted;
}

export namespace EventCrosschainAckExecuted {
  export type AsObject = {
    attestationId: Uint8Array | string,
    ackSrcChainId: string,
    ackRequestIdentifier: number,
    ackExecResponse: Uint8Array | string,
  }
}

export class EventCrosschainAckExecutionFailed extends jspb.Message {
  getAttestationId(): Uint8Array | string;
  getAttestationId_asU8(): Uint8Array;
  getAttestationId_asB64(): string;
  setAttestationId(value: Uint8Array | string): void;

  getAckSrcChainId(): string;
  setAckSrcChainId(value: string): void;

  getAckRequestIdentifier(): number;
  setAckRequestIdentifier(value: number): void;

  getAckExecErrResponse(): Uint8Array | string;
  getAckExecErrResponse_asU8(): Uint8Array;
  getAckExecErrResponse_asB64(): string;
  setAckExecErrResponse(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventCrosschainAckExecutionFailed.AsObject;
  static toObject(includeInstance: boolean, msg: EventCrosschainAckExecutionFailed): EventCrosschainAckExecutionFailed.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventCrosschainAckExecutionFailed, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventCrosschainAckExecutionFailed;
  static deserializeBinaryFromReader(message: EventCrosschainAckExecutionFailed, reader: jspb.BinaryReader): EventCrosschainAckExecutionFailed;
}

export namespace EventCrosschainAckExecutionFailed {
  export type AsObject = {
    attestationId: Uint8Array | string,
    ackSrcChainId: string,
    ackRequestIdentifier: number,
    ackExecErrResponse: Uint8Array | string,
  }
}

export class EventCrosschainAckFeeSettlement extends jspb.Message {
  getAckSrcChainId(): string;
  setAckSrcChainId(value: string): void;

  getAckRequestIdentifier(): number;
  setAckRequestIdentifier(value: number): void;

  hasRelayerFeeInRoute(): boolean;
  clearRelayerFeeInRoute(): void;
  getRelayerFeeInRoute(): cosmos_base_v1beta1_coin_pb.Coin | undefined;
  setRelayerFeeInRoute(value?: cosmos_base_v1beta1_coin_pb.Coin): void;

  hasRefundFeeInRoute(): boolean;
  clearRefundFeeInRoute(): void;
  getRefundFeeInRoute(): cosmos_base_v1beta1_coin_pb.Coin | undefined;
  setRefundFeeInRoute(value?: cosmos_base_v1beta1_coin_pb.Coin): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventCrosschainAckFeeSettlement.AsObject;
  static toObject(includeInstance: boolean, msg: EventCrosschainAckFeeSettlement): EventCrosschainAckFeeSettlement.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventCrosschainAckFeeSettlement, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventCrosschainAckFeeSettlement;
  static deserializeBinaryFromReader(message: EventCrosschainAckFeeSettlement, reader: jspb.BinaryReader): EventCrosschainAckFeeSettlement;
}

export namespace EventCrosschainAckFeeSettlement {
  export type AsObject = {
    ackSrcChainId: string,
    ackRequestIdentifier: number,
    relayerFeeInRoute?: cosmos_base_v1beta1_coin_pb.Coin.AsObject,
    refundFeeInRoute?: cosmos_base_v1beta1_coin_pb.Coin.AsObject,
  }
}

export class EventCrosschainAckCompleted extends jspb.Message {
  getAckSrcChainId(): string;
  setAckSrcChainId(value: string): void;

  getAckRequestIdentifier(): number;
  setAckRequestIdentifier(value: number): void;

  getClaimHash(): Uint8Array | string;
  getClaimHash_asU8(): Uint8Array;
  getClaimHash_asB64(): string;
  setClaimHash(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventCrosschainAckCompleted.AsObject;
  static toObject(includeInstance: boolean, msg: EventCrosschainAckCompleted): EventCrosschainAckCompleted.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventCrosschainAckCompleted, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventCrosschainAckCompleted;
  static deserializeBinaryFromReader(message: EventCrosschainAckCompleted, reader: jspb.BinaryReader): EventCrosschainAckCompleted;
}

export namespace EventCrosschainAckCompleted {
  export type AsObject = {
    ackSrcChainId: string,
    ackRequestIdentifier: number,
    claimHash: Uint8Array | string,
  }
}

export class EventCrosschainAckGasIncremented extends jspb.Message {
  getAckSrcChainType(): string;
  setAckSrcChainType(value: string): void;

  getAckRequestIdentifier(): number;
  setAckRequestIdentifier(value: number): void;

  getClaimHash(): Uint8Array | string;
  getClaimHash_asU8(): Uint8Array;
  getClaimHash_asB64(): string;
  setClaimHash(value: Uint8Array | string): void;

  getFeePayer(): string;
  setFeePayer(value: string): void;

  getAckGasLimit(): number;
  setAckGasLimit(value: number): void;

  getAckGasPrice(): number;
  setAckGasPrice(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventCrosschainAckGasIncremented.AsObject;
  static toObject(includeInstance: boolean, msg: EventCrosschainAckGasIncremented): EventCrosschainAckGasIncremented.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventCrosschainAckGasIncremented, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventCrosschainAckGasIncremented;
  static deserializeBinaryFromReader(message: EventCrosschainAckGasIncremented, reader: jspb.BinaryReader): EventCrosschainAckGasIncremented;
}

export namespace EventCrosschainAckGasIncremented {
  export type AsObject = {
    ackSrcChainType: string,
    ackRequestIdentifier: number,
    claimHash: Uint8Array | string,
    feePayer: string,
    ackGasLimit: number,
    ackGasPrice: number,
  }
}

export class EventCrosschainAckReceiptCreated extends jspb.Message {
  getAttestationId(): Uint8Array | string;
  getAttestationId_asU8(): Uint8Array;
  getAttestationId_asB64(): string;
  setAttestationId(value: Uint8Array | string): void;

  getAckReceiptSrcChainId(): string;
  setAckReceiptSrcChainId(value: string): void;

  getAckReceiptIdentifier(): number;
  setAckReceiptIdentifier(value: number): void;

  getAckReceiptBlockHeight(): number;
  setAckReceiptBlockHeight(value: number): void;

  getAckReceiptTxHash(): string;
  setAckReceiptTxHash(value: string): void;

  getRelayerRouterAddress(): string;
  setRelayerRouterAddress(value: string): void;

  getRequestIdentifier(): number;
  setRequestIdentifier(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventCrosschainAckReceiptCreated.AsObject;
  static toObject(includeInstance: boolean, msg: EventCrosschainAckReceiptCreated): EventCrosschainAckReceiptCreated.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventCrosschainAckReceiptCreated, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventCrosschainAckReceiptCreated;
  static deserializeBinaryFromReader(message: EventCrosschainAckReceiptCreated, reader: jspb.BinaryReader): EventCrosschainAckReceiptCreated;
}

export namespace EventCrosschainAckReceiptCreated {
  export type AsObject = {
    attestationId: Uint8Array | string,
    ackReceiptSrcChainId: string,
    ackReceiptIdentifier: number,
    ackReceiptBlockHeight: number,
    ackReceiptTxHash: string,
    relayerRouterAddress: string,
    requestIdentifier: number,
  }
}

export class EventCrosschainReceiptCompleted extends jspb.Message {
  getAckReceiptSrcChainId(): string;
  setAckReceiptSrcChainId(value: string): void;

  getAckReceiptIdentifier(): number;
  setAckReceiptIdentifier(value: number): void;

  getClaimHash(): Uint8Array | string;
  getClaimHash_asU8(): Uint8Array;
  getClaimHash_asB64(): string;
  setClaimHash(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventCrosschainReceiptCompleted.AsObject;
  static toObject(includeInstance: boolean, msg: EventCrosschainReceiptCompleted): EventCrosschainReceiptCompleted.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventCrosschainReceiptCompleted, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventCrosschainReceiptCompleted;
  static deserializeBinaryFromReader(message: EventCrosschainReceiptCompleted, reader: jspb.BinaryReader): EventCrosschainReceiptCompleted;
}

export namespace EventCrosschainReceiptCompleted {
  export type AsObject = {
    ackReceiptSrcChainId: string,
    ackReceiptIdentifier: number,
    claimHash: Uint8Array | string,
  }
}

