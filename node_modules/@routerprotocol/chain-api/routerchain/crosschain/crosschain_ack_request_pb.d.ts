// package: routerprotocol.routerchain.crosschain
// file: routerchain/crosschain/crosschain_ack_request.proto

import * as jspb from "google-protobuf";
import * as multichain_chain_type_pb from "../../multichain/chain_type_pb";
import * as cosmos_base_v1beta1_coin_pb from "../../cosmos/base/v1beta1/coin_pb";
import * as gogoproto_gogo_pb from "../../gogoproto/gogo_pb";
import * as routerchain_crosschain_crosschain_ack_tx_status_pb from "../../routerchain/crosschain/crosschain_ack_tx_status_pb";

export class CrosschainAckRequest extends jspb.Message {
  getAckSrcChainId(): string;
  setAckSrcChainId(value: string): void;

  getContract(): string;
  setContract(value: string): void;

  getAckRequestIdentifier(): number;
  setAckRequestIdentifier(value: number): void;

  getBlockheight(): number;
  setBlockheight(value: number): void;

  getDesttxhash(): string;
  setDesttxhash(value: string): void;

  getRelayerrouteraddress(): string;
  setRelayerrouteraddress(value: string): void;

  getAckDestChainId(): string;
  setAckDestChainId(value: string): void;

  getRequestSender(): string;
  setRequestSender(value: string): void;

  getRequestidentifier(): number;
  setRequestidentifier(value: number): void;

  getAckSrcChainType(): multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap];
  setAckSrcChainType(value: multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap]): void;

  getAckDestChainType(): multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap];
  setAckDestChainType(value: multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap]): void;

  getFeeconsumed(): number;
  setFeeconsumed(value: number): void;

  getExecdata(): Uint8Array | string;
  getExecdata_asU8(): Uint8Array;
  getExecdata_asB64(): string;
  setExecdata(value: Uint8Array | string): void;

  getExecstatus(): boolean;
  setExecstatus(value: boolean): void;

  getEthsigner(): string;
  setEthsigner(value: string): void;

  getSignature(): string;
  setSignature(value: string): void;

  getAckGasLimit(): number;
  setAckGasLimit(value: number): void;

  getAckGasPrice(): number;
  setAckGasPrice(value: number): void;

  hasAckFeeDeducted(): boolean;
  clearAckFeeDeducted(): void;
  getAckFeeDeducted(): cosmos_base_v1beta1_coin_pb.Coin | undefined;
  setAckFeeDeducted(value?: cosmos_base_v1beta1_coin_pb.Coin): void;

  hasAckRelayerIncentive(): boolean;
  clearAckRelayerIncentive(): void;
  getAckRelayerIncentive(): cosmos_base_v1beta1_coin_pb.Coin | undefined;
  setAckRelayerIncentive(value?: cosmos_base_v1beta1_coin_pb.Coin): void;

  getStatus(): routerchain_crosschain_crosschain_ack_tx_status_pb.CrosschainAckTxStatusMap[keyof routerchain_crosschain_crosschain_ack_tx_status_pb.CrosschainAckTxStatusMap];
  setStatus(value: routerchain_crosschain_crosschain_ack_tx_status_pb.CrosschainAckTxStatusMap[keyof routerchain_crosschain_crosschain_ack_tx_status_pb.CrosschainAckTxStatusMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): CrosschainAckRequest.AsObject;
  static toObject(includeInstance: boolean, msg: CrosschainAckRequest): CrosschainAckRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: CrosschainAckRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): CrosschainAckRequest;
  static deserializeBinaryFromReader(message: CrosschainAckRequest, reader: jspb.BinaryReader): CrosschainAckRequest;
}

export namespace CrosschainAckRequest {
  export type AsObject = {
    ackSrcChainId: string,
    contract: string,
    ackRequestIdentifier: number,
    blockheight: number,
    desttxhash: string,
    relayerrouteraddress: string,
    ackDestChainId: string,
    requestSender: string,
    requestidentifier: number,
    ackSrcChainType: multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap],
    ackDestChainType: multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap],
    feeconsumed: number,
    execdata: Uint8Array | string,
    execstatus: boolean,
    ethsigner: string,
    signature: string,
    ackGasLimit: number,
    ackGasPrice: number,
    ackFeeDeducted?: cosmos_base_v1beta1_coin_pb.Coin.AsObject,
    ackRelayerIncentive?: cosmos_base_v1beta1_coin_pb.Coin.AsObject,
    status: routerchain_crosschain_crosschain_ack_tx_status_pb.CrosschainAckTxStatusMap[keyof routerchain_crosschain_crosschain_ack_tx_status_pb.CrosschainAckTxStatusMap],
  }
}

export class CrosschainAckRequestClaimHash extends jspb.Message {
  getAckSrcChainId(): string;
  setAckSrcChainId(value: string): void;

  getContract(): string;
  setContract(value: string): void;

  getAckRequestIdentifier(): number;
  setAckRequestIdentifier(value: number): void;

  getBlockheight(): number;
  setBlockheight(value: number): void;

  getDesttxhash(): string;
  setDesttxhash(value: string): void;

  getRelayerrouteraddress(): string;
  setRelayerrouteraddress(value: string): void;

  getAckDestChainId(): string;
  setAckDestChainId(value: string): void;

  getRequestSender(): string;
  setRequestSender(value: string): void;

  getRequestidentifier(): number;
  setRequestidentifier(value: number): void;

  getAckSrcChainType(): multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap];
  setAckSrcChainType(value: multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap]): void;

  getAckDestChainType(): multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap];
  setAckDestChainType(value: multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap]): void;

  getFeeconsumed(): number;
  setFeeconsumed(value: number): void;

  getExecdata(): Uint8Array | string;
  getExecdata_asU8(): Uint8Array;
  getExecdata_asB64(): string;
  setExecdata(value: Uint8Array | string): void;

  getExecstatus(): boolean;
  setExecstatus(value: boolean): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): CrosschainAckRequestClaimHash.AsObject;
  static toObject(includeInstance: boolean, msg: CrosschainAckRequestClaimHash): CrosschainAckRequestClaimHash.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: CrosschainAckRequestClaimHash, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): CrosschainAckRequestClaimHash;
  static deserializeBinaryFromReader(message: CrosschainAckRequestClaimHash, reader: jspb.BinaryReader): CrosschainAckRequestClaimHash;
}

export namespace CrosschainAckRequestClaimHash {
  export type AsObject = {
    ackSrcChainId: string,
    contract: string,
    ackRequestIdentifier: number,
    blockheight: number,
    desttxhash: string,
    relayerrouteraddress: string,
    ackDestChainId: string,
    requestSender: string,
    requestidentifier: number,
    ackSrcChainType: multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap],
    ackDestChainType: multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap],
    feeconsumed: number,
    execdata: Uint8Array | string,
    execstatus: boolean,
  }
}

