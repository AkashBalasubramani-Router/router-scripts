// package: routerprotocol.routerchain.multichain
// file: multichain/chain_config.proto

import * as jspb from "google-protobuf";
import * as multichain_chain_type_pb from "../multichain/chain_type_pb";
import * as cosmos_base_v1beta1_coin_pb from "../cosmos/base/v1beta1/coin_pb";
import * as gogoproto_gogo_pb from "../gogoproto/gogo_pb";
import * as google_protobuf_any_pb from "google-protobuf/google/protobuf/any_pb";

export class ContractConfig extends jspb.Message {
  getChainid(): string;
  setChainid(value: string): void;

  getContractaddress(): string;
  setContractaddress(value: string): void;

  getContractheight(): number;
  setContractheight(value: number): void;

  getLastobservedeventnonce(): number;
  setLastobservedeventnonce(value: number): void;

  getLastobservedeventblockheight(): number;
  setLastobservedeventblockheight(value: number): void;

  getContracttype(): ContractTypeMap[keyof ContractTypeMap];
  setContracttype(value: ContractTypeMap[keyof ContractTypeMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ContractConfig.AsObject;
  static toObject(includeInstance: boolean, msg: ContractConfig): ContractConfig.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ContractConfig, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ContractConfig;
  static deserializeBinaryFromReader(message: ContractConfig, reader: jspb.BinaryReader): ContractConfig;
}

export namespace ContractConfig {
  export type AsObject = {
    chainid: string,
    contractaddress: string,
    contractheight: number,
    lastobservedeventnonce: number,
    lastobservedeventblockheight: number,
    contracttype: ContractTypeMap[keyof ContractTypeMap],
  }
}

export class ChainConfig extends jspb.Message {
  getChainid(): string;
  setChainid(value: string): void;

  getChainname(): string;
  setChainname(value: string): void;

  getSymbol(): string;
  setSymbol(value: string): void;

  getNativeDecimals(): number;
  setNativeDecimals(value: number): void;

  getChaintype(): multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap];
  setChaintype(value: multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap]): void;

  getConfirmationsrequired(): number;
  setConfirmationsrequired(value: number): void;

  getLastobservedvalsetnonce(): number;
  setLastobservedvalsetnonce(value: number): void;

  getChainEnabled(): boolean;
  setChainEnabled(value: boolean): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChainConfig.AsObject;
  static toObject(includeInstance: boolean, msg: ChainConfig): ChainConfig.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChainConfig, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChainConfig;
  static deserializeBinaryFromReader(message: ChainConfig, reader: jspb.BinaryReader): ChainConfig;
}

export namespace ChainConfig {
  export type AsObject = {
    chainid: string,
    chainname: string,
    symbol: string,
    nativeDecimals: number,
    chaintype: multichain_chain_type_pb.ChainTypeMap[keyof multichain_chain_type_pb.ChainTypeMap],
    confirmationsrequired: number,
    lastobservedvalsetnonce: number,
    chainEnabled: boolean,
  }
}

export interface ContractTypeMap {
  GATEWAY: 0;
  VOYAGER: 1;
}

export const ContractType: ContractTypeMap;

