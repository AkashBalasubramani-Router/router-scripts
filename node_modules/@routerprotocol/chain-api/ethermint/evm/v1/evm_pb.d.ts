// package: ethermint.evm.v1
// file: ethermint/evm/v1/evm.proto

import * as jspb from "google-protobuf";
import * as gogoproto_gogo_pb from "../../../gogoproto/gogo_pb";

export class Params extends jspb.Message {
  getEvmDenom(): string;
  setEvmDenom(value: string): void;

  getEnableCreate(): boolean;
  setEnableCreate(value: boolean): void;

  getEnableCall(): boolean;
  setEnableCall(value: boolean): void;

  clearExtraEipsList(): void;
  getExtraEipsList(): Array<number>;
  setExtraEipsList(value: Array<number>): void;
  addExtraEips(value: number, index?: number): number;

  hasChainConfig(): boolean;
  clearChainConfig(): void;
  getChainConfig(): ChainConfig | undefined;
  setChainConfig(value?: ChainConfig): void;

  getAllowUnprotectedTxs(): boolean;
  setAllowUnprotectedTxs(value: boolean): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Params.AsObject;
  static toObject(includeInstance: boolean, msg: Params): Params.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Params, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Params;
  static deserializeBinaryFromReader(message: Params, reader: jspb.BinaryReader): Params;
}

export namespace Params {
  export type AsObject = {
    evmDenom: string,
    enableCreate: boolean,
    enableCall: boolean,
    extraEipsList: Array<number>,
    chainConfig?: ChainConfig.AsObject,
    allowUnprotectedTxs: boolean,
  }
}

export class ChainConfig extends jspb.Message {
  getHomesteadBlock(): string;
  setHomesteadBlock(value: string): void;

  getDaoForkBlock(): string;
  setDaoForkBlock(value: string): void;

  getDaoForkSupport(): boolean;
  setDaoForkSupport(value: boolean): void;

  getEip150Block(): string;
  setEip150Block(value: string): void;

  getEip150Hash(): string;
  setEip150Hash(value: string): void;

  getEip155Block(): string;
  setEip155Block(value: string): void;

  getEip158Block(): string;
  setEip158Block(value: string): void;

  getByzantiumBlock(): string;
  setByzantiumBlock(value: string): void;

  getConstantinopleBlock(): string;
  setConstantinopleBlock(value: string): void;

  getPetersburgBlock(): string;
  setPetersburgBlock(value: string): void;

  getIstanbulBlock(): string;
  setIstanbulBlock(value: string): void;

  getMuirGlacierBlock(): string;
  setMuirGlacierBlock(value: string): void;

  getBerlinBlock(): string;
  setBerlinBlock(value: string): void;

  getLondonBlock(): string;
  setLondonBlock(value: string): void;

  getArrowGlacierBlock(): string;
  setArrowGlacierBlock(value: string): void;

  getGrayGlacierBlock(): string;
  setGrayGlacierBlock(value: string): void;

  getMergeNetsplitBlock(): string;
  setMergeNetsplitBlock(value: string): void;

  getShanghaiBlock(): string;
  setShanghaiBlock(value: string): void;

  getCancunBlock(): string;
  setCancunBlock(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChainConfig.AsObject;
  static toObject(includeInstance: boolean, msg: ChainConfig): ChainConfig.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChainConfig, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChainConfig;
  static deserializeBinaryFromReader(message: ChainConfig, reader: jspb.BinaryReader): ChainConfig;
}

export namespace ChainConfig {
  export type AsObject = {
    homesteadBlock: string,
    daoForkBlock: string,
    daoForkSupport: boolean,
    eip150Block: string,
    eip150Hash: string,
    eip155Block: string,
    eip158Block: string,
    byzantiumBlock: string,
    constantinopleBlock: string,
    petersburgBlock: string,
    istanbulBlock: string,
    muirGlacierBlock: string,
    berlinBlock: string,
    londonBlock: string,
    arrowGlacierBlock: string,
    grayGlacierBlock: string,
    mergeNetsplitBlock: string,
    shanghaiBlock: string,
    cancunBlock: string,
  }
}

export class State extends jspb.Message {
  getKey(): string;
  setKey(value: string): void;

  getValue(): string;
  setValue(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): State.AsObject;
  static toObject(includeInstance: boolean, msg: State): State.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: State, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): State;
  static deserializeBinaryFromReader(message: State, reader: jspb.BinaryReader): State;
}

export namespace State {
  export type AsObject = {
    key: string,
    value: string,
  }
}

export class TransactionLogs extends jspb.Message {
  getHash(): string;
  setHash(value: string): void;

  clearLogsList(): void;
  getLogsList(): Array<Log>;
  setLogsList(value: Array<Log>): void;
  addLogs(value?: Log, index?: number): Log;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TransactionLogs.AsObject;
  static toObject(includeInstance: boolean, msg: TransactionLogs): TransactionLogs.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TransactionLogs, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TransactionLogs;
  static deserializeBinaryFromReader(message: TransactionLogs, reader: jspb.BinaryReader): TransactionLogs;
}

export namespace TransactionLogs {
  export type AsObject = {
    hash: string,
    logsList: Array<Log.AsObject>,
  }
}

export class Log extends jspb.Message {
  getAddress(): string;
  setAddress(value: string): void;

  clearTopicsList(): void;
  getTopicsList(): Array<string>;
  setTopicsList(value: Array<string>): void;
  addTopics(value: string, index?: number): string;

  getData(): Uint8Array | string;
  getData_asU8(): Uint8Array;
  getData_asB64(): string;
  setData(value: Uint8Array | string): void;

  getBlockNumber(): number;
  setBlockNumber(value: number): void;

  getTxHash(): string;
  setTxHash(value: string): void;

  getTxIndex(): number;
  setTxIndex(value: number): void;

  getBlockHash(): string;
  setBlockHash(value: string): void;

  getIndex(): number;
  setIndex(value: number): void;

  getRemoved(): boolean;
  setRemoved(value: boolean): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Log.AsObject;
  static toObject(includeInstance: boolean, msg: Log): Log.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Log, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Log;
  static deserializeBinaryFromReader(message: Log, reader: jspb.BinaryReader): Log;
}

export namespace Log {
  export type AsObject = {
    address: string,
    topicsList: Array<string>,
    data: Uint8Array | string,
    blockNumber: number,
    txHash: string,
    txIndex: number,
    blockHash: string,
    index: number,
    removed: boolean,
  }
}

export class TxResult extends jspb.Message {
  getContractAddress(): string;
  setContractAddress(value: string): void;

  getBloom(): Uint8Array | string;
  getBloom_asU8(): Uint8Array;
  getBloom_asB64(): string;
  setBloom(value: Uint8Array | string): void;

  hasTxLogs(): boolean;
  clearTxLogs(): void;
  getTxLogs(): TransactionLogs | undefined;
  setTxLogs(value?: TransactionLogs): void;

  getRet(): Uint8Array | string;
  getRet_asU8(): Uint8Array;
  getRet_asB64(): string;
  setRet(value: Uint8Array | string): void;

  getReverted(): boolean;
  setReverted(value: boolean): void;

  getGasUsed(): number;
  setGasUsed(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TxResult.AsObject;
  static toObject(includeInstance: boolean, msg: TxResult): TxResult.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TxResult, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TxResult;
  static deserializeBinaryFromReader(message: TxResult, reader: jspb.BinaryReader): TxResult;
}

export namespace TxResult {
  export type AsObject = {
    contractAddress: string,
    bloom: Uint8Array | string,
    txLogs?: TransactionLogs.AsObject,
    ret: Uint8Array | string,
    reverted: boolean,
    gasUsed: number,
  }
}

export class AccessTuple extends jspb.Message {
  getAddress(): string;
  setAddress(value: string): void;

  clearStorageKeysList(): void;
  getStorageKeysList(): Array<string>;
  setStorageKeysList(value: Array<string>): void;
  addStorageKeys(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): AccessTuple.AsObject;
  static toObject(includeInstance: boolean, msg: AccessTuple): AccessTuple.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: AccessTuple, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): AccessTuple;
  static deserializeBinaryFromReader(message: AccessTuple, reader: jspb.BinaryReader): AccessTuple;
}

export namespace AccessTuple {
  export type AsObject = {
    address: string,
    storageKeysList: Array<string>,
  }
}

export class TraceConfig extends jspb.Message {
  getTracer(): string;
  setTracer(value: string): void;

  getTimeout(): string;
  setTimeout(value: string): void;

  getReexec(): number;
  setReexec(value: number): void;

  getDisableStack(): boolean;
  setDisableStack(value: boolean): void;

  getDisableStorage(): boolean;
  setDisableStorage(value: boolean): void;

  getDebug(): boolean;
  setDebug(value: boolean): void;

  getLimit(): number;
  setLimit(value: number): void;

  hasOverrides(): boolean;
  clearOverrides(): void;
  getOverrides(): ChainConfig | undefined;
  setOverrides(value?: ChainConfig): void;

  getEnableMemory(): boolean;
  setEnableMemory(value: boolean): void;

  getEnableReturnData(): boolean;
  setEnableReturnData(value: boolean): void;

  getTracerJsonConfig(): string;
  setTracerJsonConfig(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TraceConfig.AsObject;
  static toObject(includeInstance: boolean, msg: TraceConfig): TraceConfig.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TraceConfig, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TraceConfig;
  static deserializeBinaryFromReader(message: TraceConfig, reader: jspb.BinaryReader): TraceConfig;
}

export namespace TraceConfig {
  export type AsObject = {
    tracer: string,
    timeout: string,
    reexec: number,
    disableStack: boolean,
    disableStorage: boolean,
    debug: boolean,
    limit: number,
    overrides?: ChainConfig.AsObject,
    enableMemory: boolean,
    enableReturnData: boolean,
    tracerJsonConfig: string,
  }
}

