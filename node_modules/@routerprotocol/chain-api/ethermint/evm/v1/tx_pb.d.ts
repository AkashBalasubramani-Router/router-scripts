// package: ethermint.evm.v1
// file: ethermint/evm/v1/tx.proto

import * as jspb from "google-protobuf";
import * as cosmos_msg_v1_msg_pb from "../../../cosmos/msg/v1/msg_pb";
import * as cosmos_proto_cosmos_pb from "../../../cosmos_proto/cosmos_pb";
import * as ethermint_evm_v1_evm_pb from "../../../ethermint/evm/v1/evm_pb";
import * as gogoproto_gogo_pb from "../../../gogoproto/gogo_pb";
import * as google_api_annotations_pb from "../../../google/api/annotations_pb";
import * as google_protobuf_any_pb from "google-protobuf/google/protobuf/any_pb";

export class MsgEthereumTx extends jspb.Message {
  hasData(): boolean;
  clearData(): void;
  getData(): google_protobuf_any_pb.Any | undefined;
  setData(value?: google_protobuf_any_pb.Any): void;

  getSize(): number;
  setSize(value: number): void;

  getHash(): string;
  setHash(value: string): void;

  getFrom(): string;
  setFrom(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgEthereumTx.AsObject;
  static toObject(includeInstance: boolean, msg: MsgEthereumTx): MsgEthereumTx.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgEthereumTx, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgEthereumTx;
  static deserializeBinaryFromReader(message: MsgEthereumTx, reader: jspb.BinaryReader): MsgEthereumTx;
}

export namespace MsgEthereumTx {
  export type AsObject = {
    data?: google_protobuf_any_pb.Any.AsObject,
    size: number,
    hash: string,
    from: string,
  }
}

export class LegacyTx extends jspb.Message {
  getNonce(): number;
  setNonce(value: number): void;

  getGasPrice(): string;
  setGasPrice(value: string): void;

  getGas(): number;
  setGas(value: number): void;

  getTo(): string;
  setTo(value: string): void;

  getValue(): string;
  setValue(value: string): void;

  getData(): Uint8Array | string;
  getData_asU8(): Uint8Array;
  getData_asB64(): string;
  setData(value: Uint8Array | string): void;

  getV(): Uint8Array | string;
  getV_asU8(): Uint8Array;
  getV_asB64(): string;
  setV(value: Uint8Array | string): void;

  getR(): Uint8Array | string;
  getR_asU8(): Uint8Array;
  getR_asB64(): string;
  setR(value: Uint8Array | string): void;

  getS(): Uint8Array | string;
  getS_asU8(): Uint8Array;
  getS_asB64(): string;
  setS(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): LegacyTx.AsObject;
  static toObject(includeInstance: boolean, msg: LegacyTx): LegacyTx.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: LegacyTx, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): LegacyTx;
  static deserializeBinaryFromReader(message: LegacyTx, reader: jspb.BinaryReader): LegacyTx;
}

export namespace LegacyTx {
  export type AsObject = {
    nonce: number,
    gasPrice: string,
    gas: number,
    to: string,
    value: string,
    data: Uint8Array | string,
    v: Uint8Array | string,
    r: Uint8Array | string,
    s: Uint8Array | string,
  }
}

export class AccessListTx extends jspb.Message {
  getChainId(): string;
  setChainId(value: string): void;

  getNonce(): number;
  setNonce(value: number): void;

  getGasPrice(): string;
  setGasPrice(value: string): void;

  getGas(): number;
  setGas(value: number): void;

  getTo(): string;
  setTo(value: string): void;

  getValue(): string;
  setValue(value: string): void;

  getData(): Uint8Array | string;
  getData_asU8(): Uint8Array;
  getData_asB64(): string;
  setData(value: Uint8Array | string): void;

  clearAccessesList(): void;
  getAccessesList(): Array<ethermint_evm_v1_evm_pb.AccessTuple>;
  setAccessesList(value: Array<ethermint_evm_v1_evm_pb.AccessTuple>): void;
  addAccesses(value?: ethermint_evm_v1_evm_pb.AccessTuple, index?: number): ethermint_evm_v1_evm_pb.AccessTuple;

  getV(): Uint8Array | string;
  getV_asU8(): Uint8Array;
  getV_asB64(): string;
  setV(value: Uint8Array | string): void;

  getR(): Uint8Array | string;
  getR_asU8(): Uint8Array;
  getR_asB64(): string;
  setR(value: Uint8Array | string): void;

  getS(): Uint8Array | string;
  getS_asU8(): Uint8Array;
  getS_asB64(): string;
  setS(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): AccessListTx.AsObject;
  static toObject(includeInstance: boolean, msg: AccessListTx): AccessListTx.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: AccessListTx, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): AccessListTx;
  static deserializeBinaryFromReader(message: AccessListTx, reader: jspb.BinaryReader): AccessListTx;
}

export namespace AccessListTx {
  export type AsObject = {
    chainId: string,
    nonce: number,
    gasPrice: string,
    gas: number,
    to: string,
    value: string,
    data: Uint8Array | string,
    accessesList: Array<ethermint_evm_v1_evm_pb.AccessTuple.AsObject>,
    v: Uint8Array | string,
    r: Uint8Array | string,
    s: Uint8Array | string,
  }
}

export class DynamicFeeTx extends jspb.Message {
  getChainId(): string;
  setChainId(value: string): void;

  getNonce(): number;
  setNonce(value: number): void;

  getGasTipCap(): string;
  setGasTipCap(value: string): void;

  getGasFeeCap(): string;
  setGasFeeCap(value: string): void;

  getGas(): number;
  setGas(value: number): void;

  getTo(): string;
  setTo(value: string): void;

  getValue(): string;
  setValue(value: string): void;

  getData(): Uint8Array | string;
  getData_asU8(): Uint8Array;
  getData_asB64(): string;
  setData(value: Uint8Array | string): void;

  clearAccessesList(): void;
  getAccessesList(): Array<ethermint_evm_v1_evm_pb.AccessTuple>;
  setAccessesList(value: Array<ethermint_evm_v1_evm_pb.AccessTuple>): void;
  addAccesses(value?: ethermint_evm_v1_evm_pb.AccessTuple, index?: number): ethermint_evm_v1_evm_pb.AccessTuple;

  getV(): Uint8Array | string;
  getV_asU8(): Uint8Array;
  getV_asB64(): string;
  setV(value: Uint8Array | string): void;

  getR(): Uint8Array | string;
  getR_asU8(): Uint8Array;
  getR_asB64(): string;
  setR(value: Uint8Array | string): void;

  getS(): Uint8Array | string;
  getS_asU8(): Uint8Array;
  getS_asB64(): string;
  setS(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DynamicFeeTx.AsObject;
  static toObject(includeInstance: boolean, msg: DynamicFeeTx): DynamicFeeTx.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DynamicFeeTx, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DynamicFeeTx;
  static deserializeBinaryFromReader(message: DynamicFeeTx, reader: jspb.BinaryReader): DynamicFeeTx;
}

export namespace DynamicFeeTx {
  export type AsObject = {
    chainId: string,
    nonce: number,
    gasTipCap: string,
    gasFeeCap: string,
    gas: number,
    to: string,
    value: string,
    data: Uint8Array | string,
    accessesList: Array<ethermint_evm_v1_evm_pb.AccessTuple.AsObject>,
    v: Uint8Array | string,
    r: Uint8Array | string,
    s: Uint8Array | string,
  }
}

export class ExtensionOptionsEthereumTx extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ExtensionOptionsEthereumTx.AsObject;
  static toObject(includeInstance: boolean, msg: ExtensionOptionsEthereumTx): ExtensionOptionsEthereumTx.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ExtensionOptionsEthereumTx, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ExtensionOptionsEthereumTx;
  static deserializeBinaryFromReader(message: ExtensionOptionsEthereumTx, reader: jspb.BinaryReader): ExtensionOptionsEthereumTx;
}

export namespace ExtensionOptionsEthereumTx {
  export type AsObject = {
  }
}

export class MsgEthereumTxResponse extends jspb.Message {
  getHash(): string;
  setHash(value: string): void;

  clearLogsList(): void;
  getLogsList(): Array<ethermint_evm_v1_evm_pb.Log>;
  setLogsList(value: Array<ethermint_evm_v1_evm_pb.Log>): void;
  addLogs(value?: ethermint_evm_v1_evm_pb.Log, index?: number): ethermint_evm_v1_evm_pb.Log;

  getRet(): Uint8Array | string;
  getRet_asU8(): Uint8Array;
  getRet_asB64(): string;
  setRet(value: Uint8Array | string): void;

  getVmError(): string;
  setVmError(value: string): void;

  getGasUsed(): number;
  setGasUsed(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgEthereumTxResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgEthereumTxResponse): MsgEthereumTxResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgEthereumTxResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgEthereumTxResponse;
  static deserializeBinaryFromReader(message: MsgEthereumTxResponse, reader: jspb.BinaryReader): MsgEthereumTxResponse;
}

export namespace MsgEthereumTxResponse {
  export type AsObject = {
    hash: string,
    logsList: Array<ethermint_evm_v1_evm_pb.Log.AsObject>,
    ret: Uint8Array | string,
    vmError: string,
    gasUsed: number,
  }
}

export class MsgUpdateParams extends jspb.Message {
  getAuthority(): string;
  setAuthority(value: string): void;

  hasParams(): boolean;
  clearParams(): void;
  getParams(): ethermint_evm_v1_evm_pb.Params | undefined;
  setParams(value?: ethermint_evm_v1_evm_pb.Params): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgUpdateParams.AsObject;
  static toObject(includeInstance: boolean, msg: MsgUpdateParams): MsgUpdateParams.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgUpdateParams, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgUpdateParams;
  static deserializeBinaryFromReader(message: MsgUpdateParams, reader: jspb.BinaryReader): MsgUpdateParams;
}

export namespace MsgUpdateParams {
  export type AsObject = {
    authority: string,
    params?: ethermint_evm_v1_evm_pb.Params.AsObject,
  }
}

export class MsgUpdateParamsResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgUpdateParamsResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgUpdateParamsResponse): MsgUpdateParamsResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgUpdateParamsResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgUpdateParamsResponse;
  static deserializeBinaryFromReader(message: MsgUpdateParamsResponse, reader: jspb.BinaryReader): MsgUpdateParamsResponse;
}

export namespace MsgUpdateParamsResponse {
  export type AsObject = {
  }
}

