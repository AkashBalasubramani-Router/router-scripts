import { TxRaw } from '@routerprotocol/chain-api/cosmos/tx/v1beta1/tx_pb';
import { HttpClient } from '../../utils/classes';
import { Wait, Block, Sync, TxSuccess, TxBroadcastResult, TxError, TxInfo, TxResult, BroadcastMode, WaitTxBroadcastResult, SyncTxBroadcastResult, BlockTxBroadcastResult, TxSearchResult } from '../../types/tx-rest-client';
import { APIParams, TxSearchOptions } from '../../types/rest-client';
export declare function isTxError<C extends TxSuccess | TxError | {}, B extends Wait | Block | Sync, T extends TxBroadcastResult<B, C>>(x: T): x is T & TxBroadcastResult<B, TxError>;
export declare class TxRestClient {
    httpClient: HttpClient;
    constructor(endpoint: string);
    txInfo(txHash: string, params?: APIParams): Promise<TxResult>;
    txInfosByHeight(height: number | undefined): Promise<TxInfo[]>;
    waitTxBroadcast(txHash: string, timeout?: number): Promise<{
        txhash: string;
        raw_log: string;
        gas_wanted: number;
        gas_used: number;
        height: number;
        logs: import("../../types/tx-rest-client").TxLog[];
        code: number;
        codespace: string;
        timestamp: string;
    }>;
    simulateTx(txRaw: TxRaw): Promise<{
        result: {
            data: string;
            log: string;
            eventsList: {
                type: string;
                attributes: {
                    key: string;
                    value: string;
                }[];
            }[];
        };
        gasInfo: {
            gasWanted: number;
            gasUsed: number;
        };
    }>;
    private broadcastTx;
    broadcastTxn(txRaw: TxRaw, mode?: BroadcastMode): Promise<SyncTxBroadcastResult>;
    broadcast(tx: TxRaw, timeout?: number): Promise<WaitTxBroadcastResult>;
    /**
     * Broadcast the transaction using the "block" mode, waiting for its inclusion in the blockchain.
     * @param tx transaction to broadcast
     */
    broadcastBlock(tx: TxRaw): Promise<BlockTxBroadcastResult>;
    /**
     * NOTE: This is not a synchronous function and is unconventionally named. This function
     * can be await as it returns a `Promise`.
     *
     * Broadcast the transaction using the "sync" mode, returning after CheckTx() is performed.
     * @param tx transaction to broadcast
     */
    broadcastSync(tx: TxRaw): Promise<SyncTxBroadcastResult>;
    /**
     * Search for transactions based on event attributes.
     * @param options
     */
    search(options: Partial<TxSearchOptions>): Promise<TxSearchResult>;
    private postRaw;
    private getRaw;
}
