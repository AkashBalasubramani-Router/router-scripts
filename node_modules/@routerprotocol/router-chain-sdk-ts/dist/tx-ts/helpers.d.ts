import { Any } from 'google-protobuf/google/protobuf/any_pb';
import { TxRaw } from '@routerprotocol/chain-api/cosmos/tx/v1beta1/tx_pb';
import { DirectSignResponse } from '@cosmjs/proto-signing';
import { SignDoc as CosmosSignDoc } from 'cosmjs-types/cosmos/tx/v1beta1/tx';
import { CreateTransactionArgs, EthereumChainId, MessageGenerated } from '../';
import { Msgs } from '../core';
import { ExtensionOptionsWeb3Tx } from '@routerprotocol/chain-api/types/tx_ext_pb';
export declare const createAnyMessage: (msg: MessageGenerated) => Any;
export declare const createAny: (value: any, type: string) => Any;
/**
 * Used when we want to pass a Msg class instead of the {type, message}
 * object of the Message (using the toDirectSign() method)
 * @returns
 */
export declare const createTransactionFromMsg: (params: Omit<CreateTransactionArgs, 'message'> & {
    message: Msgs | Msgs[];
}) => import("..").CreateTransactionResult;
/**
 * Used when we get a DirectSignResponse from
 * Cosmos native wallets like Keplr, Leap, etc after
 * the TxRaw has been signed.
 *
 * The reason why we need to create a new TxRaw and
 * not use the one that we passed to signing is that the users
 * can change the gas fees and that will alter the original
 * TxRaw which will cause signature miss match if we broadcast
 * that transaction on chain
 * @returns TxRaw
 */
export declare const createTxRawFromSigResponse: (signatureResponse: DirectSignResponse) => TxRaw;
/**
 * Used when we don't have account details and block details
 * and we pass the message and the user's address only
 * @returns
 */
export declare const createTransactionForAddressAndMsg: (params: Omit<CreateTransactionArgs, 'message' | 'sequence' | 'pubKey' | 'accountNumber'> & {
    message: Msgs | Msgs[];
    address: string;
    pubKey?: string;
    endpoint: string;
}) => Promise<import("..").CreateTransactionResult>;
export declare const createTransactionAndCosmosSignDoc: (args: CreateTransactionArgs) => {
    cosmosSignDoc: CosmosSignDoc;
    txRaw: TxRaw;
    signDoc: import("@routerprotocol/chain-api/cosmos/tx/v1beta1/tx_pb").SignDoc;
    bodyBytes: Uint8Array;
    signers: import("..").SignerDetails | import("..").SignerDetails[];
    signer: import("..").SignerDetails;
    authInfoBytes: Uint8Array;
    signBytes: Uint8Array;
    signHashedBytes: Uint8Array;
};
export declare const createCosmosSignDocFromTransaction: (args: {
    txRaw: TxRaw;
    chainId: string;
    accountNumber: number;
}) => CosmosSignDoc;
export declare const createTransactionAndCosmosSignDocForAddressAndMsg: (params: Omit<CreateTransactionArgs, 'message' | 'sequence' | 'pubKey' | 'accountNumber'> & {
    message: Msgs | Msgs[];
    address: string;
    pubKey?: string;
    endpoint: string;
}) => Promise<{
    cosmosSignDoc: CosmosSignDoc;
    txRaw: TxRaw;
    signDoc: import("@routerprotocol/chain-api/cosmos/tx/v1beta1/tx_pb").SignDoc;
    bodyBytes: Uint8Array;
    signers: import("..").SignerDetails | import("..").SignerDetails[];
    signer: import("..").SignerDetails;
    authInfoBytes: Uint8Array;
    signBytes: Uint8Array;
    signHashedBytes: Uint8Array;
}>;
export declare const createTxRawEIP712: (txRaw: TxRaw, extension: ExtensionOptionsWeb3Tx) => TxRaw;
export declare const createWeb3Extension: ({ ethereumChainId, feePayer, feePayerSig, }: {
    ethereumChainId: EthereumChainId;
    feePayer?: string | undefined;
    feePayerSig?: Uint8Array | undefined;
}) => ExtensionOptionsWeb3Tx;
export declare const getRouterSignerAddress: (address: string | undefined) => string;
export declare const getEthereumSignerAddress: (address: string | undefined) => string;
