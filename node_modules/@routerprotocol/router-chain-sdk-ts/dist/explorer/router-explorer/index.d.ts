import { Network } from '../../networks';
import { CrosschainEvent } from '../constants';
import { BlockTypeWithTxns, CrosschainType, FundDepositType, FundPaidType, InboundOutboundMapType, PaginatedBlock, PaginatedBlockWithSignature, PaginatedCrosschain, PaginatedFundDeposit, PaginatedFundPaid, PaginatedTransaction, TransactionType, ValidatorUptime } from '../types';
/**
 * @group Router Scan Utility
 */
export declare class RouterExplorer {
    readonly chainEnvironment: Network;
    readonly applicationAddress: string | null;
    constructor(chainEnvironment: string, applicationAddress?: string);
    /**
     * Fetches latest Blocks
     * @param {string} timeRange Time Range
     * @param {string} limit Page Limit
     * @param {string} offset Page Number
     * @return {PaginatedBlock}
     * @throws {Error}
     */
    getLatestBlocks(timeRange?: number[], limit?: Number, offset?: Number, { source }?: {
        source: import("axios").CancelTokenSource;
    }): Promise<{
        paginatedBlock: PaginatedBlock;
    }>;
    getLatestBlocksWithSignatures(timeRange?: number[], limit?: Number, offset?: Number, { source }?: {
        source: import("axios").CancelTokenSource;
    }): Promise<{
        paginatedBlock: PaginatedBlockWithSignature;
    }>;
    /**
     * Fetches specific Block
     * @param {string} height BlockHeight
     * @return {BlockType}
     * @throws {Error}
     */
    getBlockByHeight(height: Number, { source }?: {
        source: import("axios").CancelTokenSource;
    }): Promise<{
        block: BlockTypeWithTxns;
    }>;
    /**
     * Fetches latest Transactions
     * @param {string} timeRange Time Range
     * @param {string} limit Page Limit
     * @param {string} offset Page Number
     * @return {PaginatedTransaction}
     * @throws {Error}
     */
    getLatestTransactions(timeRange?: number[], limit?: Number, offset?: Number, { source }?: {
        source: import("axios").CancelTokenSource;
    }): Promise<{
        paginatedTransaction: PaginatedTransaction;
    }>;
    /**
     * Fetches latest Transactions for a specific address
     * @param {string} address Address
     * @param {string} limit Page Limit
     * @param {string} offset Page Number
     * @return {PaginatedTransaction}
     * @throws {Error}
     */
    getLatestTransactionsByAddress(address: String, timeRange?: number[], limit?: Number, offset?: Number, { source }?: {
        source: import("axios").CancelTokenSource;
    }): Promise<{
        paginatedTransaction: PaginatedTransaction;
    }>;
    /**
     * Fetches specific Transaction
     * @param {string} hash
     * @return {Transaction}
     * @throws {Error}
     */
    getTransactionByHash(hash: String, { source }?: {
        source: import("axios").CancelTokenSource;
    }): Promise<{
        transaction: TransactionType;
    }>;
    /**
     * Fetches latest Crosschains
     * @param {string} timeRange Time Range
     * @param {string} limit Page Limit
     * @param {string} offset Page Number
     * @return {PaginatedCrosschain}
     * @throws {Error}
     */
    getLatestCrosschains(timeRange?: number[], limit?: Number, offset?: Number, { source }?: {
        source: import("axios").CancelTokenSource;
    }): Promise<{
        paginatedCrosschain: PaginatedCrosschain;
    }>;
    /**
     * Fetches specific Crosschains
     * @param {string} timeRange Time Range
     * @param {string} searchTerm Source Sender or Source Transaction Hash
     * @param {string} limit Page Limit
     * @param {string} offset Page Number
     * @return {PaginatedCrosschain}
     * @throws {Error}
     */
    getCrosschainBySearch(searchTerm: String, srcChainIds?: string[], dstChainIds?: string[], timeRange?: number[], limit?: Number, offset?: Number, { source }?: {
        source: import("axios").CancelTokenSource;
    }): Promise<{
        paginatedCrosschain: PaginatedCrosschain;
    }>;
    /**
     * Fetches specific Crosschain
     * @param {string} formAttestationId
     * @return {CrosschainType}
     * @throws {Error}
     */
    getCrosschainByAttestationId(formAttestationId: String, { source }?: {
        source: import("axios").CancelTokenSource;
    }): Promise<{
        crosschain: CrosschainType;
    }>;
    /**
     * Fetches latest Fund Deposits
     * @param {string} timeRange Time Range
     * @param {string} limit Page Limit
     * @param {string} offset Page Number
     * @return {PaginatedFundDeposit}
     * @throws {Error}
     */
    getLatestFundDeposits(timeRange?: number[], limit?: Number, offset?: Number, { source }?: {
        source: import("axios").CancelTokenSource;
    }): Promise<{
        paginatedFundDeposit: PaginatedFundDeposit;
    }>;
    /**
     * Fetches specific Fund Deposits
     * @param {string} timeRange Time Range
     * @param {string} searchTerm srcTxHash or contract or srcToken or recipient or depositor
     * @param {string} limit Page Limit
     * @param {string} offset Page Number
     * @return {PaginatedFundDeposit}
     * @throws {Error}
     */
    getFundDepositBySearch(searchTerm: String, srcChainIds?: string[], dstChainIds?: string[], timeRange?: number[], limit?: Number, offset?: Number, { source }?: {
        source: import("axios").CancelTokenSource;
    }): Promise<{
        paginatedFundDeposit: PaginatedFundDeposit;
    }>;
    /**
     * Fetches specific Fund Deposit
     * @param {string} id
     * @return {FundDepositType}
     * @throws {Error}
     */
    getFundDepositById(id: String, { source }?: {
        source: import("axios").CancelTokenSource;
    }): Promise<{
        fundDeposit: FundDepositType;
    }>;
    /**
     * Fetches latest Fund Paid
     * @param {string} timeRange Time Range
     * @param {string} limit Page Limit
     * @param {string} offset Page Number
     * @return {PaginatedFundPaid}
     * @throws {Error}
     */
    getLatestFundPaids(timeRange?: number[], limit?: Number, offset?: Number, { source }?: {
        source: import("axios").CancelTokenSource;
    }): Promise<{
        paginatedFundPaid: PaginatedFundPaid;
    }>;
    /**
     * Fetches specific Fund Paids
     * @param {string} timeRange Time Range
     * @param {string} searchTerm srcTxHash or contract or srcToken or recipient or depositor
     * @param {string} limit Page Limit
     * @param {string} offset Page Number
     * @return {PaginatedFundPaid}
     * @throws {Error}
     */
    getFundPaidBySearch(searchTerm: String, srcChainIds?: string[], timeRange?: number[], limit?: Number, offset?: Number, { source }?: {
        source: import("axios").CancelTokenSource;
    }): Promise<{
        paginatedFundPaid: PaginatedFundPaid;
    }>;
    /**
     * Fetches specific Fund Paid
     * @param {string} id
     * @return {FundDepositType}
     * @throws {Error}
     */
    getFundPaidById(id: String, { source }?: {
        source: import("axios").CancelTokenSource;
    }): Promise<{
        fundPaid: FundPaidType;
    }>;
    /**
     * Fetches specific Transaction
     * @param {string} middlewareContract
     * @param {string} inboundId
     * @return {InboundOutboundMapType[]}
     * @throws {Error}
     */
    getOutboundsForInbound(inboundId: String, middlewareContract?: string | null, { source }?: {
        source: import("axios").CancelTokenSource;
    }): Promise<{
        outboundToInboundMap: InboundOutboundMapType[];
    }>;
    /**
     * Fetches specific Transaction
     * @return {ValidatorUptime[]}
     * @throws {Error}
     */
    getValidatorsUptime({ source }?: {
        source: import("axios").CancelTokenSource;
    }): Promise<{
        validators: ValidatorUptime[];
    }>;
    /**
     * Fetches specific Transaction
     * @param {string} sourceChainId
     * @param {string} nonce
     * @return {InboundOutboundMapType[]}
     * @throws {Error}
     */
    getBlockEventsForCrosschain(sourceChainId: string, nonce: string, crosschainEvent: CrosschainEvent): Promise<any>;
    getBlockEvents(blockNumber: string): Promise<any>;
}
