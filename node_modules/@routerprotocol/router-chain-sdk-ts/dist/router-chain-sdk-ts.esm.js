import { bech32 } from 'bech32';
import { Address as Address$1, fromRpcSig, ecrecover, toBuffer, publicToAddress, addHexPrefix, bufferToHex } from 'ethereumjs-util';
import { BigNumber } from 'bignumber.js';
import { Query } from '@routerprotocol/chain-api/cosmos/bank/v1beta1/query_pb_service';
import { QueryParamsRequest, QueryBalanceRequest, QueryAllBalancesRequest, QueryTotalSupplyRequest } from '@routerprotocol/chain-api/cosmos/bank/v1beta1/query_pb';
import { grpc } from '@improbable-eng/grpc-web';
import { NodeHttpTransport } from '@improbable-eng/grpc-web-node-http-transport';
import snakeCaseKeys from 'snakecase-keys';
import { PageRequest } from '@routerprotocol/chain-api/cosmos/base/query/v1beta1/pagination_pb';
import store from 'store2';
import axios from 'axios';
import { TextEncoder, TextDecoder as TextDecoder$1 } from 'text-encoding';
import secp256k1__default, { publicKeyCreate, publicKeyConvert } from 'secp256k1';
import { createHash } from 'crypto';
import { TypedDataUtils, SignTypedDataVersion } from '@metamask/eth-sig-util';
import { ethers, Wallet as Wallet$1 } from 'ethers';
export { Delegation as GrpcDelegation, DelegationResponse as GrpcDelegationResponse, Pool as GrpcPool, Redelegation as GrpcReDelegation, RedelegationResponse as GrpcReDelegationResponse, Params as GrpcStakingParams, UnbondingDelegation as GrpcUnbondingDelegation, Validator as GrpcValidator, Commission as GrpcValidatorCommission, CommissionRates as GrpcValidatorCommissionRates, Description as GrpcValidatorDescription } from '@routerprotocol/chain-api/cosmos/staking/v1beta1/staking_pb';
import { Query as Query$1 } from '@routerprotocol/chain-api/cosmos/auth/v1beta1/query_pb_service';
import { QueryParamsRequest as QueryParamsRequest$1, QueryAccountRequest, QueryAccountsRequest } from '@routerprotocol/chain-api/cosmos/auth/v1beta1/query_pb';
import { EthAccount } from '@routerprotocol/chain-api/ethermint/types/v1/account_pb';
import { QueryParamsRequest as QueryParamsRequest$2, QueryDelegationRewardsRequest, QueryDelegationTotalRewardsRequest } from '@routerprotocol/chain-api/cosmos/distribution/v1beta1/query_pb';
import { Query as Query$2 } from '@routerprotocol/chain-api/cosmos/distribution/v1beta1/query_pb_service';
import { QueryParamsRequest as QueryParamsRequest$3, QueryProposalsRequest, QueryProposalRequest, QueryDepositsRequest, QueryVotesRequest, QueryTallyResultRequest } from '@routerprotocol/chain-api/cosmos/gov/v1beta1/query_pb';
import { Query as Query$3 } from '@routerprotocol/chain-api/cosmos/gov/v1beta1/query_pb_service';
import { Query as Query$4 } from '@routerprotocol/chain-api/ibc/applications/transfer/v1/query_pb_service';
import { QueryDenomTraceRequest, QueryDenomTracesRequest } from '@routerprotocol/chain-api/ibc/applications/transfer/v1/query_pb';
import { Query as Query$5 } from '@routerprotocol/chain-api/cosmos/mint/v1beta1/query_pb_service';
import { QueryParamsRequest as QueryParamsRequest$4, QueryInflationRequest, QueryAnnualProvisionsRequest } from '@routerprotocol/chain-api/cosmos/mint/v1beta1/query_pb';
import { QueryParamsRequest as QueryParamsRequest$5, QueryPoolRequest, QueryValidatorsRequest, QueryValidatorRequest, QueryValidatorDelegationsRequest, QueryValidatorUnbondingDelegationsRequest, QueryDelegationRequest, QueryDelegatorDelegationsRequest, QueryDelegatorUnbondingDelegationsRequest, QueryRedelegationsRequest } from '@routerprotocol/chain-api/cosmos/staking/v1beta1/query_pb';
import { Query as Query$6 } from '@routerprotocol/chain-api/cosmos/staking/v1beta1/query_pb_service';
import { StatusCodes } from 'http-status-codes';
export { Params as GrpcBankParams, Supply as GrpcSupply } from '@routerprotocol/chain-api/cosmos/bank/v1beta1/bank_pb';
import { TextProposal } from '@routerprotocol/chain-api/cosmos/gov/v1beta1/gov_pb';
export { DepositParams as GrpcGovernanceDepositParams, TallyParams as GrpcGovernanceTallyParams, VotingParams as GrpcGovernanceVotingParams, Proposal as GrpcProposal, Deposit as GrpcProposalDeposit, TallyResult as GrpcTallyResult, Vote as GrpcVote } from '@routerprotocol/chain-api/cosmos/gov/v1beta1/gov_pb';
export { Params as GrpcMintParams } from '@routerprotocol/chain-api/cosmos/mint/v1beta1/mint_pb';
import { ValsetUpdatedClaimHash } from '@routerprotocol/chain-api/attestation/valset_updated_claim_pb';
import { BridgeValidator } from '@routerprotocol/chain-api/attestation/bridge_validator_pb';
import { sha256 } from '@cosmjs/crypto';
import { CrosschainRequestClaimHash } from '@routerprotocol/chain-api/routerchain/crosschain/crosschain_request_pb';
import { CrosschainAckRequestClaimHash } from '@routerprotocol/chain-api/routerchain/crosschain/crosschain_ack_request_pb';
import { CrosschainAckReceiptClaimHash } from '@routerprotocol/chain-api/routerchain/crosschain/crosschain_ack_receipt_pb';
import { Query as Query$7 } from '@routerprotocol/chain-api/cosmwasm/wasm/v1/query_pb_service';
import { QueryAllContractStateRequest, QueryContractHistoryRequest, QuerySmartContractStateRequest, QueryRawContractStateRequest, QueryCodesRequest, QueryCodeRequest, QueryContractsByCodeRequest } from '@routerprotocol/chain-api/cosmwasm/wasm/v1/query_pb';
import { Query as Query$8 } from '@routerprotocol/chain-api/attestation/query_pb_service';
import { QueryLatestValsetNonceRequest, QueryAllValsetRequest, QueryGetValsetRequest, QueryLatestValsetRequest, QueryLastEventNonceRequest, QueryListOrchestratorsRequest } from '@routerprotocol/chain-api/attestation/query_pb';
import { Query as Query$9 } from '@routerprotocol/chain-api/multichain/query_pb_service';
import { QueryGetChainConfigRequest, QueryAllChainConfigRequest, QueryAllContractConfigByChainIdRequest, QueryAllContractConfigRequest } from '@routerprotocol/chain-api/multichain/query_pb';
import { Query as Query$a } from '@routerprotocol/chain-api/routerchain/crosschain/query_pb_service';
import { QueryAllCrosschainRequestRequest, QueryAllCrosschainRequestConfirmRequest, QueryAllCrosschainAckRequestRequest, QueryAllCrosschainAckRequestConfirmRequest, QueryGetCrosschainRequestConfirmRequest, QueryGetCrosschainAckRequestConfirmRequest, QueryGetCrosschainRequestRequest, QueryGetCrosschainAckReceiptRequest } from '@routerprotocol/chain-api/routerchain/crosschain/query_pb';
import bip39 from 'bip39';
import keccak256$1 from 'keccak256';
import { PubKey as PubKey$2 } from '@routerprotocol/chain-api/ethermint/crypto/v1/ethsecp256k1/keys_pb';
import { Any } from 'google-protobuf/google/protobuf/any_pb';
import { keccak256 } from 'js-sha3';
import { splitSignature, arrayify, concat } from '@ethersproject/bytes';
import { TxRaw as TxRaw$1, TxBody as TxBody$1, Fee as Fee$1, ModeInfo as ModeInfo$1, SignerInfo as SignerInfo$1, AuthInfo as AuthInfo$1, SignDoc as SignDoc$2 } from '@routerprotocol/chain-api/cosmos/tx/v1beta1/tx_pb';
import { SignMode as SignMode$1 } from '@routerprotocol/chain-api/cosmos/tx/signing/v1beta1/signing_pb';
import { Coin as Coin$1 } from '@routerprotocol/chain-api/cosmos/base/v1beta1/coin_pb';
export { Coin as GrpcCoin } from '@routerprotocol/chain-api/cosmos/base/v1beta1/coin_pb';
import { PubKey as PubKey$3 } from '@routerprotocol/chain-api/cosmos/crypto/secp256k1/keys_pb';
import { SignDoc as SignDoc$1 } from 'cosmjs-types/cosmos/tx/v1beta1/tx';
import { ExtensionOptionsWeb3Tx } from '@routerprotocol/chain-api/types/tx_ext_pb';
import { MsgGrant as MsgGrant$2, MsgRevoke as MsgRevoke$2, MsgExec as MsgExec$2 } from '@routerprotocol/chain-api/cosmos/authz/v1beta1/tx_pb';
import { GenericAuthorization, Grant } from '@routerprotocol/chain-api/cosmos/authz/v1beta1/authz_pb';
import { Timestamp } from 'google-protobuf/google/protobuf/timestamp_pb';
import { MsgSend as MsgSend$2 } from '@routerprotocol/chain-api/cosmos/bank/v1beta1/tx_pb';
import { MsgWithdrawDelegatorReward as MsgWithdrawDelegatorReward$2 } from '@routerprotocol/chain-api/cosmos/distribution/v1beta1/tx_pb';
import { MsgVote as MsgVote$2, MsgDeposit as MsgDeposit$2, MsgSubmitProposal as MsgSubmitProposal$1 } from '@routerprotocol/chain-api/cosmos/gov/v1beta1/tx_pb';
import { SoftwareUpgradeProposal } from '@routerprotocol/chain-api/cosmos/upgrade/v1beta1/upgrade_pb';
import { ParameterChangeProposal } from '@routerprotocol/chain-api/cosmos/params/v1beta1/params_pb';
import { MsgTransfer as MsgTransfer$1 } from '@routerprotocol/chain-api/ibc/applications/transfer/v1/tx_pb';
import { Height } from '@routerprotocol/chain-api/ibc/core/client/v1/client_pb';
import { MsgBeginRedelegate as MsgBeginRedelegate$1, MsgDelegate as MsgDelegate$2, MsgUndelegate as MsgUndelegate$2 } from '@routerprotocol/chain-api/cosmos/staking/v1beta1/tx_pb';
import { MsgExecuteContract as MsgExecuteContract$2, MsgInstantiateContract as MsgInstantiateContract$1, MsgStoreCode as MsgStoreCode$2, MsgUpdateAdmin as MsgUpdateAdmin$2, MsgMigrateContract as MsgMigrateContract$2 } from '@routerprotocol/chain-api/cosmwasm/wasm/v1/tx_pb';
import { MsgApproveFeepayerRequest as MsgApproveFeepayerRequest$2 } from '@routerprotocol/chain-api/metastore/tx_pb';
import { MsgExecuteCwContract as MsgExecuteCwContract$2, MsgInstantiateCwContract as MsgInstantiateCwContract$2, MsgCwStoreCode as MsgCwStoreCode$2, MsgMigrateCwContract as MsgMigrateCwContract$2 } from '@routerprotocol/chain-api/routerchain/rwasm/tx_pb';
import { proto3, Any as Any$1 } from '@bufbuild/protobuf';
import { Keccak } from 'sha3';
import { ServiceClient, Service } from '@routerprotocol/chain-api/cosmos/tx/v1beta1/service_pb_service';
import { GetTxRequest, SimulateRequest, BroadcastTxRequest, BroadcastMode as BroadcastMode$2 } from '@routerprotocol/chain-api/cosmos/tx/v1beta1/service_pb';
import Web3 from 'web3';
import { BroadcastMode as BroadcastMode$3 } from '@cosmjs/launchpad';
import { Bech32Address } from '@keplr-wallet/cosmos';
import { makeSignDoc } from '@cosmjs/proto-signing';
import { InstallError, cosmos, ethereum } from '@cosmostation/extension-client';
import { SEND_TRANSACTION_MODE } from '@cosmostation/extension-client/cosmos';
import ledgerService from '@ledgerhq/hw-app-eth/lib/services/ledger';
import Common, { Hardfork, Chain } from '@ethereumjs/common';
import { FeeMarketEIP1559Transaction } from '@ethereumjs/tx';
import TransportWebHID from '@ledgerhq/hw-transport-webhid';
import TransportWebUSB from '@ledgerhq/hw-transport-webusb';
import TransportU2F from '@ledgerhq/hw-transport-u2f';
import EthereumApp from '@ledgerhq/hw-app-eth';
import HDNode from 'hdkey';
import { TypedDataUtils as TypedDataUtils$1 } from 'eth-sig-util';
import WalletConnectProvider from '@walletconnect/web3-provider';

function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return exports;
  };
  var exports = {},
    Op = Object.prototype,
    hasOwn = Op.hasOwnProperty,
    defineProperty = Object.defineProperty || function (obj, key, desc) {
      obj[key] = desc.value;
    },
    $Symbol = "function" == typeof Symbol ? Symbol : {},
    iteratorSymbol = $Symbol.iterator || "@@iterator",
    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
      generator = Object.create(protoGenerator.prototype),
      context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg,
          value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function (method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self, context) {
    var state = "suspendedStart";
    return function (method, arg) {
      if ("executing" === state) throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method) throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg;;) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }
        if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
          if ("suspendedStart" === state) throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method,
      method = delegate.iterator[methodName];
    if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1,
          next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
            return next.value = undefined, next.done = !0, next;
          };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (val) {
    var object = Object(val),
      keys = [];
    for (var key in object) keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
          record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
            hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;
  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;
    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);
      _cache.set(Class, Wrapper);
    }
    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };
  return _wrapNativeSuper(Class);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

var ContractErrorModule;
(function (ContractErrorModule) {
  ContractErrorModule["Erc20Contract"] = "erc20-contract";
  ContractErrorModule["Peggy"] = "peggy-contract";
  ContractErrorModule["PeggyOld"] = "peggy-old-contract";
})(ContractErrorModule || (ContractErrorModule = {}));
var ChainErrorModule;
(function (ChainErrorModule) {
  ChainErrorModule["Auction"] = "chain-auction";
  ChainErrorModule["Auth"] = "chain-auth";
  ChainErrorModule["Bank"] = "chain-bank";
  ChainErrorModule["Distribution"] = "chain-distribution";
  ChainErrorModule["Exchange"] = "chain-exchange";
  ChainErrorModule["Gov"] = "chain-gov";
  ChainErrorModule["Ibc"] = "chain-ibc";
  ChainErrorModule["InsuranceFund"] = "chain-insurance";
  ChainErrorModule["Mint"] = "chain-mint";
  ChainErrorModule["Oracle"] = "chain-oracle";
  ChainErrorModule["Peggy"] = "chain-peggy";
  ChainErrorModule["Staking"] = "chain-staking";
  ChainErrorModule["Wasm"] = "chain-wasm";
  ChainErrorModule["WasmX"] = "chain-wasmx";
  ChainErrorModule["Tendermint"] = "chain-tendermint";
})(ChainErrorModule || (ChainErrorModule = {}));
var IndexerErrorModule;
(function (IndexerErrorModule) {
  IndexerErrorModule["Account"] = "indexer-account";
  IndexerErrorModule["Auction"] = "indexer-auction";
  IndexerErrorModule["Derivatives"] = "indexer-derivatives";
  IndexerErrorModule["Explorer"] = "indexer-explorer";
  IndexerErrorModule["InsuranceFund"] = "indexer-insurance-fund";
  IndexerErrorModule["Meta"] = "indexer-meta";
  IndexerErrorModule["Oracle"] = "indexer-oracle";
  IndexerErrorModule["Spot"] = "indexer-spot";
  IndexerErrorModule["Transaction"] = "indexer-transaction";
  IndexerErrorModule["ChronosDerivative"] = "indexer-chronos-derivative";
  IndexerErrorModule["ChronosSpot"] = "indexer-chronos-spot";
  IndexerErrorModule["ChronosMarkets"] = "indexer-chronos-markets";
})(IndexerErrorModule || (IndexerErrorModule = {}));
var WalletErrorActionModule;
(function (WalletErrorActionModule) {
  WalletErrorActionModule["SignTransaction"] = "sign-transaction";
  WalletErrorActionModule["SignEthereumTransaction"] = "sign-ethereum-transaction";
  WalletErrorActionModule["SendTransaction"] = "send-transaction";
  WalletErrorActionModule["SendEthereumTransaction"] = "send-ethereum-transaction";
  WalletErrorActionModule["GetAccounts"] = "get-accounts";
  WalletErrorActionModule["GetNetworkId"] = "get-network-id";
  WalletErrorActionModule["GetChainId"] = "get-chain-id";
  WalletErrorActionModule["GetEthereumTransactionReceipt"] = "get-ethereum-transaction-receipt";
})(WalletErrorActionModule || (WalletErrorActionModule = {}));

var ChainCosmosErrorCode;
(function (ChainCosmosErrorCode) {
  // ErrTxDecode is returned if we cannot parse a transaction
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrTxDecode"] = 2] = "ErrTxDecode";
  // ErrInvalidSequence is used the sequence number (nonce) is incorrect for the signature
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrInvalidSequence"] = 3] = "ErrInvalidSequence";
  // ErrUnauthorized is used whenever a request without sufficient authorization is handled.
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrUnauthorized"] = 4] = "ErrUnauthorized";
  // ErrInsufficientFunds is used when the account cannot pay requested amount.
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrInsufficientFunds"] = 5] = "ErrInsufficientFunds";
  // ErrUnknownRequest to doc
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrUnknownRequest"] = 6] = "ErrUnknownRequest";
  // ErrInvalidAddress to doc
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrInvalidAddress"] = 7] = "ErrInvalidAddress";
  // ErrInvalidPubKey to doc
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrInvalidPubKey"] = 8] = "ErrInvalidPubKey";
  // ErrUnknownAddress to doc
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrUnknownAddress"] = 9] = "ErrUnknownAddress";
  // ErrInvalidCoins to doc
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrInvalidCoins"] = 10] = "ErrInvalidCoins";
  // ErrOutOfGas to doc
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrOutOfGas"] = 11] = "ErrOutOfGas";
  // ErrMemoTooLarge to doc
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrMemoTooLarge"] = 12] = "ErrMemoTooLarge";
  // ErrInsufficientFee to doc
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrInsufficientFee"] = 13] = "ErrInsufficientFee";
  // ErrTooManySignatures to doc
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrTooManySignatures"] = 14] = "ErrTooManySignatures";
  // ErrNoSignatures to doc
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrNoSignatures"] = 15] = "ErrNoSignatures";
  // ErrJSONMarshal defines an ABCI typed JSON marshalling error
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrJSONMarshal"] = 16] = "ErrJSONMarshal";
  // ErrJSONUnmarshal defines an ABCI typed JSON unmarshalling error
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrJSONUnmarshal"] = 17] = "ErrJSONUnmarshal";
  // ErrInvalidRequest defines an ABCI typed error where the request contains invalid data.
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrInvalidRequest"] = 18] = "ErrInvalidRequest";
  // ErrTxInMempoolCache defines an ABCI typed error where a tx already exists in the mempool.
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrTxInMempoolCache"] = 19] = "ErrTxInMempoolCache";
  // ErrMempoolIsFull defines an ABCI typed error where the mempool is full.
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrMempoolIsFull"] = 20] = "ErrMempoolIsFull";
  // ErrTxTooLarge defines an ABCI typed error where tx is too large.
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrTxTooLarge"] = 21] = "ErrTxTooLarge";
  // ErrKeyNotFound defines an error when the key doesn't exist
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrKeyNotFound"] = 22] = "ErrKeyNotFound";
  // ErrWrongPassword defines an error when the key password is invalid.
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrWrongPassword"] = 23] = "ErrWrongPassword";
  // ErrorInvalidSigner defines an error when the tx intended signer does not match the given signer.
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrorInvalidSigner"] = 24] = "ErrorInvalidSigner";
  // ErrorInvalidGasAdjustment defines an error for an invalid gas adjustment
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrorInvalidGasAdjustment"] = 25] = "ErrorInvalidGasAdjustment";
  // ErrInvalidHeight defines an error for an invalid height
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrInvalidHeight"] = 26] = "ErrInvalidHeight";
  // ErrInvalidVersion defines a general error for an invalid version
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrInvalidVersion"] = 27] = "ErrInvalidVersion";
  // ErrInvalidChainID defines an error when the chain-id is invalid.
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrInvalidChainID"] = 28] = "ErrInvalidChainID";
  // ErrInvalidType defines an error an invalid type.
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrInvalidType"] = 29] = "ErrInvalidType";
  // ErrTxTimeoutHeight defines an error for when a tx is rejected out due to an explicitly set timeout height.
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrTxTimeoutHeight"] = 30] = "ErrTxTimeoutHeight";
  // ErrUnknownExtensionOptions defines an error for unknown extension options.
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrUnknownExtensionOptions"] = 31] = "ErrUnknownExtensionOptions";
  // ErrWrongSequence defines an error where the account sequence defined in the signer info doesn't match the account's actual sequence number.
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrWrongSequence"] = 32] = "ErrWrongSequence";
  // ErrPackAny defines an error when packing a protobuf message to Any fails.
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrPackAny"] = 33] = "ErrPackAny";
  // ErrUnpackAny defines an error when unpacking a protobuf message from Any fails.
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrUnpackAny"] = 34] = "ErrUnpackAny";
  // ErrLogic defines an internal logic error, e.g. an invariant or assertion that is violated. It is a programmer error, not a user-facing error.
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrLogic"] = 35] = "ErrLogic";
  // ErrConflict defines a conflict error, e.g. when two goroutines try to access the same resource and one of them fails.
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrConflict"] = 36] = "ErrConflict";
  // ErrNotSupported is returned when we call a branch of a code which is currently not supported.
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrNotSupported"] = 37] = "ErrNotSupported";
  // ErrNotFound defines an error when requested entity doesn't exist in the state.
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrNotFound"] = 38] = "ErrNotFound";
  // ErrIO should be used to wrap internal errors caused by external operation. Examples: not DB domain error, file writing etc...
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrIO"] = 39] = "ErrIO";
  // ErrAppConfig defines an error occurred if min-gas-prices field in BaseConfig is empty.
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrAppConfig"] = 40] = "ErrAppConfig";
  // ErrInvalidGasLimit defines an error when an invalid GasWanted value is supplied.
  ChainCosmosErrorCode[ChainCosmosErrorCode["ErrInvalidGasLimit"] = 41] = "ErrInvalidGasLimit";
})(ChainCosmosErrorCode || (ChainCosmosErrorCode = {}));
var ChainExchangeModuleErrorCode;
(function (ChainExchangeModuleErrorCode) {
  //  failed to validate order
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrOrderInvalid"] = 1] = "ErrOrderInvalid";
  //  spot market not found
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrSpotMarketNotFound"] = 2] = "ErrSpotMarketNotFound";
  //  spot market exists
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrSpotMarketExists"] = 3] = "ErrSpotMarketExists";
  //  struct field error
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrBadField"] = 4] = "ErrBadField";
  //  failed to validate market
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrMarketInvalid"] = 5] = "ErrMarketInvalid";
  //  subaccount has insufficient deposits
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInsufficientDeposit"] = 6] = "ErrInsufficientDeposit";
  //  unrecognized order type
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrUnrecognizedOrderType"] = 7] = "ErrUnrecognizedOrderType";
  //  position quantity insufficient for order
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInsufficientPositionQuantity"] = 8] = "ErrInsufficientPositionQuantity";
  //  order hash is not valid
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrOrderHashInvalid"] = 9] = "ErrOrderHashInvalid";
  //  subaccount id is not valid
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrBadSubaccountID"] = 10] = "ErrBadSubaccountID";
  //  invalid ticker
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidTicker"] = 11] = "ErrInvalidTicker";
  //  invalid base denom
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidBaseDenom"] = 12] = "ErrInvalidBaseDenom";
  //  invalid quote denom
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidQuoteDenom"] = 13] = "ErrInvalidQuoteDenom";
  //  invalid oracle
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidOracle"] = 14] = "ErrInvalidOracle";
  //  invalid expiry
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidExpiry"] = 15] = "ErrInvalidExpiry";
  //  invalid price
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidPrice"] = 16] = "ErrInvalidPrice";
  //  invalid quantity
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidQuantity"] = 17] = "ErrInvalidQuantity";
  //  unsupported oracle type
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrUnsupportedOracleType"] = 18] = "ErrUnsupportedOracleType";
  //  order doesnt exist
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrOrderDoesntExist"] = 19] = "ErrOrderDoesntExist";
  //  spot limit orderbook fill invalid
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrOrderbookFillInvalid"] = 20] = "ErrOrderbookFillInvalid";
  //  perpetual market exists
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrPerpetualMarketExists"] = 21] = "ErrPerpetualMarketExists";
  //  expiry futures market exists
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrExpiryFuturesMarketExists"] = 22] = "ErrExpiryFuturesMarketExists";
  //  expiry futures market expired
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrExpiryFuturesMarketExpired"] = 23] = "ErrExpiryFuturesMarketExpired";
  //  no liquidity on the orderbook!
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrNoLiquidity"] = 24] = "ErrNoLiquidity";
  //  Orderbook liquidity cannot satisfy current worst price
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrSlippageExceedsWorstPrice"] = 25] = "ErrSlippageExceedsWorstPrice";
  //  Order has insufficient margin
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInsufficientOrderMargin"] = 26] = "ErrInsufficientOrderMargin";
  //  Derivative market not found
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrDerivativeMarketNotFound"] = 27] = "ErrDerivativeMarketNotFound";
  //  Position not found
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrPositionNotFound"] = 28] = "ErrPositionNotFound";
  //  Position direction does not oppose the reduce-only order
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidReduceOnlyPositionDirection"] = 29] = "ErrInvalidReduceOnlyPositionDirection";
  //  Price Surpasses Bankruptcy Price
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrPriceSurpassesBankruptcyPrice"] = 30] = "ErrPriceSurpassesBankruptcyPrice";
  //  Position not liquidable
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrPositionNotLiquidable"] = 31] = "ErrPositionNotLiquidable";
  //  invalid trigger price
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidTriggerPrice"] = 32] = "ErrInvalidTriggerPrice";
  //  invalid oracle type
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidOracleType"] = 33] = "ErrInvalidOracleType";
  //  invalid minimum price tick size
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidPriceTickSize"] = 34] = "ErrInvalidPriceTickSize";
  //  invalid minimum quantity tick size
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidQuantityTickSize"] = 35] = "ErrInvalidQuantityTickSize";
  //  invalid minimum order margin
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidMargin"] = 36] = "ErrInvalidMargin";
  //  Exceeds order side count
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrExceedsOrderSideCount"] = 37] = "ErrExceedsOrderSideCount";
  //  Subaccount cannot place a market order when a market order in the same market was already placed in same block
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrMarketOrderAlreadyExists"] = 38] = "ErrMarketOrderAlreadyExists";
  //  cannot place a conditional market order when a conditional market order in same relative direction already exists
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrConditionalMarketOrderAlreadyExists"] = 39] = "ErrConditionalMarketOrderAlreadyExists";
  //  An equivalent market launch proposal already exists.
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrMarketLaunchProposalAlreadyExists"] = 40] = "ErrMarketLaunchProposalAlreadyExists";
  //  Invalid Market Status
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidMarketStatus"] = 41] = "ErrInvalidMarketStatus";
  //  base denom cannot be same with quote denom
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrSameDenoms"] = 42] = "ErrSameDenoms";
  //  oracle base cannot be same with oracle quote
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrSameOracles"] = 43] = "ErrSameOracles";
  //  MakerFeeRate does not match TakerFeeRate requirements
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrFeeRatesRelation"] = 44] = "ErrFeeRatesRelation";
  //  MaintenanceMarginRatio cannot be greater than InitialMarginRatio
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrMarginsRelation"] = 45] = "ErrMarginsRelation";
  //  OracleScaleFactor cannot be greater than MaxOracleScaleFactor
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrExceedsMaxOracleScaleFactor"] = 46] = "ErrExceedsMaxOracleScaleFactor";
  //  Spot exchange is not enabled yet
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrSpotExchangeNotEnabled"] = 47] = "ErrSpotExchangeNotEnabled";
  //  Derivatives exchange is not enabled yet
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrDerivativesExchangeNotEnabled"] = 48] = "ErrDerivativesExchangeNotEnabled";
  //  Oracle price delta exceeds threshold
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrOraclePriceDeltaExceedsThreshold"] = 49] = "ErrOraclePriceDeltaExceedsThreshold";
  //  Invalid hourly interest rate
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidHourlyInterestRate"] = 50] = "ErrInvalidHourlyInterestRate";
  //  Invalid hourly funding rate cap
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidHourlyFundingRateCap"] = 51] = "ErrInvalidHourlyFundingRateCap";
  //  Only perpetual markets can update funding parameters
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidMarketFundingParamUpdate"] = 52] = "ErrInvalidMarketFundingParamUpdate";
  //  Invalid trading reward campaign
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidTradingRewardCampaign"] = 53] = "ErrInvalidTradingRewardCampaign";
  //  Invalid fee discount schedule
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidFeeDiscountSchedule"] = 54] = "ErrInvalidFeeDiscountSchedule";
  //  invalid liquidation order
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidLiquidationOrder"] = 55] = "ErrInvalidLiquidationOrder";
  //  Unknown error happened for campaign distributions
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrTradingRewardCampaignDistributionError"] = 56] = "ErrTradingRewardCampaignDistributionError";
  //  Invalid trading reward points update
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidTradingRewardsPendingPointsUpdate"] = 57] = "ErrInvalidTradingRewardsPendingPointsUpdate";
  //  Invalid batch msg update
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidBatchMsgUpdate"] = 58] = "ErrInvalidBatchMsgUpdate";
  //  Post-only order exceeds top of book price
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrExceedsTopOfBookPrice"] = 59] = "ErrExceedsTopOfBookPrice";
  //  Order type not supported for given message
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidOrderTypeForMessage"] = 60] = "ErrInvalidOrderTypeForMessage";
  //  Sender must match dmm account
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidDMMSender"] = 61] = "ErrInvalidDMMSender";
  //  already opted out of rewards
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrAlreadyOptedOutOfRewards"] = 62] = "ErrAlreadyOptedOutOfRewards";
  //  Invalid margin ratio
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidMarginRatio"] = 63] = "ErrInvalidMarginRatio";
  //  Provided funds are below minimum
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrBelowMinimalContribution"] = 64] = "ErrBelowMinimalContribution";
  //  Position is below initial margin requirement
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrLowPositionMargin"] = 65] = "ErrLowPositionMargin";
  //  Pool has non-positive total lp token supply
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidTotalSupply"] = 66] = "ErrInvalidTotalSupply";
  //  Passed lp token burn amount is greater than total lp token supply
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidLpTokenBurnAmount"] = 67] = "ErrInvalidLpTokenBurnAmount";
  //  unsupported action
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrUnsupportedAction"] = 68] = "ErrUnsupportedAction";
  //  position quantity cannot be negative
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrNegativePositionQuantity"] = 69] = "ErrNegativePositionQuantity";
  //  binary options market exists
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrBinaryOptionsMarketExists"] = 70] = "ErrBinaryOptionsMarketExists";
  //  binary options market not found
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrBinaryOptionsMarketNotFound"] = 71] = "ErrBinaryOptionsMarketNotFound";
  //  invalid settlement
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidSettlement"] = 72] = "ErrInvalidSettlement";
  //  account doesnt exist
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrAccountDoesntExist"] = 73] = "ErrAccountDoesntExist";
  //  sender should be a market admin
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrSenderIsNotAnAdmin"] = 74] = "ErrSenderIsNotAnAdmin";
  //  market is already scheduled to settle
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrMarketAlreadyScheduledToSettle"] = 75] = "ErrMarketAlreadyScheduledToSettle";
  //  market not found
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrGenericMarketNotFound"] = 76] = "ErrGenericMarketNotFound";
  //  denom decimal cannot be below 1 or above max scale factor
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidDenomDecimal"] = 77] = "ErrInvalidDenomDecimal";
  //  state is invalid
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidState"] = 78] = "ErrInvalidState";
  //  transient orders up to cancellation not supported
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrTransientOrdersUpToCancelNotSupported"] = 79] = "ErrTransientOrdersUpToCancelNotSupported";
  //  invalid trade
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidTrade"] = 80] = "ErrInvalidTrade";
  //  no margin locked in subaccount
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrNoMarginLocked"] = 81] = "ErrNoMarginLocked";
  //  Invalid access level to perform action
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidAccessLevel"] = 82] = "ErrInvalidAccessLevel";
  //  Invalid address
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidAddress"] = 83] = "ErrInvalidAddress";
  //  Invalid argument
  ChainExchangeModuleErrorCode[ChainExchangeModuleErrorCode["ErrInvalidArgument"] = 84] = "ErrInvalidArgument";
})(ChainExchangeModuleErrorCode || (ChainExchangeModuleErrorCode = {}));
var UnspecifiedErrorCode = -1;

var HttpRequestMethod;
(function (HttpRequestMethod) {
  HttpRequestMethod["Get"] = "GET";
  HttpRequestMethod["Post"] = "POST";
  HttpRequestMethod["Options"] = "OPTIONS";
})(HttpRequestMethod || (HttpRequestMethod = {}));
var ErrorType;
(function (ErrorType) {
  ErrorType["Unspecified"] = "unspecified";
  ErrorType["ChainError"] = "chain-error";
  ErrorType["ExecutionError"] = "execution-error";
  ErrorType["NotFoundError"] = "not-found-error";
  ErrorType["ValidationError"] = "validation-error";
  ErrorType["WalletError"] = "wallet-error";
  ErrorType["WalletNotInstalledError"] = "wallet-not-installed-error";
  ErrorType["GrpcUnaryRequest"] = "grpc-unary-request";
  ErrorType["HttpRequest"] = "http-request";
  ErrorType["Web3"] = "web3";
})(ErrorType || (ErrorType = {}));

var ConcreteException = /*#__PURE__*/function (_Error) {
  _inheritsLoose(ConcreteException, _Error);
  function ConcreteException(error, context) {
    var _this;
    _this = _Error.call(this, error.message) || this;
    /**
     * The type of the Error
     */
    _this.type = ErrorType.Unspecified;
    /**
     * Error specific code (HttpStatus, GrpcStatus, etc)
     */
    _this.code = UnspecifiedErrorCode;
    /**
     * Providing more context as to why the exception was thrown
     * (ex: on-chain error code, etc)
     */
    _this.contextCode = UnspecifiedErrorCode;
    /**
     * Parsed message of the exception
     */
    _this.message = '';
    /**
     * The original stack of the error
     */
    _this.stack = '';
    /**
     * The original message of the error
     */
    _this.errorMessage = '';
    _this.parseError(error);
    _this.parseContext(context);
    _this.parse();
    return _this;
  }
  var _proto = ConcreteException.prototype;
  _proto.parse = function parse() {
    //
  };
  _proto.parseError = function parseError(error) {
    this.setName(this.constructor.name);
    this.setStack(error.stack || '');
    this.setMessage(error.message);
    this.errorMessage = error.message;
  };
  _proto.parseContext = function parseContext(context) {
    var _ref = context || {
        contextModule: '',
        code: UnspecifiedErrorCode,
        type: ErrorType.Unspecified
      },
      contextModule = _ref.contextModule,
      type = _ref.type,
      code = _ref.code;
    this.contextModule = contextModule;
    this.type = type || ErrorType.Unspecified;
    this.code = code || UnspecifiedErrorCode;
  };
  _proto.setType = function setType(type) {
    this.type = type;
  };
  _proto.setCode = function setCode(code) {
    this.code = code;
  };
  _proto.setStack = function setStack(stack) {
    //@ts-ignore
    this.stack = stack;
    this.stack = stack;
  };
  _proto.setName = function setName(name) {
    //@ts-ignore
    this.name = name;
    this.name = name;
  };
  _proto.setMessage = function setMessage(message) {
    //@ts-ignore
    this.message = message;
    this.message = message;
  };
  _proto.setContextModule = function setContextModule(contextModule) {
    this.contextModule = contextModule;
  };
  _proto.setContextCode = function setContextCode(code) {
    this.contextCode = code;
  };
  _proto.toOriginalError = function toOriginalError() {
    var error = new Error(this.errorMessage);
    error.stack = this.stack;
    error.name = this.name || '';
    return error;
  };
  _proto.toError = function toError() {
    var error = new Error(this.message);
    error.stack = this.stack;
    error.name = this.name || '';
    return error;
  };
  _proto.toJson = function toJson() {
    return JSON.stringify({
      error: this.message,
      stack: this.stack
    });
  };
  _proto.toString = function toString() {
    return this.message;
  };
  return ConcreteException;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var GrpcUnaryRequestException = /*#__PURE__*/function (_ConcreteException) {
  _inheritsLoose(GrpcUnaryRequestException, _ConcreteException);
  function GrpcUnaryRequestException(error, context) {
    var _this;
    _this = _ConcreteException.call(this, error, context) || this;
    _this.type = ErrorType.GrpcUnaryRequest;
    return _this;
  }
  return GrpcUnaryRequestException;
}(ConcreteException);

var HttpRequestException = /*#__PURE__*/function (_ConcreteException) {
  _inheritsLoose(HttpRequestException, _ConcreteException);
  function HttpRequestException(error, context) {
    var _this;
    _this = _ConcreteException.call(this, error, context) || this;
    _this.method = HttpRequestMethod.Get;
    _this.type = ErrorType.HttpRequest;
    _this.method = context ? context.method || HttpRequestMethod.Get : HttpRequestMethod.Get;
    return _this;
  }
  return HttpRequestException;
}(ConcreteException);

var GeneralException = /*#__PURE__*/function (_ConcreteException) {
  _inheritsLoose(GeneralException, _ConcreteException);
  function GeneralException() {
    return _ConcreteException.apply(this, arguments) || this;
  }
  return GeneralException;
}(ConcreteException);

var isCommonLockedError = function isCommonLockedError(error) {
  return !!(error.includes('Ledger device: Incorrect length') || error.includes('Ledger device: INS_NOT_SUPPORTED') || error.includes('Ledger device: CLA_NOT_SUPPORTED') || error.includes('Failed to open the device') || error.includes('Failed to open the device') || error.includes('Ledger Device is busy') || error.includes('UNKNOWN_ERROR'));
};
var LedgerException = /*#__PURE__*/function (_ConcreteException) {
  _inheritsLoose(LedgerException, _ConcreteException);
  function LedgerException(error, context) {
    var _this;
    _this = _ConcreteException.call(this, error, context) || this;
    _this.type = ErrorType.WalletError;
    return _this;
  }
  var _proto = LedgerException.prototype;
  _proto.parseMessage = function parseMessage() {
    var message = this.message;
    if (isCommonLockedError(message)) {
      this.setMessage('Please ensure your Ledger is connected, unlocked and your Ethereum app is open.');
    }
  };
  return LedgerException;
}(ConcreteException);

var removeMetamaskFromErrorString = function removeMetamaskFromErrorString(message) {
  return message.replaceAll('Metamask', '').replaceAll('MetaMask', '').replaceAll('Metamask:', '');
};
var MetamaskException = /*#__PURE__*/function (_ConcreteException) {
  _inheritsLoose(MetamaskException, _ConcreteException);
  function MetamaskException(error, context) {
    var _this;
    _this = _ConcreteException.call(this, error, context) || this;
    _this.type = ErrorType.WalletError;
    return _this;
  }
  var _proto = MetamaskException.prototype;
  _proto.parseMessage = function parseMessage() {
    var message = this.message;
    this.setMessage(removeMetamaskFromErrorString(message));
  };
  return MetamaskException;
}(ConcreteException);

var CosmosWalletException = /*#__PURE__*/function (_ConcreteException) {
  _inheritsLoose(CosmosWalletException, _ConcreteException);
  function CosmosWalletException(error, context) {
    var _this;
    _this = _ConcreteException.call(this, error, context) || this;
    _this.type = ErrorType.WalletError;
    return _this;
  }
  return CosmosWalletException;
}(ConcreteException);

var mapMessage = function mapMessage(message) {
  var _message$split = message.split('message index: 0:'),
    parsedMessage = _message$split[1];
  if (parsedMessage) {
    var _parsedMessage$split = parsedMessage.split(': invalid request'),
      actualMessage = _parsedMessage$split[0];
    var trimmedMessage = actualMessage.trim().trimEnd();
    if (trimmedMessage.toLowerCase().includes('insufficient fee')) {
      return {
        message: 'You do not have enough funds to cover transaction fees.',
        code: ChainCosmosErrorCode.ErrInsufficientFee
      };
    }
    if (trimmedMessage.toLowerCase().includes('insufficient funds')) {
      return {
        message: 'You do not have enough funds to cover transaction fees.',
        code: ChainCosmosErrorCode.ErrInsufficientFunds
      };
    }
  }
  return {
    message: message,
    code: UnspecifiedErrorCode
  };
};
var TransactionException = /*#__PURE__*/function (_ConcreteException) {
  _inheritsLoose(TransactionException, _ConcreteException);
  function TransactionException(error, context) {
    var _this;
    _this = _ConcreteException.call(this, error, context) || this;
    _this.type = ErrorType.ChainError;
    return _this;
  }
  var _proto = TransactionException.prototype;
  _proto.parse = function parse() {
    var message = this.message;
    var _mapMessage = mapMessage(message),
      parsedMessage = _mapMessage.message,
      code = _mapMessage.code;
    this.setMessage(parsedMessage);
    this.setContextCode(code);
  };
  return TransactionException;
}(ConcreteException);

var WalletException = /*#__PURE__*/function (_ConcreteException) {
  _inheritsLoose(WalletException, _ConcreteException);
  function WalletException() {
    return _ConcreteException.apply(this, arguments) || this;
  }
  return WalletException;
}(ConcreteException);

var EthereumChainId;
(function (EthereumChainId) {
  EthereumChainId[EthereumChainId["Mainnet"] = 1] = "Mainnet";
  EthereumChainId[EthereumChainId["Ropsten"] = 3] = "Ropsten";
  EthereumChainId[EthereumChainId["Rinkeby"] = 4] = "Rinkeby";
  EthereumChainId[EthereumChainId["Goerli"] = 5] = "Goerli";
  EthereumChainId[EthereumChainId["Kovan"] = 42] = "Kovan";
  EthereumChainId[EthereumChainId["Ganache"] = 1337] = "Ganache";
  EthereumChainId[EthereumChainId["HardHat"] = 31337] = "HardHat";
  EthereumChainId[EthereumChainId["AlphaDevnetEvm"] = 9605] = "AlphaDevnetEvm";
  EthereumChainId[EthereumChainId["DevnetEvm"] = 9603] = "DevnetEvm";
  EthereumChainId[EthereumChainId["TestnetEvm"] = 9601] = "TestnetEvm";
  EthereumChainId[EthereumChainId["MainnetEvm"] = 9600] = "MainnetEvm";
  EthereumChainId[EthereumChainId["InternalDevnet"] = 9000] = "InternalDevnet";
  EthereumChainId[EthereumChainId["LocalEvm"] = 9604] = "LocalEvm";
})(EthereumChainId || (EthereumChainId = {}));
var ChainId;
(function (ChainId) {
  ChainId["Mainnet"] = "router-1";
  ChainId["Testnet"] = "router-1";
  ChainId["Devnet"] = "router-1";
  ChainId["AlphaDevnet"] = "router_9000-1";
})(ChainId || (ChainId = {}));

var CosmosChainId;
(function (CosmosChainId) {
  CosmosChainId["Router"] = "router-1";
  CosmosChainId["Cosmoshub"] = "cosmoshub-4";
  CosmosChainId["Juno"] = "juno-1";
  CosmosChainId["Osmosis"] = "osmosis-1";
  CosmosChainId["Terra"] = "columbus-5";
  CosmosChainId["TerraUST"] = "columbus-5";
  CosmosChainId["Chihuahua"] = "chihuahua-1";
  CosmosChainId["Axelar"] = "axelar-dojo-1";
  CosmosChainId["Evmos"] = "evmos_9001-2";
  CosmosChainId["Persistence"] = "core-1";
  CosmosChainId["Secret"] = "secret-4";
})(CosmosChainId || (CosmosChainId = {}));
var TestnetCosmosChainId;
(function (TestnetCosmosChainId) {
  TestnetCosmosChainId["Router"] = "router-1";
  TestnetCosmosChainId["Cosmoshub"] = "cosmoshub";
})(TestnetCosmosChainId || (TestnetCosmosChainId = {}));
var DevnetCosmosChainId;
(function (DevnetCosmosChainId) {
  DevnetCosmosChainId["Router"] = "router-1";
})(DevnetCosmosChainId || (DevnetCosmosChainId = {}));
var AlphaDevnetCosmosChainId;
(function (AlphaDevnetCosmosChainId) {
  AlphaDevnetCosmosChainId["Router"] = "router_9000-1";
})(AlphaDevnetCosmosChainId || (AlphaDevnetCosmosChainId = {}));

var TradeExecutionType;
(function (TradeExecutionType) {
  TradeExecutionType["Market"] = "market";
  TradeExecutionType["LimitFill"] = "limitFill";
  TradeExecutionType["LimitMatchRestingOrder"] = "limitMatchRestingOrder";
  TradeExecutionType["LimitMatchNewOrder"] = "limitMatchNewOrder";
})(TradeExecutionType || (TradeExecutionType = {}));
var TradeExecutionSide;
(function (TradeExecutionSide) {
  TradeExecutionSide["Maker"] = "market";
  TradeExecutionSide["Taker"] = "taker";
})(TradeExecutionSide || (TradeExecutionSide = {}));
var TradeDirection;
(function (TradeDirection) {
  TradeDirection["Buy"] = "buy";
  TradeDirection["Sell"] = "sell";
  TradeDirection["Long"] = "long";
  TradeDirection["Short"] = "short";
})(TradeDirection || (TradeDirection = {}));
var OrderState;
(function (OrderState) {
  OrderState["Booked"] = "booked";
  OrderState["PartiallyFilled"] = "partially_filled";
  OrderState["Filled"] = "filled";
  OrderState["Canceled"] = "canceled";
  OrderState["Triggered"] = "triggered";
})(OrderState || (OrderState = {}));

var _ChainIdByChainType;
var mainnetChainInfo = {
  feeDenom: 'route',
  chainId: 'router_9600-1',
  env: 'mainnet'
};
var testnetChainInfo = {
  feeDenom: 'route',
  chainId: 'router_9601-1',
  env: 'testnet'
};
var loadTestChainInfo = {
  feeDenom: 'route',
  chainId: 'router_9601-1',
  env: 'load-test'
};
var devnetChainInfo = {
  feeDenom: 'route',
  chainId: 'router_9603-1',
  env: 'devnet'
};
var localChainInfo = {
  feeDenom: 'route',
  chainId: 'router_9604-1',
  env: 'local'
};
var dockerChainInfo = {
  feeDenom: 'route',
  chainId: 'router-1',
  env: 'docker'
};
var internalDevnetChainInfo = {
  feeDenom: 'route',
  chainId: 'router_9000-1',
  env: 'internal-devnet'
};
var alphaDevnetChainInfo = {
  feeDenom: 'route',
  chainId: 'router_9605-1',
  env: 'alpha-devnet'
};
var ChainType;
(function (ChainType) {
  ChainType["EVM"] = "CHAIN_TYPE_EVM";
})(ChainType || (ChainType = {}));
var ChainTypes = [ChainType.EVM];
var ChainIdByChainType = (_ChainIdByChainType = {}, _ChainIdByChainType[ChainType.EVM] = [{
  chainId: '3',
  name: 'Ropsten',
  logoURI: 'https://cryptologos.cc/logos/ethereum-eth-logo.png?v=023'
}, {
  chainId: '4',
  name: 'Rinkeby',
  logoURI: 'https://cryptologos.cc/logos/ethereum-eth-logo.png?v=023'
}, {
  chainId: '5',
  name: 'Georli',
  logoURI: 'https://cryptologos.cc/logos/ethereum-eth-logo.png?v=023'
}, {
  chainId: '42',
  name: 'Kovan',
  logoURI: 'https://cryptologos.cc/logos/ethereum-eth-logo.png?v=023'
}, {
  chainId: '1',
  name: 'Georli',
  logoURI: 'https://cryptologos.cc/logos/ethereum-eth-logo.png?v=023'
}, {
  chainId: '80001',
  name: 'Matic Testnet',
  logoURI: 'https://cryptologos.cc/logos/polygon-matic-logo.png?v=023'
}], _ChainIdByChainType);

var urlEndpointsMainnet = {
  explorerGql: 'https://alpha-explorer-api.routerprotocol.com/gql/query',
  explorerGqlWs: 'wss://alpha-explorer-api.routerprotocol.com/gql/query',
  lcdEndpoint: 'https://devnet-alpha.lcd.routerprotocol.com',
  grpcEndpoint: 'https://devnet-alpha.grpcweb.routerprotocol.com',
  tmEndpoint: 'https://devnet-alpha.tm.routerprotocol.com',
  rpcEndpoint: 'https://devnet.evm.rpc.routerprotocol.com'
};
var urlEndpointsTestnet = {
  explorerGql: 'https://explorer-api.testnet.routerchain.dev/gql/query',
  explorerGqlWs: 'wss://explorer-api.testnet.routerchain.dev/gql/query',
  lcdEndpoint: 'https://lcd.testnet.routerchain.dev',
  grpcEndpoint: 'https://grpcweb.testnet.routerchain.dev',
  tmEndpoint: 'https://tm.rpc.testnet.routerchain.dev',
  rpcEndpoint: 'https://evm.rpc.testnet.routerchain.dev'
};
var urlEndpointsLoadtest = {
  explorerGql: 'http://52.66.245.51:3000/gql/query',
  explorerGqlWs: 'ws://52.66.245.51:3000/gql/query',
  lcdEndpoint: 'http://3.110.53.116:1317',
  grpcEndpoint: 'http://3.110.53.116:9090',
  tmEndpoint: 'http://3.110.53.116:26657',
  rpcEndpoint: 'http://3.110.53.116:8545'
};
var urlEndpointsTestnetEu = {
  explorerGql: 'https://explorer-api.testnet.routerchain.dev/gql/query',
  explorerGqlWs: 'wss://explorer-api.testnet.routerchain.dev/gql/query',
  lcdEndpoint: 'https://lcd.testnet-eu.routerchain.dev',
  grpcEndpoint: 'https://grpcweb.testnet-eu.routerchain.dev',
  tmEndpoint: 'https://tm.rpc.testnet-eu.routerchain.dev',
  rpcEndpoint: 'https://evm.rpc.testnet-eu.routerchain.dev'
};
var urlEndpointsInternalDevnet = {
  explorerGql: 'https://alpha-explorer-api.routerprotocol.com/gql/query',
  explorerGqlWs: 'wss://alpha-explorer-api.routerprotocol.com/gql/query',
  lcdEndpoint: 'https://devnet-internal.lcd.routerprotocol.com',
  grpcEndpoint: 'https://devnet-internal.grpcweb.routerprotocol.com',
  tmEndpoint: 'https://devnet-internal.tm.routerprotocol.com',
  rpcEndpoint: 'https://devnet-internal.evm.rpc.routerprotocol.com'
};
var urlEndpointsAlphaDevnet = {
  explorerGql: 'https://alpha-explorer-api.routerprotocol.com/gql/query',
  explorerGqlWs: 'wss://alpha-explorer-api.routerprotocol.com/gql/query',
  lcdEndpoint: 'https://devnet-alpha.lcd.routerprotocol.com',
  grpcEndpoint: 'https://devnet-alpha.grpcweb.routerprotocol.com',
  tmEndpoint: 'https://devnet-alpha.tm.routerprotocol.com',
  rpcEndpoint: 'https://devnet-alpha.evm.rpc.routerprotocol.com'
};
var urlEndpointsDevnet = {
  explorerGql: 'https://devnet-explorer-api.routerprotocol.com/gql/query',
  explorerGqlWs: 'wss://devnet-explorer-api.routerprotocol.com/gql/query',
  lcdEndpoint: 'https://devnet.lcd.routerprotocol.com',
  grpcEndpoint: 'https://devnet.grpcweb.routerprotocol.com',
  tmEndpoint: 'https://devnet.tm.routerprotocol.com',
  rpcEndpoint: 'https://devnet.evm.rpc.routerprotocol.com'
};
var urlEndpointsLocal = {
  explorerGql: 'http://127.0.0.1:3000/gql/query',
  explorerGqlWs: 'ws://127.0.0.1:3000/gql/query',
  lcdEndpoint: 'http://127.0.0.1:1317',
  grpcEndpoint: 'http://127.0.0.1:9090',
  tmEndpoint: 'http://127.0.0.1:26657',
  rpcEndpoint: 'http://127.0.0.1:8545'
};
var urlEndpointsDocker = {
  explorerGql: 'http://host.docker.internal:3000/gql/query',
  explorerGqlWs: 'wss://host.docker.internal:3000/gql/query',
  lcdEndpoint: 'https://devnet-alpha.lcd.routerprotocol.com',
  grpcEndpoint: 'https://devnet-alpha.grpcweb.routerprotocol.com',
  tmEndpoint: 'https://devnet-alpha.tm.routerprotocol.com',
  rpcEndpoint: 'https://devnet-alpha.evm.rpc.routerprotocol.com'
};

/**
 * Different networks available on Router chain.
 *
 * @group Network
 */
var Network;
(function (Network) {
  Network["Local"] = "local";
  Network["InternalDevnet"] = "internal-devnet";
  Network["AlphaDevnet"] = "alpha-devnet";
  Network["Devnet"] = "devnet";
  Network["Testnet"] = "testnet";
  Network["TestnetEu"] = "testnet-eu";
  Network["Mainnet"] = "mainnet";
  Network["Docker"] = "docker";
  Network["LoadTest"] = "load-test";
})(Network || (Network = {}));
var getNetworkType = function getNetworkType(type) {
  switch (type.toLowerCase()) {
    case 'local':
      return Network.Local;
    case 'internal-devnet':
      return Network.InternalDevnet;
    case 'alpha-devnet':
      return Network.AlphaDevnet;
    case 'devnet':
      return Network.Devnet;
    case 'testnet':
      return Network.Testnet;
    case 'testnet-eu':
      return Network.TestnetEu;
    case 'mainnet':
      return Network.Mainnet;
    case 'docker':
      return Network.Docker;
    case 'load-test':
      return Network.LoadTest;
    default:
      return Network.Devnet;
  }
};

var _NETWORK_ENDPOINT, _CHAIN_INFO, _ETH_CHAINID;
/**
 * @hidden
 * Supported network endpoints for Router chain. Also see {@link Network} for network names.
 *
 * @example
 * const endpoint =  networkEndpoints["alpha-devnet"]; // here, 'alpha-devnet' is network name
 *
 * @group Network
 */
var NETWORK_ENDPOINT = (_NETWORK_ENDPOINT = {}, _NETWORK_ENDPOINT[Network.Mainnet] = urlEndpointsMainnet, _NETWORK_ENDPOINT[Network.Devnet] = urlEndpointsDevnet, _NETWORK_ENDPOINT[Network.Testnet] = urlEndpointsTestnet, _NETWORK_ENDPOINT[Network.TestnetEu] = urlEndpointsTestnetEu, _NETWORK_ENDPOINT[Network.Local] = urlEndpointsLocal, _NETWORK_ENDPOINT[Network.Docker] = urlEndpointsDocker, _NETWORK_ENDPOINT[Network.AlphaDevnet] = urlEndpointsAlphaDevnet, _NETWORK_ENDPOINT[Network.InternalDevnet] = urlEndpointsInternalDevnet, _NETWORK_ENDPOINT[Network.LoadTest] = urlEndpointsLoadtest, _NETWORK_ENDPOINT);
/**
 * @hidden
 * Supported Router chain info.
 *
 * @group Network
 */
var CHAIN_INFO = (_CHAIN_INFO = {}, _CHAIN_INFO[Network.Mainnet] = mainnetChainInfo, _CHAIN_INFO[Network.Devnet] = devnetChainInfo, _CHAIN_INFO[Network.Testnet] = testnetChainInfo, _CHAIN_INFO[Network.TestnetEu] = testnetChainInfo, _CHAIN_INFO[Network.Local] = localChainInfo, _CHAIN_INFO[Network.Docker] = dockerChainInfo, _CHAIN_INFO[Network.AlphaDevnet] = alphaDevnetChainInfo, _CHAIN_INFO[Network.InternalDevnet] = internalDevnetChainInfo, _CHAIN_INFO[Network.LoadTest] = loadTestChainInfo, _CHAIN_INFO);
var ETH_CHAINID = (_ETH_CHAINID = {}, _ETH_CHAINID[Network.Mainnet] = EthereumChainId.MainnetEvm, _ETH_CHAINID[Network.Devnet] = EthereumChainId.DevnetEvm, _ETH_CHAINID[Network.Testnet] = EthereumChainId.TestnetEvm, _ETH_CHAINID[Network.TestnetEu] = EthereumChainId.TestnetEvm, _ETH_CHAINID[Network.Local] = EthereumChainId.LocalEvm, _ETH_CHAINID[Network.Docker] = EthereumChainId.Goerli, _ETH_CHAINID[Network.AlphaDevnet] = EthereumChainId.AlphaDevnetEvm, _ETH_CHAINID[Network.InternalDevnet] = EthereumChainId.InternalDevnet, _ETH_CHAINID[Network.LoadTest] = EthereumChainId.TestnetEvm, _ETH_CHAINID);
/**
 * Get endpoint object for a network. Also see {@link Network} for different networks on Router chain.
 *
 * @example
 * const endpoint =  getEndpointsForNetwork(Network.devnet);
 *
 * @group Network
 */
var getEndpointsForNetwork = function getEndpointsForNetwork(network) {
  return NETWORK_ENDPOINT[network];
};
var getChainInfoForNetwork = function getChainInfoForNetwork(network) {
  return CHAIN_INFO[network];
};
var getEthereumChainIdForNetwork = function getEthereumChainIdForNetwork(network) {
  return ETH_CHAINID[network];
};
var getNetworkInfo = function getNetworkInfo(network) {
  return _extends({}, CHAIN_INFO[network], NETWORK_ENDPOINT[network]);
};
var getEndpointsFromChainId = function getEndpointsFromChainId(chainId) {
  switch (chainId) {
    case CosmosChainId.Router:
      return {
        rpc: getEndpointsForNetwork(getNetworkType('mainnet')).tmEndpoint,
        rest: getEndpointsForNetwork(getNetworkType('mainnet')).lcdEndpoint
      };
    case TestnetCosmosChainId.Router:
      return {
        rpc: getEndpointsForNetwork(getNetworkType('testnet')).tmEndpoint,
        rest: getEndpointsForNetwork(getNetworkType('testnet')).lcdEndpoint
      };
    case DevnetCosmosChainId.Router:
      return {
        rpc: getEndpointsForNetwork(getNetworkType('devnet')).tmEndpoint,
        rest: getEndpointsForNetwork(getNetworkType('devnet')).lcdEndpoint
      };
    case CosmosChainId.Cosmoshub:
      return {
        rpc: 'https://tm.cosmos.injective.network',
        rest: 'https://lcd.cosmos.injective.network'
      };
    case CosmosChainId.Osmosis:
      return {
        rpc: 'https://tm.osmosis.injective.network',
        rest: 'https://lcd.osmosis.injective.network'
      };
    case CosmosChainId.Juno:
      return {
        rpc: 'https://tm.juno.injective.network',
        rest: 'https://lcd.juno.injective.network'
      };
    case CosmosChainId.Terra:
      return {
        rpc: 'https://tm.terra.injective.network',
        rest: 'https://lcd.terra.injective.network'
      };
    case CosmosChainId.TerraUST:
      return {
        rpc: 'https://tm.terra.injective.network',
        rest: 'https://lcd.terra.injective.network'
      };
    case CosmosChainId.Axelar:
      return {
        rpc: 'https://tm.axelar.injective.network',
        rest: 'https://lcd.axelar.injective.network'
      };
    case CosmosChainId.Evmos:
      return {
        rpc: 'https://tm.evmos.injective.network',
        rest: 'https://lcd.evmos.injective.network'
      };
    case CosmosChainId.Persistence:
      return {
        rpc: 'https://tm.persistence.injective.network',
        rest: 'https://lcd.persistence.injective.network'
      };
    case CosmosChainId.Secret:
      return {
        rpc: 'https://tm.secret.injective.network',
        rest: 'https://lcd.secret.injective.network'
      };
    case CosmosChainId.Chihuahua:
      return {
        rpc: 'https://rpc.chihuahua.wtf',
        rest: 'https://api.chihuahua.wtf'
      };
    case TestnetCosmosChainId.Cosmoshub:
      return {
        rpc: 'https://testnet.tm.cosmos.injective.dev',
        rest: 'https://testnet.lcd.cosmos.injective.dev'
      };
    default:
      throw new GeneralException(new Error("Endpoints for " + chainId + " not found"));
  }
};

var bigNumberBaseToWei = function bigNumberBaseToWei(value, decimals) {
  if (decimals === void 0) {
    decimals = 18;
  }
  return new BigNumber(value).multipliedBy(new BigNumber(10).pow(decimals));
};
var bigNumberWeiToBase = function bigNumberWeiToBase(value, decimals) {
  if (decimals === void 0) {
    decimals = 18;
  }
  return new BigNumber(value).dividedBy(new BigNumber(10).pow(decimals));
};

var BigNumberInBase = /*#__PURE__*/function (_BigNumber) {
  _inheritsLoose(BigNumberInBase, _BigNumber);
  function BigNumberInBase() {
    return _BigNumber.apply(this, arguments) || this;
  }
  BigNumberInBase.make = function make(number) {
    return new BigNumberInBase(number);
  };
  var _proto = BigNumberInBase.prototype;
  _proto.minus = function minus(n, base) {
    return new BigNumberInBase(_BigNumber.prototype.minus.call(this, n, base));
  };
  _proto.plus = function plus(n, base) {
    return new BigNumberInBase(_BigNumber.prototype.plus.call(this, n, base));
  };
  _proto.dividedBy = function dividedBy(n, base) {
    return new BigNumberInBase(_BigNumber.prototype.dividedBy.call(this, n, base));
  };
  _proto.div = function div(n, base) {
    return new BigNumberInBase(_BigNumber.prototype.div.call(this, n, base));
  };
  _proto.multipliedBy = function multipliedBy(n, base) {
    return new BigNumberInBase(_BigNumber.prototype.multipliedBy.call(this, n, base));
  };
  _proto.times = function times(n, base) {
    return new BigNumberInBase(_BigNumber.prototype.times.call(this, n, base));
  };
  _proto.pow = function pow(n, base) {
    return new BigNumberInBase(_BigNumber.prototype.pow.call(this, n, base));
  };
  _proto.toWei = function toWei(decimals) {
    if (decimals === void 0) {
      decimals = 18;
    }
    return bigNumberBaseToWei(this, decimals);
  };
  return BigNumberInBase;
}(BigNumber);

var ROUTER_DENOM = 'route';
var BECH32_PUBKEY_ACC_PREFIX = 'routerpub';
var BECH32_PUBKEY_VAL_PREFIX = 'routervaloperpub';
var BECH32_PUBKEY_CONS_PREFIX = 'routervalconspub';
var BECH32_ADDR_ACC_PREFIX = 'router';
var BECH32_ADDR_VAL_PREFIX = 'routervaloper';
var BECH32_ADDR_CONS_PREFIX = 'routervalcons';
var DEFAULT_DERIVATION_PATH = "m/44'/60'/0'/0/0";
var DEFAULT_BRIDGE_FEE_DENOM = 'route';
var DEFAULT_BRIDGE_FEE_PRICE = '500000000';
var DEFAULT_BRIDGE_FEE_AMOUNT = '200000000000000';
var DEFAULT_TIMEOUT_HEIGHT = 40;
var DEFAULT_FEE_DENOM = 'route';
var DEFAULT_GAS_LIMIT = 400000;
var DEFAULT_EXCHANGE_GAS_LIMIT = 200000;
var DEFAULT_GAS_PRICE = 500000000;
var DUST_AMOUNT = 0.0001;
var PAGINATION_TOTAL_PAGE_LIMIT = 10000;
var DEFAULT_PAGINATION_TOTAL_COUNT = 1000000;
var DEFAULT_BLOCK_TIMEOUT_HEIGHT = 30;
var DEFAULT_BLOCK_TIME_IN_SECONDS = 2;
var DEFAULT_TX_BLOCK_INCLUSION_TIMEOUT_IN_MS = DEFAULT_BLOCK_TIMEOUT_HEIGHT * DEFAULT_BLOCK_TIME_IN_SECONDS * 1000;
var DEFAULT_TIMESTAMP_TIMEOUT_MS = 60 * 1000 * 3;
var DEFAULT_STD_FEE = {
  amount: [{
    amount: /*#__PURE__*/new BigNumberInBase(DEFAULT_GAS_LIMIT).times(DEFAULT_GAS_PRICE).toString(),
    denom: DEFAULT_FEE_DENOM
  }],
  gas: /*#__PURE__*/DEFAULT_GAS_LIMIT.toString()
};
var ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';
var DEFAULT_EXCHANGE_LIMIT = 200000;
var DEFAULT_STD_FEE_BY_DENOM = function DEFAULT_STD_FEE_BY_DENOM(denom) {
  if (denom === void 0) {
    denom = 'route';
  }
  return {
    amount: [{
      denom: denom,
      amount: new BigNumber(DEFAULT_GAS_LIMIT).times(DEFAULT_GAS_PRICE).toString()
    }],
    gas: DEFAULT_GAS_LIMIT.toString()
  };
};

/**
 * @group Util
 */
var Address = /*#__PURE__*/function () {
  function Address(bech32Address) {
    this.bech32Address = bech32Address;
  }
  var _proto = Address.prototype;
  _proto.compare = function compare(address) {
    return this.bech32Address.toLowerCase() === address.bech32Address.toLowerCase();
  }
  //@ts-ignore
  ;
  /**
   * Create an address instance from a bech32-encoded address and a prefix
   * @param {string} bech32 bech32-encoded address
   * @param {string} prefix
   * @return {Address}
   * @throws {Error} if bech is not a valid bech32-encoded address
   */
  Address.fromBech32 = function fromBech32(bech, prefix) {
    if (prefix === void 0) {
      prefix = BECH32_ADDR_ACC_PREFIX;
    }
    var address = Buffer.from(bech32.fromWords(bech32.decode(bech).words)).toString('hex');
    var addressInHex = address.startsWith('0x') ? address : "0x" + address;
    var addressBuffer = Address$1.fromString(addressInHex.toString()).toBuffer();
    var bech32Address = bech32.encode(prefix, bech32.toWords(addressBuffer));
    return new Address(bech32Address);
  }
  /**
   * Create an address instance from an ethereum address
   * @param {string} hex Ethereum address
   * @param {string} prefix
   * @return {Address}
   * @throws {Error} if bech is not a valid bech32-encoded address
   */;
  Address.fromHex = function fromHex(hex, prefix) {
    if (prefix === void 0) {
      prefix = BECH32_ADDR_ACC_PREFIX;
    }
    var addressHex = hex.startsWith('0x') ? hex : "0x" + hex;
    var addressBuffer = Address$1.fromString(addressHex.toString()).toBuffer();
    var bech32Address = bech32.encode(prefix, bech32.toWords(addressBuffer));
    return new Address(bech32Address);
  }
  /**
   * Convert an address instance to a bech32-encoded account address
   * @param {string} prefix
   * @returns {string}
   */;
  _proto.toBech32 = function toBech32(prefix) {
    if (prefix === void 0) {
      prefix = BECH32_ADDR_ACC_PREFIX;
    }
    var address = this.toHex();
    var addressHex = address.startsWith('0x') ? address : "0x" + address;
    var addressBuffer = Address$1.fromString(addressHex).toBuffer();
    return bech32.encode(prefix, bech32.toWords(addressBuffer));
  }
  /**
   * Return a bech32-encoded account address
   * @return {string}
   * @throws {Error} if this address is not a valid account address
   * */;
  _proto.toAccountAddress = function toAccountAddress() {
    return this.toBech32(BECH32_ADDR_ACC_PREFIX);
  }
  /**
   * Return a bech32-encoded validator address
   * @return {string}
   * @throws {Error} if this address is not a valid validator address
   * */;
  _proto.toValidatorAddress = function toValidatorAddress() {
    return this.toBech32(BECH32_ADDR_VAL_PREFIX);
  }
  /**
   * Return a bech32-encoded consensus address
   * @return {string}
   * @throws {Error} if this address is not a valid consensus address
   * */;
  _proto.toConsensusAddress = function toConsensusAddress() {
    return this.toBech32(BECH32_ADDR_CONS_PREFIX);
  }
  /**
   * Return a hex representation of address
   * @return {string}
   * @throws {Error} if this address is not a valid account address
   * */;
  _proto.toHex = function toHex() {
    var bech32Address = this.bech32Address;
    var address = Buffer.from(bech32.fromWords(bech32.decode(bech32Address).words)).toString('hex');
    return address.startsWith('0x') ? address : "0x" + address;
  }
  /**
   * Return a subaccount address from the given bech32 encoded address
   * @param {number} index the subaccount index
   * @return {string}
   * @throws {Error} if this address is not a valid account address
   * */;
  _proto.getSubaccountId = function getSubaccountId(index) {
    if (index === void 0) {
      index = 0;
    }
    var suffix = '0'.repeat(23) + index; /* TODO for double digit numbers */
    return "" + this.toHex() + suffix;
  }
  /**
   * Return a ethereum address from the given bech32 encoded address
   * @return {string}
   * @throws {Error} if this address is not a valid account address
   * */;
  _proto.getEthereumAddress = function getEthereumAddress() {
    return this.toHex();
  };
  _createClass(Address, [{
    key: "address",
    get: function get() {
      return this.bech32Address;
    }
  }]);
  return Address;
}();

/**
 * @group Util
 */
var BaseAccount = /*#__PURE__*/function (_Address) {
  _inheritsLoose(BaseAccount, _Address);
  function BaseAccount(_ref) {
    var _this;
    var address = _ref.address,
      accountNumber = _ref.accountNumber,
      sequence = _ref.sequence,
      pubKey = _ref.pubKey;
    _this = _Address.call(this, address) || this;
    _this.accountNumber = accountNumber;
    _this.sequence = sequence;
    _this.pubKey = pubKey;
    return _this;
  }
  BaseAccount.fromRestApi = function fromRestApi(accountResponse) {
    var baseAccount = accountResponse.account.base_account;
    return new BaseAccount({
      address: baseAccount.address,
      accountNumber: baseAccount.account_number ? parseInt(baseAccount.account_number, 10) : 0,
      sequence: baseAccount.sequence ? parseInt(baseAccount.sequence, 10) : 0,
      pubKey: baseAccount.pub_key ? {
        type: baseAccount.pub_key['@type'],
        key: baseAccount.pub_key.key
      } : {
        type: '',
        key: ''
      }
    });
  };
  BaseAccount.fromRestCosmosApi = function fromRestCosmosApi(accountResponse) {
    return new BaseAccount({
      address: accountResponse.address,
      accountNumber: accountResponse.account_number ? parseInt(accountResponse.account_number, 10) : 0,
      sequence: accountResponse.sequence ? parseInt(accountResponse.sequence, 10) : 0,
      pubKey: accountResponse.pub_key ? {
        type: accountResponse.pub_key['@type'],
        key: accountResponse.pub_key.key
      } : {
        type: '',
        key: ''
      }
    });
  };
  var _proto = BaseAccount.prototype;
  _proto.incrementSequence = function incrementSequence() {
    this.sequence += 1;
  };
  _proto.toAccountDetails = function toAccountDetails() {
    return {
      address: this.bech32Address,
      pubKey: this.pubKey,
      accountNumber: this.accountNumber,
      sequence: this.sequence
    };
  };
  return BaseAccount;
}(Address);

var sleep = function sleep(timeout) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, timeout);
  });
};
//export const isServerSide = () => true;
//@ts-ignore
var isServerSide = function isServerSide() {
  return typeof window === 'undefined';
};
var getWeb3GatewayMessage = function getWeb3GatewayMessage(message, type) {
  return _extends({}, snakeCaseKeys(message), {
    '@type': type
  });
};
var mapMultipleComposerResponseMessages = function mapMultipleComposerResponseMessages(messages) {
  return messages.reduce(function (messages, message) {
    var web3GatewayMessage = Array.isArray(message.web3GatewayMessage) ? message.web3GatewayMessage : [message.web3GatewayMessage];
    var directBroadcastMessage = Array.isArray(message.directBroadcastMessage) ? message.directBroadcastMessage : [message.directBroadcastMessage];
    return {
      web3GatewayMessage: [].concat(messages.web3GatewayMessage, web3GatewayMessage),
      directBroadcastMessage: [].concat(messages.directBroadcastMessage, directBroadcastMessage)
    };
  }, {
    web3GatewayMessage: [],
    directBroadcastMessage: []
  });
};
var objectToJson = function objectToJson(object, params) {
  var _ref = params || {
      replacer: null,
      indentation: 2
    },
    replacer = _ref.replacer,
    indentation = _ref.indentation;
  return JSON.stringify(object, replacer, indentation);
};
var protoObjectToJson = function protoObjectToJson(object, params) {
  var _ref2 = params || {
      replacer: null,
      indentation: 2
    },
    replacer = _ref2.replacer,
    indentation = _ref2.indentation;
  if (object.toObject !== undefined) {
    return JSON.stringify(object.toObject(), replacer, indentation);
  }
  return objectToJson(object, {
    replacer: replacer,
    indentation: indentation
  });
};
var grpcCoinToUiCoin = function grpcCoinToUiCoin(coin) {
  return {
    amount: coin.getAmount(),
    denom: coin.getDenom()
  };
};
var uint8ArrayToString = function uint8ArrayToString(string) {
  if (!string) {
    return '';
  }
  if (string.constructor !== Uint8Array) {
    return string;
  }
  return new TextDecoder().decode(string);
};
var toPascalCase = function toPascalCase(str) {
  return ("" + str).toLowerCase().replace(new RegExp(/[-_]+/, 'g'), ' ').replace(new RegExp(/[^\w\s]/, 'g'), '').replace(new RegExp(/\s+(.)(\w*)/, 'g'), function (_$1, $2, $3) {
    return "" + ($2.toUpperCase() + $3);
  }).replace(new RegExp(/\w/), function (s) {
    return s.toUpperCase();
  });
};
var snakeToPascal = function snakeToPascal(str) {
  return str.split('/').map(function (snake) {
    return snake.split('_').map(function (substr) {
      return substr.charAt(0).toUpperCase() + substr.slice(1);
    }).join('');
  }).join('/');
};

if (isServerSide()) {
  grpc.setDefaultTransport(NodeHttpTransport());
}
/**
 * @hidden
 */
var BaseGrpcConsumer = /*#__PURE__*/function () {
  function BaseGrpcConsumer(endpoint) {
    this.endpoint = endpoint;
  }
  var _proto = BaseGrpcConsumer.prototype;
  _proto.request = function request(_request, service) {
    var _this = this;
    return new Promise(function (resolve, reject) {
      grpc.unary(service, {
        request: _request,
        host: _this.endpoint,
        onEnd: function onEnd(res) {
          var statusMessage = res.statusMessage,
            status = res.status,
            message = res.message;
          if (status === grpc.Code.OK && message) {
            resolve(message);
          }
          reject(new Error(statusMessage));
        }
      });
    });
  };
  return BaseGrpcConsumer;
}();

var paginationRequestFromPagination = function paginationRequestFromPagination(pagination) {
  var paginationForRequest = new PageRequest();
  if (!pagination) {
    return;
  }
  if (pagination.key) {
    paginationForRequest.setKey(pagination.key);
  }
  if (pagination.limit !== undefined) {
    paginationForRequest.setLimit(pagination.limit);
  }
  if (pagination.offset !== undefined) {
    paginationForRequest.setOffset(pagination.offset);
  }
  if (pagination.reverse !== undefined) {
    paginationForRequest.setReverse(pagination.reverse);
  }
  if (pagination.countTotal !== undefined) {
    paginationForRequest.setCountTotal(pagination.countTotal);
  }
  return paginationForRequest;
};
var generatePagination = function generatePagination(pagination) {
  if (!pagination) {
    return;
  }
  if (!pagination.nextKey) {
    return;
  }
  return {
    pagination: {
      key: pagination.nextKey
    }
  };
};
var paginationUint8ArrayToString = function paginationUint8ArrayToString(key) {
  if (key.constructor !== Uint8Array) {
    return key;
  }
  // TODO: uncomment
  // return new TextDecoder().decode(key)
  return '';
};
var pageResponseToPagination = function pageResponseToPagination(_ref) {
  var newPagination = _ref.newPagination,
    oldPagination = _ref.oldPagination;
  if (!newPagination) {
    return {
      prev: null,
      current: null,
      nextKey: null
    };
  }
  var nextKey = paginationUint8ArrayToString(newPagination.nextKey);
  if (!oldPagination) {
    return {
      prev: null,
      current: null,
      nextKey: nextKey
    };
  }
  return {
    prev: oldPagination.current,
    current: oldPagination.nextKey,
    nextKey: nextKey
  };
};
var grpcPaginationToPagination = function grpcPaginationToPagination(pagination) {
  return {
    total: pagination ? pagination.getTotal() : 0,
    nextKey: pagination ? pagination.getNextKey_asB64() : ''
  };
};

var ChainGrpcBankTransformer = /*#__PURE__*/function () {
  function ChainGrpcBankTransformer() {}
  ChainGrpcBankTransformer.grpcCoinToCoin = function grpcCoinToCoin(coin) {
    return {
      denom: coin.getDenom(),
      amount: coin.getAmount()
    };
  };
  ChainGrpcBankTransformer.grpcCoinsToCoins = function grpcCoinsToCoins(coins) {
    return coins.map(ChainGrpcBankTransformer.grpcCoinToCoin);
  };
  ChainGrpcBankTransformer.moduleParamsResponseToModuleParams = function moduleParamsResponseToModuleParams(response) {
    var params = response.getParams();
    return {
      sendEnabledList: params.getSendEnabledList().map(function (e) {
        return e.toObject();
      }),
      defaultSendEnabled: params.getDefaultSendEnabled()
    };
  };
  ChainGrpcBankTransformer.totalSupplyResponseToTotalSupply = function totalSupplyResponseToTotalSupply(response) {
    var balances = response.getSupplyList();
    var pagination = response.getPagination();
    return {
      supply: balances.map(ChainGrpcBankTransformer.grpcCoinToCoin),
      pagination: grpcPaginationToPagination(pagination)
    };
  };
  ChainGrpcBankTransformer.balanceResponseToBalance = function balanceResponseToBalance(response) {
    return ChainGrpcBankTransformer.grpcCoinToCoin(response.getBalance());
  };
  ChainGrpcBankTransformer.balancesResponseToBalances = function balancesResponseToBalances(response) {
    var balances = response.getBalancesList();
    var pagination = response.getPagination();
    return {
      balances: ChainGrpcBankTransformer.grpcCoinsToCoins(balances),
      pagination: grpcPaginationToPagination(pagination)
    };
  };
  return ChainGrpcBankTransformer;
}();

var LocalStorage = /*#__PURE__*/function () {
  function LocalStorage(namespace) {
    this.storage = store.namespace(namespace);
  }
  var _proto = LocalStorage.prototype;
  _proto.get = function get(key, defaultValue) {
    if (defaultValue === void 0) {
      defaultValue = {};
    }
    return this.storage.get(key) || defaultValue;
  };
  _proto.has = function has(key) {
    return this.storage.has(key);
  };
  _proto.set = function set(key, value) {
    this.storage.set(key, value);
  };
  _proto.remove = function remove(key) {
    this.storage.remove(key);
  };
  _proto.clear = function clear() {
    this.storage.clear();
  };
  return LocalStorage;
}();

var BigNumberInWei = /*#__PURE__*/function (_BigNumber) {
  _inheritsLoose(BigNumberInWei, _BigNumber);
  function BigNumberInWei() {
    return _BigNumber.apply(this, arguments) || this;
  }
  BigNumberInWei.make = function make(number) {
    return new BigNumberInWei(number);
  };
  var _proto = BigNumberInWei.prototype;
  _proto.minus = function minus(n, base) {
    return new BigNumberInWei(_BigNumber.prototype.minus.call(this, n, base));
  };
  _proto.plus = function plus(n, base) {
    return new BigNumberInWei(_BigNumber.prototype.plus.call(this, n, base));
  };
  _proto.dividedBy = function dividedBy(n, base) {
    return new BigNumberInWei(_BigNumber.prototype.dividedBy.call(this, n, base));
  };
  _proto.div = function div(n, base) {
    return new BigNumberInWei(_BigNumber.prototype.div.call(this, n, base));
  };
  _proto.multipliedBy = function multipliedBy(n, base) {
    return new BigNumberInWei(_BigNumber.prototype.multipliedBy.call(this, n, base));
  };
  _proto.times = function times(n, base) {
    return new BigNumberInWei(_BigNumber.prototype.times.call(this, n, base));
  };
  _proto.pow = function pow(n, base) {
    return new BigNumberInWei(_BigNumber.prototype.pow.call(this, n, base));
  };
  _proto.toBase = function toBase(decimals) {
    if (decimals === void 0) {
      decimals = 18;
    }
    return bigNumberWeiToBase(this, decimals);
  };
  return BigNumberInWei;
}(BigNumber);

var HttpClient = /*#__PURE__*/function () {
  function HttpClient(endpoint) {
    this.config = {};
    this.client = axios.create({
      baseURL: endpoint,
      headers: {
        'Content-Type': 'application/json'
      }
    });
    this.config = {};
  }
  var _proto = HttpClient.prototype;
  _proto.setConfig = function setConfig(config) {
    this.config = config;
    return this;
  };
  _proto.get = function get(endpoint, params) {
    if (params === void 0) {
      params = {};
    }
    return this.client.get(endpoint, _extends({
      params: params
    }, this.config));
  };
  _proto.post = function post(endpoint, data) {
    if (data === void 0) {
      data = {};
    }
    return this.client.post(endpoint, data, this.config);
  };
  _proto["delete"] = function _delete(endpoint, params) {
    if (params === void 0) {
      params = {};
    }
    return this.client["delete"](endpoint, _extends({
      params: params
    }, this.config));
  };
  return HttpClient;
}();

var StreamManager = /*#__PURE__*/function () {
  function StreamManager() {
    this.streams = new Map();
  }
  var _proto = StreamManager.prototype;
  _proto.set = function set(stream, streamKey) {
    if (this.streams.has(streamKey)) {
      throw new Error("Stream " + streamKey + " already exists");
    }
    this.streams.set(streamKey, stream);
  };
  _proto.get = function get(streamKey) {
    if (!this.streams.has(streamKey)) {
      throw new Error("Stream " + streamKey + " is not found");
    }
    return this.streams.get(streamKey);
  };
  _proto.exists = function exists(streamKey) {
    return this.streams.has(streamKey);
  };
  _proto.cancelAll = function cancelAll() {
    this.streams.forEach(function (stream) {
      stream.cancel();
    });
    this.streams = new Map();
  };
  _proto.cancel = function cancel(streamKey) {
    if (!this.streams.has(streamKey)) {
      throw new Error("Stream " + streamKey + " is not found");
    }
    this.streams.get(streamKey).cancel();
    this.streams["delete"](streamKey);
  };
  _proto.cancelIfExists = function cancelIfExists(streamKey) {
    if (!this.streams.has(streamKey)) {
      return;
    }
    this.streams.get(streamKey).cancel();
    this.streams["delete"](streamKey);
  };
  return StreamManager;
}();

var StatusType;
(function (StatusType) {
  StatusType["Idle"] = "idle";
  StatusType["Loading"] = "loading";
  StatusType["Completed"] = "completed";
  StatusType["Error"] = "error";
  StatusType["Confirmed"] = "confirmed";
})(StatusType || (StatusType = {}));
var Status = /*#__PURE__*/function () {
  function Status(status) {
    if (status === void 0) {
      status = StatusType.Idle;
    }
    this.status = status;
  }
  var _proto = Status.prototype;
  _proto.get = function get() {
    return this.status;
  };
  _proto.set = function set(status) {
    this.status = status;
  };
  _proto.is = function is(status) {
    return this.status === status;
  };
  _proto.isLoading = function isLoading() {
    return this.is(StatusType.Loading);
  };
  _proto.isNotLoading = function isNotLoading() {
    return !this.is(StatusType.Loading);
  };
  _proto.isCompleted = function isCompleted() {
    return this.is(StatusType.Completed);
  };
  _proto.isConfirmed = function isConfirmed() {
    return this.is(StatusType.Confirmed);
  };
  _proto.isIdle = function isIdle() {
    return this.is(StatusType.Idle);
  };
  _proto.isError = function isError() {
    return this.is(StatusType.Error);
  };
  _proto.setLoading = function setLoading() {
    this.set(StatusType.Loading);
  };
  _proto.setCompleted = function setCompleted() {
    this.set(StatusType.Completed);
  };
  _proto.setConfirmed = function setConfirmed() {
    this.set(StatusType.Confirmed);
  };
  _proto.setError = function setError() {
    this.set(StatusType.Error);
  };
  _proto.setIdle = function setIdle() {
    this.set(StatusType.Idle);
  };
  _proto.toggle = function toggle() {
    this.set(this.status === StatusType.Idle ? StatusType.Loading : StatusType.Idle);
  };
  _proto.toString = function toString() {
    return this.get();
  };
  _proto.valueOf = function valueOf() {
    return this.get();
  };
  return Status;
}();

var formatWalletAddress = function formatWalletAddress(address, substrLength) {
  if (substrLength === void 0) {
    substrLength = 6;
  }
  if (address.length <= 10) {
    return address;
  }
  return address.slice(0, substrLength) + "..." + address.slice(address.length - substrLength, address.length);
};

var SECONDS_IN_A_DAY = /*#__PURE__*/new BigNumber(60 * 60 * 24);
var convertTimestampToMilliseconds = function convertTimestampToMilliseconds(timestamp) {
  if (timestamp.toString().length > 13) {
    return parseInt(timestamp.toString().slice(0, 13), 10);
  }
  if (timestamp.toString().length < 13) {
    return parseInt("" + timestamp + '0'.repeat(13 - timestamp.toString().length), 10);
  }
  return timestamp;
};
var getUTCDateFromTimestamp = function getUTCDateFromTimestamp(timestamp) {
  var date = new Date(convertTimestampToMilliseconds(timestamp));
  return date.getUTCDate() + "-" + (date.getUTCMonth() + 1) + "-" + date.getUTCFullYear();
};
var tomorrow = function tomorrow() {
  return new BigNumberInBase(Math.floor(new Date().valueOf() / 1000) + 3600 * 24);
};
var todayInSeconds = function todayInSeconds() {
  return Math.floor(Date.now() / 1000);
};
var past24Hours = function past24Hours() {
  return new BigNumberInBase(todayInSeconds()).minus(SECONDS_IN_A_DAY).toNumber();
};
var pastDays = function pastDays(day) {
  if (day === void 0) {
    day = 1;
  }
  return new BigNumberInBase(todayInSeconds()).minus(SECONDS_IN_A_DAY.times(day)).toNumber();
};
var getEndDateStringFromTimeInSeconds = function getEndDateStringFromTimeInSeconds(timeInSeconds) {
  var currentDate = new Date(timeInSeconds.toNumber() * 1000);
  return currentDate.toLocaleString('en-us');
};

var $BigNumber = /*#__PURE__*/BigNumber.clone({
  ROUNDING_MODE: BigNumber.ROUND_DOWN
});
var getSignificantDecimalsFromNumber = function getSignificantDecimalsFromNumber(number) {
  if (Math.floor(new $BigNumber(number).toNumber()) === number) {
    return 0;
  }
  var parts = new $BigNumber(number).toFixed().split('.');
  var decimals = parts[1];
  /** Number doesn't have decimals */
  if (!decimals) {
    return 0;
  }
  return decimals.length;
};
/**
 * On chain amounts queried from a sentry using the
 * gRPC API are returned with an extra decimal point
 * 18 places from the beginning, so we need to remove it
 * to get a workable amount
 */
var denomAmountFromGrpcChainDenomAmount = function denomAmountFromGrpcChainDenomAmount(value) {
  return new $BigNumber(value).dividedBy(new $BigNumber(10).pow(18));
};
/**
 * On chain amounts broadcasted to a sentry directly using the
 * gRPC API should be passed with an extra decimal point
 * 18 places from the beginning, so we need to add it
 * to get a workable amount
 */
var denomAmountToGrpcChainDenomAmount = function denomAmountToGrpcChainDenomAmount(value) {
  return new $BigNumber(value).multipliedBy(new $BigNumber(10).pow(18));
};
/**
 * On chain amounts (based on the cosmosSdk.Dec type)
 * broadcasted to a sentry directly using the
 * gRPC API should be passed with an extra decimal point
 * 18 places from the beginning (i.e multiplied by 1e18), so we need to add it
 * to get a workable amount
 */
var amountToCosmosSdkDecAmount = function amountToCosmosSdkDecAmount(value) {
  return new $BigNumber(value).multipliedBy(new $BigNumber(10).pow(18));
};
/**
 * Amount that the chain requires is in the x * 10^(quoteDecimals) format
 * where x is a human readable number
 */
var denomAmountToChainDenomAmount = function denomAmountToChainDenomAmount(_ref) {
  var value = _ref.value,
    _ref$decimals = _ref.decimals,
    decimals = _ref$decimals === void 0 ? 18 : _ref$decimals;
  return new $BigNumber(value).multipliedBy(new $BigNumber(10).pow(decimals));
};
/**
 * Amount that the chain returns is in the x * 10^(quoteDecimals) format
 * where x is a human readable number
 */
var denomAmountToChainDenomAmountToFixed = function denomAmountToChainDenomAmountToFixed(_ref2) {
  var value = _ref2.value,
    _ref2$decimals = _ref2.decimals,
    decimals = _ref2$decimals === void 0 ? 18 : _ref2$decimals,
    _ref2$decimalPlaces = _ref2.decimalPlaces,
    decimalPlaces = _ref2$decimalPlaces === void 0 ? undefined : _ref2$decimalPlaces,
    _ref2$roundingMode = _ref2.roundingMode,
    roundingMode = _ref2$roundingMode === void 0 ? BigNumber.ROUND_DOWN : _ref2$roundingMode;
  var number = denomAmountToChainDenomAmount({
    value: value,
    decimals: decimals
  });
  if (decimalPlaces === undefined) {
    return number.toFixed();
  }
  return number.toFixed(getSignificantDecimalsFromNumber(number), roundingMode);
};
/**
 * Amount that the chain returns is in the x * 10^(quoteDecimals) format
 * where x is a human readable number
 */
var denomAmountFromChainDenomAmount = function denomAmountFromChainDenomAmount(_ref3) {
  var value = _ref3.value,
    _ref3$decimals = _ref3.decimals,
    decimals = _ref3$decimals === void 0 ? 18 : _ref3$decimals;
  return new $BigNumber(value).dividedBy(new $BigNumber(10).pow(decimals));
};
/**
 *
 * Amount that the chain returns is in the x * 10^(quoteDecimals) format
 * where x is a human readable number stringified
 */
var denomAmountFromChainDenomAmountToFixed = function denomAmountFromChainDenomAmountToFixed(_ref4) {
  var value = _ref4.value,
    _ref4$decimals = _ref4.decimals,
    decimals = _ref4$decimals === void 0 ? 18 : _ref4$decimals,
    _ref4$decimalPlaces = _ref4.decimalPlaces,
    decimalPlaces = _ref4$decimalPlaces === void 0 ? undefined : _ref4$decimalPlaces,
    _ref4$roundingMode = _ref4.roundingMode,
    roundingMode = _ref4$roundingMode === void 0 ? BigNumber.ROUND_DOWN : _ref4$roundingMode;
  var number = denomAmountFromChainDenomAmount({
    value: value,
    decimals: decimals
  });
  if (decimalPlaces === undefined) {
    return number.toFixed();
  }
  return number.toFixed(getSignificantDecimalsFromNumber(number), roundingMode);
};
/**
 * Amount that the chain requires is in the x * 10^(quoteDecimals) format
 * where x is a human readable number
 */
var derivativeMarginToChainMargin = function derivativeMarginToChainMargin(_ref5) {
  var value = _ref5.value,
    _ref5$quoteDecimals = _ref5.quoteDecimals,
    quoteDecimals = _ref5$quoteDecimals === void 0 ? 18 : _ref5$quoteDecimals;
  return new $BigNumber(value).multipliedBy(new $BigNumber(10).pow(quoteDecimals));
};
/**
 * Amount that the chain requires is in the x * 10^(quoteDecimals) format
 * where x is a human readable number stringified
 */
var derivativeMarginToChainMarginToFixed = function derivativeMarginToChainMarginToFixed(_ref6) {
  var value = _ref6.value,
    _ref6$quoteDecimals = _ref6.quoteDecimals,
    quoteDecimals = _ref6$quoteDecimals === void 0 ? 18 : _ref6$quoteDecimals,
    _ref6$decimalPlaces = _ref6.decimalPlaces,
    decimalPlaces = _ref6$decimalPlaces === void 0 ? undefined : _ref6$decimalPlaces,
    _ref6$roundingMode = _ref6.roundingMode,
    roundingMode = _ref6$roundingMode === void 0 ? BigNumber.ROUND_DOWN : _ref6$roundingMode;
  var number = derivativeMarginToChainMargin({
    value: value,
    quoteDecimals: quoteDecimals
  });
  if (decimalPlaces === undefined) {
    return number.toFixed();
  }
  return number.toFixed(getSignificantDecimalsFromNumber(number), roundingMode);
};
/**
 * Amount that the chain returns is in the x * 10^(quoteDecimals) format
 * where x is a human readable number
 */
var derivativeMarginFromChainMargin = function derivativeMarginFromChainMargin(_ref7) {
  var value = _ref7.value,
    _ref7$quoteDecimals = _ref7.quoteDecimals,
    quoteDecimals = _ref7$quoteDecimals === void 0 ? 18 : _ref7$quoteDecimals;
  return new $BigNumber(value).dividedBy(new $BigNumber(10).pow(quoteDecimals));
};
/**
 * Amount that the chain returns is in the x * 10^(quoteDecimals) format
 * where x is a human readable number
 */
var derivativeMarginFromChainMarginToFixed = function derivativeMarginFromChainMarginToFixed(_ref8) {
  var value = _ref8.value,
    _ref8$quoteDecimals = _ref8.quoteDecimals,
    quoteDecimals = _ref8$quoteDecimals === void 0 ? 18 : _ref8$quoteDecimals,
    _ref8$decimalPlaces = _ref8.decimalPlaces,
    decimalPlaces = _ref8$decimalPlaces === void 0 ? undefined : _ref8$decimalPlaces,
    _ref8$roundingMode = _ref8.roundingMode,
    roundingMode = _ref8$roundingMode === void 0 ? BigNumber.ROUND_DOWN : _ref8$roundingMode;
  var number = derivativeMarginFromChainMargin({
    value: value,
    quoteDecimals: quoteDecimals
  });
  if (decimalPlaces === undefined) {
    return number.toFixed();
  }
  return number.toFixed(getSignificantDecimalsFromNumber(number), roundingMode);
};
/**
 * Amount that the chain requires is in the x * 10^(quoteDecimals) format
 * where x is a human readable number
 */
var derivativePriceToChainPrice = function derivativePriceToChainPrice(_ref9) {
  var value = _ref9.value,
    _ref9$quoteDecimals = _ref9.quoteDecimals,
    quoteDecimals = _ref9$quoteDecimals === void 0 ? 18 : _ref9$quoteDecimals;
  return new $BigNumber(value).multipliedBy(new $BigNumber(10).pow(quoteDecimals));
};
/**
 * Amount that the chain requires is in the x * 10^(quoteDecimals) format
 * where x is a human readable number stringified
 */
var derivativePriceToChainPriceToFixed = function derivativePriceToChainPriceToFixed(_ref10) {
  var value = _ref10.value,
    _ref10$quoteDecimals = _ref10.quoteDecimals,
    quoteDecimals = _ref10$quoteDecimals === void 0 ? 18 : _ref10$quoteDecimals,
    _ref10$decimalPlaces = _ref10.decimalPlaces,
    decimalPlaces = _ref10$decimalPlaces === void 0 ? undefined : _ref10$decimalPlaces,
    _ref10$roundingMode = _ref10.roundingMode,
    roundingMode = _ref10$roundingMode === void 0 ? BigNumber.ROUND_DOWN : _ref10$roundingMode;
  var number = derivativePriceToChainPrice({
    value: value,
    quoteDecimals: quoteDecimals
  });
  if (decimalPlaces === undefined) {
    return number.toFixed();
  }
  return number.toFixed(getSignificantDecimalsFromNumber(number), roundingMode);
};
/**
 * Amount that the chain returns is in the x * 10^(quoteDecimals) format
 * where x is a human readable number
 */
var derivativePriceFromChainPrice = function derivativePriceFromChainPrice(_ref11) {
  var value = _ref11.value,
    _ref11$quoteDecimals = _ref11.quoteDecimals,
    quoteDecimals = _ref11$quoteDecimals === void 0 ? 18 : _ref11$quoteDecimals;
  return new $BigNumber(value).dividedBy(new $BigNumber(10).pow(quoteDecimals));
};
/**
 * Amount that the chain returns is in the x * 10^(quoteDecimals) format
 * where x is a human readable number stringified
 */
var derivativePriceFromChainPriceToFixed = function derivativePriceFromChainPriceToFixed(_ref12) {
  var value = _ref12.value,
    _ref12$quoteDecimals = _ref12.quoteDecimals,
    quoteDecimals = _ref12$quoteDecimals === void 0 ? 18 : _ref12$quoteDecimals,
    _ref12$decimalPlaces = _ref12.decimalPlaces,
    decimalPlaces = _ref12$decimalPlaces === void 0 ? undefined : _ref12$decimalPlaces,
    _ref12$roundingMode = _ref12.roundingMode,
    roundingMode = _ref12$roundingMode === void 0 ? BigNumber.ROUND_DOWN : _ref12$roundingMode;
  var number = derivativePriceFromChainPrice({
    value: value,
    quoteDecimals: quoteDecimals
  });
  if (decimalPlaces === undefined) {
    return number.toFixed();
  }
  return number.toFixed(getSignificantDecimalsFromNumber(number), roundingMode);
};
/**
 * Amount that the chain requires is in the x format
 * where x is a human readable number
 */
var derivativeQuantityToChainQuantity = function derivativeQuantityToChainQuantity(_ref13) {
  var value = _ref13.value;
  return new $BigNumber(value);
};
/**
 * Amount that the chain requires is in the x format
 * where x is a human readable number stringified
 */
var derivativeQuantityToChainQuantityToFixed = function derivativeQuantityToChainQuantityToFixed(_ref14) {
  var value = _ref14.value,
    _ref14$decimalPlaces = _ref14.decimalPlaces,
    decimalPlaces = _ref14$decimalPlaces === void 0 ? undefined : _ref14$decimalPlaces,
    _ref14$roundingMode = _ref14.roundingMode,
    roundingMode = _ref14$roundingMode === void 0 ? BigNumber.ROUND_DOWN : _ref14$roundingMode;
  var number = derivativeQuantityToChainQuantity({
    value: value
  });
  if (decimalPlaces === undefined) {
    return number.toFixed();
  }
  return number.toFixed(getSignificantDecimalsFromNumber(number), roundingMode);
};
/**
 * Amount that the chain requires is in the x format
 * where x is a human readable number
 */
var derivativeQuantityFromChainQuantity = function derivativeQuantityFromChainQuantity(_ref15) {
  var value = _ref15.value;
  return new $BigNumber(value);
};
/**
 * Amount that the chain requires is in the x format
 * where x is a human readable number stringified
 */
var derivativeQuantityFromChainQuantityToFixed = function derivativeQuantityFromChainQuantityToFixed(_ref16) {
  var value = _ref16.value,
    _ref16$decimalPlaces = _ref16.decimalPlaces,
    decimalPlaces = _ref16$decimalPlaces === void 0 ? undefined : _ref16$decimalPlaces,
    _ref16$roundingMode = _ref16.roundingMode,
    roundingMode = _ref16$roundingMode === void 0 ? BigNumber.ROUND_DOWN : _ref16$roundingMode;
  var number = derivativeQuantityFromChainQuantity({
    value: value
  });
  if (decimalPlaces === undefined) {
    return number.toFixed();
  }
  return number.toFixed(getSignificantDecimalsFromNumber(number), roundingMode);
};
/**
 * Amount that the chain requires is in the x / 10^(quoteDecimals - baseDecimals) format
 * where x is a human readable number
 */
var spotPriceToChainPrice = function spotPriceToChainPrice(_ref17) {
  var value = _ref17.value,
    _ref17$baseDecimals = _ref17.baseDecimals,
    baseDecimals = _ref17$baseDecimals === void 0 ? 18 : _ref17$baseDecimals,
    _ref17$quoteDecimals = _ref17.quoteDecimals,
    quoteDecimals = _ref17$quoteDecimals === void 0 ? 6 : _ref17$quoteDecimals;
  return new $BigNumber(value).multipliedBy(new $BigNumber(10).pow(new $BigNumber(quoteDecimals).minus(baseDecimals)));
};
/**
 * Amount that the chain requires is in the x / 10^(quoteDecimals - baseDecimals) format
 * where x is a human readable number stringified
 */
var spotPriceToChainPriceToFixed = function spotPriceToChainPriceToFixed(_ref18) {
  var value = _ref18.value,
    _ref18$baseDecimals = _ref18.baseDecimals,
    baseDecimals = _ref18$baseDecimals === void 0 ? 18 : _ref18$baseDecimals,
    _ref18$quoteDecimals = _ref18.quoteDecimals,
    quoteDecimals = _ref18$quoteDecimals === void 0 ? 6 : _ref18$quoteDecimals,
    _ref18$decimalPlaces = _ref18.decimalPlaces,
    decimalPlaces = _ref18$decimalPlaces === void 0 ? undefined : _ref18$decimalPlaces,
    _ref18$roundingMode = _ref18.roundingMode,
    roundingMode = _ref18$roundingMode === void 0 ? BigNumber.ROUND_DOWN : _ref18$roundingMode;
  var number = spotPriceToChainPrice({
    value: value,
    baseDecimals: baseDecimals,
    quoteDecimals: quoteDecimals
  });
  if (decimalPlaces === undefined) {
    return number.toFixed();
  }
  return number.toFixed(getSignificantDecimalsFromNumber(number), roundingMode);
};
/**
 * Amount that the chain returns is in the x / 10^(quoteDecimals - baseDecimals) format
 * where x is a human readable number
 */
var spotPriceFromChainPrice = function spotPriceFromChainPrice(_ref19) {
  var value = _ref19.value,
    _ref19$baseDecimals = _ref19.baseDecimals,
    baseDecimals = _ref19$baseDecimals === void 0 ? 18 : _ref19$baseDecimals,
    _ref19$quoteDecimals = _ref19.quoteDecimals,
    quoteDecimals = _ref19$quoteDecimals === void 0 ? 6 : _ref19$quoteDecimals;
  return new $BigNumber(value).dividedBy(new $BigNumber(10).pow(new $BigNumber(quoteDecimals).minus(baseDecimals)));
};
/**
 * Amount that the chain returns is in the x / 10^(quoteDecimals - baseDecimals) format
 * where x is a human readable number stringified
 */
var spotPriceFromChainPriceToFixed = function spotPriceFromChainPriceToFixed(_ref20) {
  var value = _ref20.value,
    _ref20$baseDecimals = _ref20.baseDecimals,
    baseDecimals = _ref20$baseDecimals === void 0 ? 18 : _ref20$baseDecimals,
    _ref20$quoteDecimals = _ref20.quoteDecimals,
    quoteDecimals = _ref20$quoteDecimals === void 0 ? 6 : _ref20$quoteDecimals,
    _ref20$decimalPlaces = _ref20.decimalPlaces,
    decimalPlaces = _ref20$decimalPlaces === void 0 ? undefined : _ref20$decimalPlaces,
    _ref20$roundingMode = _ref20.roundingMode,
    roundingMode = _ref20$roundingMode === void 0 ? BigNumber.ROUND_DOWN : _ref20$roundingMode;
  var number = spotPriceFromChainPrice({
    value: value,
    baseDecimals: baseDecimals,
    quoteDecimals: quoteDecimals
  });
  if (decimalPlaces === undefined) {
    return number.toFixed();
  }
  return number.toFixed(getSignificantDecimalsFromNumber(number), roundingMode);
};
/**
 * Amount that the chain requires is in the x * 10^(baseDecimals) format
 * where x is a human readable number
 */
var spotQuantityToChainQuantity = function spotQuantityToChainQuantity(_ref21) {
  var value = _ref21.value,
    _ref21$baseDecimals = _ref21.baseDecimals,
    baseDecimals = _ref21$baseDecimals === void 0 ? 18 : _ref21$baseDecimals;
  return new $BigNumber(value).multipliedBy(new $BigNumber(10).pow(baseDecimals));
};
/**
 * Amount that the chain requires is in the x * 10^(baseDecimals) format
 * where x is a human readable number
 */
var spotQuantityToChainQuantityToFixed = function spotQuantityToChainQuantityToFixed(_ref22) {
  var value = _ref22.value,
    _ref22$baseDecimals = _ref22.baseDecimals,
    baseDecimals = _ref22$baseDecimals === void 0 ? 18 : _ref22$baseDecimals,
    _ref22$decimalPlaces = _ref22.decimalPlaces,
    decimalPlaces = _ref22$decimalPlaces === void 0 ? undefined : _ref22$decimalPlaces,
    _ref22$roundingMode = _ref22.roundingMode,
    roundingMode = _ref22$roundingMode === void 0 ? BigNumber.ROUND_DOWN : _ref22$roundingMode;
  var number = spotQuantityToChainQuantity({
    value: value,
    baseDecimals: baseDecimals
  });
  if (decimalPlaces === undefined) {
    return number.toFixed();
  }
  return number.toFixed(getSignificantDecimalsFromNumber(number), roundingMode);
};
/**
 * Amount that the chain returns is in the x * 10^(baseDecimals) format
 * where x is a human readable number
 */
var spotQuantityFromChainQuantity = function spotQuantityFromChainQuantity(_ref23) {
  var value = _ref23.value,
    _ref23$baseDecimals = _ref23.baseDecimals,
    baseDecimals = _ref23$baseDecimals === void 0 ? 18 : _ref23$baseDecimals;
  return new $BigNumber(value).multipliedBy(new $BigNumber(10).pow(baseDecimals));
};
/**
 * Amount that the chain returns is in the x * 10^(baseDecimals) format
 * where x is a human readable number
 */
var spotQuantityFromChainQuantityToFixed = function spotQuantityFromChainQuantityToFixed(_ref24) {
  var value = _ref24.value,
    _ref24$baseDecimals = _ref24.baseDecimals,
    baseDecimals = _ref24$baseDecimals === void 0 ? 18 : _ref24$baseDecimals,
    _ref24$decimalPlaces = _ref24.decimalPlaces,
    decimalPlaces = _ref24$decimalPlaces === void 0 ? undefined : _ref24$decimalPlaces,
    _ref24$roundingMode = _ref24.roundingMode,
    roundingMode = _ref24$roundingMode === void 0 ? BigNumber.ROUND_DOWN : _ref24$roundingMode;
  var number = spotQuantityFromChainQuantity({
    value: value,
    baseDecimals: baseDecimals
  });
  if (decimalPlaces === undefined) {
    return number.toFixed();
  }
  return number.toFixed(getSignificantDecimalsFromNumber(number), roundingMode);
};
var cosmosSdkDecToBigNumber = function cosmosSdkDecToBigNumber(number) {
  return new BigNumber(number).dividedBy(new BigNumber(10).pow(18));
};
var numberToCosmosSdkDecString = function numberToCosmosSdkDecString(value) {
  return new BigNumber(value).toFixed(18);
};
var getDecimalsFromNumber = function getDecimalsFromNumber(number) {
  var UI_DEFAULT_MAX_DISPLAY_DECIMALS = 4;
  var numberToBn = new BigNumber(number).toNumber();
  var numberParts = numberToBn.toString().split('.');
  var decimals = numberParts[1];
  var actualDecimals = decimals ? decimals.length : 0;
  return actualDecimals > UI_DEFAULT_MAX_DISPLAY_DECIMALS ? UI_DEFAULT_MAX_DISPLAY_DECIMALS : actualDecimals;
};
var getTriggerPrice = function getTriggerPrice(triggerPrice) {
  return triggerPrice ? amountToCosmosSdkDecAmount(triggerPrice).toFixed() : '';
};

var ROUTER_CHAIN_PREFIX = 'router';
var CURRENT_CHAIN_PREFIX = ROUTER_CHAIN_PREFIX;
var getRouterAddress = function getRouterAddress(address) {
  var addressBuffer = Address$1.fromString(address.toString()).toBuffer();
  return bech32.encode(CURRENT_CHAIN_PREFIX, bech32.toWords(addressBuffer));
};
var getAddressFromRouterAddress = function getAddressFromRouterAddress(address) {
  if (address.startsWith('0x')) {
    return address;
  }
  return "0x" + Buffer.from(bech32.fromWords(bech32.decode(address).words)).toString('hex');
};
var isValidAddress = function isValidAddress(address) {
  try {
    var decoded = bech32.decode(address).words;
    return !!decoded;
  } catch (_unused) {
    return false;
  }
};
var validatorToDelegatorAddress = function validatorToDelegatorAddress(address) {
  var decode = bech32.decode(address).words;
  return bech32.encode(CURRENT_CHAIN_PREFIX, decode);
};

function toUtf8(str) {
  return new TextEncoder().encode(str);
}
function fromUtf8(data) {
  return new TextDecoder$1('utf-8').decode(data);
}
function toBase64(data) {
  return Buffer.from(JSON.stringify(data)).toString('base64');
}
function fromBase64(payload) {
  return JSON.parse(Buffer.from(payload, 'base64').toString());
}
function fromBase64ToString(payload) {
  return Buffer.from(payload, 'base64').toString();
}
var encodeStringToBase64 = function encodeStringToBase64(data) {
  if (data.startsWith('0x')) {
    return hexToBase64String(data);
  }
  return Buffer.from(data).toString('base64');
};
var encodeBase64ToString = function encodeBase64ToString(data) {
  return Buffer.from(data, 'base64').toString('ascii');
};
var hexToBase64String = function hexToBase64String(hexString) {
  hexString = hexString.startsWith('0x') ? hexString.slice(2) : hexString;
  return Buffer.from(hexString, 'hex').toString('base64');
};
var base64ToHexString = function base64ToHexString(base64String) {
  return Buffer.from(base64String, 'base64').toString('hex');
};

//import { SHA256 } from 'jscrypto/SHA256';
function sha256hash(hashString) {
  return createHash('sha256').update(hashString).digest('hex');
}
var hashToHex = function hashToHex(data) {
  return sha256hash(Buffer.from(data, 'utf8').toString('base64')).toString().toUpperCase();
};
// export const sha256 = (data: Uint8Array): Uint8Array => {
//   return new Word32Array(sha256hash(new Word32Array(data))).toUint8Array();
// };
// export const ripemd160 = (data: Uint8Array): Uint8Array => {
//   return RIPEMD160.hash(new Word32Array(data)).toUint8Array();
// };
var privateKeyToPublicKey = function privateKeyToPublicKey(privateKey) {
  return publicKeyCreate(privateKey, true);
};
var privateKeyHashToPublicKey = function privateKeyHashToPublicKey(privateKeyHash) {
  var privateKey = privateKeyHash.startsWith('0x') ? privateKeyHash.slice(2) : privateKeyHash;
  return publicKeyCreate(Buffer.from(privateKey, 'hex'), true);
};
var privateKeyToPublicKeyBase64 = function privateKeyToPublicKeyBase64(privateKey) {
  return Buffer.from(privateKeyToPublicKey(privateKey)).toString('base64');
};
var privateKeyHashToPublicKeyBase64 = function privateKeyHashToPublicKeyBase64(privateKeyHash) {
  return Buffer.from(privateKeyHashToPublicKey(privateKeyHash)).toString('base64');
};

var hexToBuff = function hexToBuff(hex) {
  return Buffer.from(hex.startsWith('0x') ? hex.slice(2) : hex, 'hex');
};
var hexToBase64 = function hexToBase64(hex) {
  return Buffer.from(hex.startsWith('0x') ? hex.slice(2) : hex, 'hex').toString('base64');
};

var recoverTypedSignaturePubKey = function recoverTypedSignaturePubKey(data, signature) {
  var compressedPubKeyPrefix = Buffer.from('04', 'hex');
  var message = TypedDataUtils.eip712Hash(data, SignTypedDataVersion.V4);
  var sigParams = fromRpcSig(signature);
  var publicKey = ecrecover(message, sigParams.v, sigParams.r, sigParams.s);
  var prefixedKey = Buffer.concat([compressedPubKeyPrefix, publicKey]);
  var compressedKey = Buffer.from(publicKeyConvert(prefixedKey));
  return "0x" + compressedKey.toString('hex');
};

var getRequestMetadataWithoutAck = function getRequestMetadataWithoutAck(destGasLimit) {
  return ethers.utils.solidityPack(['uint64', 'uint64', 'uint64', 'uint64', 'uint128', 'uint8', 'bool', 'string'], [destGasLimit, 0, 0, 0, 0, 0, false, '']);
};
var getRequestMetadataWithAck = function getRequestMetadataWithAck(destGasLimit, ackType, ackGasLimit) {
  return ethers.utils.solidityPack(['uint64', 'uint64', 'uint64', 'uint64', 'uint128', 'uint8', 'bool', 'string'], [destGasLimit, 0, ackGasLimit, 0, 0, ackType, false, '']);
};
var getRequestMetadata = function getRequestMetadata(destGasLimit, destGasPrice, ackGasLimit, ackGasPrice, relayerFees, ackType, isReadCall, asmAddress) {
  return ethers.utils.solidityPack(['uint64', 'uint64', 'uint64', 'uint64', 'uint128', 'uint8', 'bool', 'string'], [destGasLimit, destGasPrice, ackGasLimit, ackGasPrice, relayerFees, ackType, isReadCall, asmAddress]);
};

var ChainGrpcDistributionTransformer = /*#__PURE__*/function () {
  function ChainGrpcDistributionTransformer() {}
  ChainGrpcDistributionTransformer.moduleParamsResponseToModuleParams = function moduleParamsResponseToModuleParams(response) {
    var params = response.getParams();
    return {
      communityTax: cosmosSdkDecToBigNumber(params.getCommunityTax()).toFixed(),
      baseProposerReward: params.getBaseProposerReward(),
      bonusProposerReward: params.getBonusProposerReward(),
      withdrawAddrEnabled: params.getWithdrawAddrEnabled()
    };
  };
  ChainGrpcDistributionTransformer.delegationRewardResponseToReward = function delegationRewardResponseToReward(response) {
    var grpcRewards = response.getRewardsList();
    return grpcRewards.map(function (grpcReward) {
      return {
        amount: cosmosSdkDecToBigNumber(grpcReward.getAmount()).toFixed(),
        denom: grpcReward.getDenom()
      };
    });
  };
  ChainGrpcDistributionTransformer.totalDelegationRewardResponseToTotalReward = function totalDelegationRewardResponseToTotalReward(response) {
    var grpcRewards = response.getRewardsList();
    return grpcRewards.map(function (grpcReward) {
      var rewards = grpcReward.getRewardList().map(function (reward) {
        return {
          amount: cosmosSdkDecToBigNumber(reward.getAmount()).toFixed(),
          denom: reward.getDenom()
        };
      });
      return {
        rewards: rewards,
        validatorAddress: grpcReward.getValidatorAddress()
      };
    });
  };
  return ChainGrpcDistributionTransformer;
}();

var ChainGrpcGovTransformer = /*#__PURE__*/function () {
  function ChainGrpcGovTransformer() {}
  ChainGrpcGovTransformer.moduleParamsResponseToModuleParams = function moduleParamsResponseToModuleParams(response) {
    var _depositParams$getMax, _votingParams$getVoti;
    var depositParams = response.getDepositParams();
    var votingParams = response.getVotingParams();
    var tallyParams = response.getTallyParams();
    return {
      depositParams: {
        minDepositList: depositParams == null ? void 0 : depositParams.getMinDepositList().map(function (m) {
          return m.toObject();
        }),
        maxDepositPeriod: (depositParams == null ? void 0 : (_depositParams$getMax = depositParams.getMaxDepositPeriod()) == null ? void 0 : _depositParams$getMax.getSeconds()) || 0
      },
      votingParams: {
        votingPeriod: ((_votingParams$getVoti = votingParams.getVotingPeriod()) == null ? void 0 : _votingParams$getVoti.getSeconds()) || 0
      },
      tallyParams: {
        quorum: cosmosSdkDecToBigNumber(uint8ArrayToString(tallyParams.getQuorum())).toFixed(),
        threshold: cosmosSdkDecToBigNumber(uint8ArrayToString(tallyParams.getThreshold())).toFixed(),
        vetoThreshold: cosmosSdkDecToBigNumber(uint8ArrayToString(tallyParams.getVetoThreshold())).toFixed()
      }
    };
  };
  ChainGrpcGovTransformer.moduleParamsResponseToModuleParamsByType = function moduleParamsResponseToModuleParamsByType(_ref) {
    var _depositParams$getMax2, _votingParams$getVoti2;
    var depositParams = _ref.depositParams,
      votingParams = _ref.votingParams,
      tallyParams = _ref.tallyParams;
    return {
      depositParams: {
        minDepositList: depositParams == null ? void 0 : depositParams.getMinDepositList().map(function (m) {
          return m.toObject();
        }),
        maxDepositPeriod: (depositParams == null ? void 0 : (_depositParams$getMax2 = depositParams.getMaxDepositPeriod()) == null ? void 0 : _depositParams$getMax2.getSeconds()) || 0
      },
      votingParams: {
        votingPeriod: ((_votingParams$getVoti2 = votingParams.getVotingPeriod()) == null ? void 0 : _votingParams$getVoti2.getSeconds()) || 0
      },
      tallyParams: {
        quorum: cosmosSdkDecToBigNumber(uint8ArrayToString(tallyParams.getQuorum())).toFixed(),
        threshold: cosmosSdkDecToBigNumber(uint8ArrayToString(tallyParams.getThreshold())).toFixed(),
        vetoThreshold: cosmosSdkDecToBigNumber(uint8ArrayToString(tallyParams.getVetoThreshold())).toFixed()
      }
    };
  };
  ChainGrpcGovTransformer.proposalResponseToProposal = function proposalResponseToProposal(response) {
    var proposal = response.getProposal();
    return ChainGrpcGovTransformer.grpcProposalToProposal(proposal);
  };
  ChainGrpcGovTransformer.proposalsResponseToProposals = function proposalsResponseToProposals(response) {
    var proposals = response.getProposalsList().map(function (p) {
      return ChainGrpcGovTransformer.grpcProposalToProposal(p);
    });
    var pagination = response.getPagination();
    return {
      proposals: proposals,
      pagination: grpcPaginationToPagination(pagination)
    };
  };
  ChainGrpcGovTransformer.depositsResponseToDeposits = function depositsResponseToDeposits(response) {
    var pagination = response.getPagination();
    var deposits = response.getDepositsList().map(function (deposit) {
      return {
        depositor: deposit.getDepositor(),
        amounts: deposit.getAmountList().map(function (coin) {
          return {
            denom: coin.getDenom(),
            amount: cosmosSdkDecToBigNumber(coin.getAmount()).toFixed()
          };
        })
      };
    });
    return {
      deposits: deposits,
      pagination: grpcPaginationToPagination(pagination)
    };
  };
  ChainGrpcGovTransformer.votesResponseToVotes = function votesResponseToVotes(response) {
    var pagination = response.getPagination();
    var votes = response.getVotesList().map(function (v) {
      return {
        proposalId: v.getProposalId(),
        voter: v.getVoter(),
        option: v.getOption()
      };
    });
    return {
      votes: votes,
      pagination: grpcPaginationToPagination(pagination)
    };
  };
  ChainGrpcGovTransformer.tallyResultResponseToTallyResult = function tallyResultResponseToTallyResult(response) {
    var result = response.getTally();
    return ChainGrpcGovTransformer.grpcTallyResultToTallyResult(result);
  };
  ChainGrpcGovTransformer.grpcTallyResultToTallyResult = function grpcTallyResultToTallyResult(result) {
    return {
      yes: result ? result.getYes() : '0',
      abstain: result ? result.getAbstain() : '0',
      no: result ? result.getNo() : '0',
      noWithVeto: result ? result.getNoWithVeto() : '0'
    };
  };
  ChainGrpcGovTransformer.grpcProposalToProposal = function grpcProposalToProposal(proposal) {
    var finalTallyResult = proposal.getFinalTallyResult();
    var content = proposal.getContent();
    return {
      proposalId: proposal.getProposalId(),
      content: {
        type: content.getTypeName(),
        value: content.getValue()
      },
      type: content.getTypeName(),
      submitTime: proposal.getSubmitTime().getSeconds(),
      status: proposal.getStatus(),
      finalTallyResult: ChainGrpcGovTransformer.grpcTallyResultToTallyResult(finalTallyResult),
      depositEndTime: proposal.getDepositEndTime().getSeconds(),
      totalDeposits: proposal.getTotalDepositList().map(function (coin) {
        return {
          denom: coin.getDenom(),
          amount: cosmosSdkDecToBigNumber(coin.getAmount()).toFixed()
        };
      }),
      votingStartTime: proposal.getVotingStartTime().getSeconds(),
      votingEndTime: proposal.getVotingEndTime().getSeconds()
    };
  };
  return ChainGrpcGovTransformer;
}();

var ChainGrpcMintTransformer = /*#__PURE__*/function () {
  function ChainGrpcMintTransformer() {}
  ChainGrpcMintTransformer.moduleParamsResponseToModuleParams = function moduleParamsResponseToModuleParams(response) {
    var params = response.getParams();
    return params.toObject();
  };
  return ChainGrpcMintTransformer;
}();

var BondStatus;
(function (BondStatus) {
  BondStatus["UnBonded"] = "UnBonded";
  BondStatus["UnBonding"] = "UnBonding";
  BondStatus["Bonded"] = "Bonded";
})(BondStatus || (BondStatus = {}));

var ChainGrpcStakingTransformer = /*#__PURE__*/function () {
  function ChainGrpcStakingTransformer() {}
  ChainGrpcStakingTransformer.moduleParamsResponseToModuleParams = function moduleParamsResponseToModuleParams(response) {
    var params = response.getParams();
    return {
      unbondingTime: params.getUnbondingTime().getSeconds(),
      maxValidators: params.getMaxValidators(),
      maxEntries: params.getMaxEntries(),
      minCommissionRate: params.getMinCommissionRate(),
      historicalEntries: params.getHistoricalEntries(),
      bondDenom: params.getBondDenom()
    };
  };
  ChainGrpcStakingTransformer.validatorResponseToValidator = function validatorResponseToValidator(response) {
    return ChainGrpcStakingTransformer.grpcValidatorToValidator(response.getValidator());
  };
  ChainGrpcStakingTransformer.validatorsResponseToValidators = function validatorsResponseToValidators(response) {
    var validators = response.getValidatorsList().map(function (validator) {
      return ChainGrpcStakingTransformer.grpcValidatorToValidator(validator);
    });
    return {
      validators: validators,
      pagination: grpcPaginationToPagination(response.getPagination())
    };
  };
  ChainGrpcStakingTransformer.delegationResponseToDelegation = function delegationResponseToDelegation(response) {
    var grpcDelegation = response.getDelegationResponse();
    var delegation = grpcDelegation.getDelegation();
    var balance = grpcDelegation.getBalance();
    return {
      delegation: {
        delegatorAddress: delegation ? delegation.getDelegatorAddress() : '',
        validatorAddress: delegation ? delegation.getValidatorAddress() : '',
        shares: cosmosSdkDecToBigNumber(delegation ? delegation.getShares() : 0).toFixed()
      },
      balance: {
        denom: balance ? balance.getDenom() : '',
        amount: new BigNumberInWei(balance ? balance.getAmount() : 0).toFixed()
      }
    };
  };
  ChainGrpcStakingTransformer.delegationsResponseToDelegations = function delegationsResponseToDelegations(response) {
    var grpcDelegations = response.getDelegationResponsesList();
    var delegations = grpcDelegations.map(function (grpcDelegator) {
      var delegation = grpcDelegator.getDelegation();
      var balance = grpcDelegator.getBalance();
      return {
        delegation: {
          delegatorAddress: delegation ? delegation.getDelegatorAddress() : '',
          validatorAddress: delegation ? delegation.getValidatorAddress() : '',
          shares: cosmosSdkDecToBigNumber(delegation ? delegation.getShares() : 0).toFixed()
        },
        balance: {
          denom: balance ? balance.getDenom() : '',
          amount: new BigNumberInWei(balance ? balance.getAmount() : 0).toFixed()
        }
      };
    }).filter(function (delegation) {
      return new BigNumberInWei(delegation.balance.amount).toBase().gte(DUST_AMOUNT);
    });
    return {
      delegations: delegations,
      pagination: grpcPaginationToPagination(response.getPagination())
    };
  };
  ChainGrpcStakingTransformer.unBondingDelegationsResponseToUnBondingDelegations = function unBondingDelegationsResponseToUnBondingDelegations(response) {
    var grpcUnbondingDelegations = response.getUnbondingResponsesList();
    var unbondingDelegations = grpcUnbondingDelegations.reduce(function (unbondingDelegations, grpcUnBondingDelegation) {
      var entries = grpcUnBondingDelegation.getEntriesList();
      var mappedEntries = entries.map(function (entry) {
        return {
          delegatorAddress: grpcUnBondingDelegation ? grpcUnBondingDelegation.getDelegatorAddress() : '',
          validatorAddress: grpcUnBondingDelegation ? grpcUnBondingDelegation.getValidatorAddress() : '',
          creationHeight: entry.getCreationHeight(),
          completionTime: entry.getCompletionTime().getSeconds(),
          initialBalance: new BigNumberInWei(entry.getInitialBalance()).toFixed(),
          balance: new BigNumberInWei(entry.getBalance()).toFixed()
        };
      });
      return [].concat(unbondingDelegations, mappedEntries);
    }, []).filter(function (delegation) {
      return new BigNumberInWei(delegation.balance).toBase().gte(DUST_AMOUNT);
    });
    return {
      unbondingDelegations: unbondingDelegations,
      pagination: grpcPaginationToPagination(response.getPagination())
    };
  };
  ChainGrpcStakingTransformer.reDelegationsResponseToReDelegations = function reDelegationsResponseToReDelegations(response) {
    var grpcReDelegations = response.getRedelegationResponsesList();
    var redelegations = grpcReDelegations.reduce(function (uiReDelegator, grpcReDelegation) {
      var grpcRedelegation = grpcReDelegation.getRedelegation();
      var entries = grpcReDelegation.getEntriesList();
      if (!grpcReDelegation) {
        return uiReDelegator;
      }
      var uiRedelegations = entries.reduce(function (acc, redelegation) {
        var entry = redelegation.getRedelegationEntry();
        return [].concat(acc, [{
          delegation: {
            completionTime: entry ? entry.getCompletionTime().getSeconds() : 0,
            delegatorAddress: grpcRedelegation.getDelegatorAddress() || '',
            sourceValidatorAddress: grpcRedelegation.getValidatorSrcAddress() || '',
            destinationValidatorAddress: (grpcRedelegation == null ? void 0 : grpcRedelegation.getValidatorDstAddress()) || ''
          },
          balance: new BigNumberInWei(redelegation.getBalance()).toFixed()
        }]);
      }, []);
      return [].concat(uiReDelegator, uiRedelegations);
    }, []).filter(function (delegation) {
      return new BigNumberInWei(delegation.balance).toBase().gte(DUST_AMOUNT);
    });
    return {
      redelegations: redelegations,
      pagination: grpcPaginationToPagination(response.getPagination())
    };
  };
  ChainGrpcStakingTransformer.grpcValidatorToValidator = function grpcValidatorToValidator(validator) {
    return {
      operatorAddress: validator.getOperatorAddress(),
      jailed: validator.getJailed(),
      status: ChainGrpcStakingTransformer.grpcValidatorStatusToStatus(validator.getStatus()),
      tokens: cosmosSdkDecToBigNumber(validator.getTokens()).toFixed(),
      delegatorShares: cosmosSdkDecToBigNumber(validator.getDelegatorShares()).toFixed(),
      description: ChainGrpcStakingTransformer.grpcValidatorDescriptionToDescription(validator.getDescription()),
      unbondingHeight: validator.getUnbondingHeight(),
      unbondingTime: validator.getUnbondingTime(),
      commission: ChainGrpcStakingTransformer.grpcValidatorCommissionToCommission(validator.getCommission()),
      minSelfDelegation: validator.getMinSelfDelegation()
    };
  };
  ChainGrpcStakingTransformer.poolResponseToPool = function poolResponseToPool(response) {
    var pool = response.getPool();
    if (!pool) {
      return {
        notBondedTokens: '0',
        bondedTokens: '0'
      };
    }
    return {
      notBondedTokens: cosmosSdkDecToBigNumber(pool.getNotBondedTokens()).toFixed(),
      bondedTokens: cosmosSdkDecToBigNumber(pool.getBondedTokens()).toFixed()
    };
  };
  ChainGrpcStakingTransformer.grpcValidatorDescriptionToDescription = function grpcValidatorDescriptionToDescription(description) {
    return {
      moniker: description ? description.getMoniker() : '',
      identity: description ? description.getIdentity() : '',
      website: description ? description.getWebsite() : '',
      securityContact: description ? description.getSecurityContact() : '',
      details: description ? description.getDetails() : ''
    };
  };
  ChainGrpcStakingTransformer.grpcValidatorCommissionToCommission = function grpcValidatorCommissionToCommission(commission) {
    var commissionRates = commission ? commission.getCommissionRates() : null;
    return {
      commissionRates: {
        rate: cosmosSdkDecToBigNumber(commissionRates ? commissionRates.getRate() : '0').toFixed(),
        maxRate: cosmosSdkDecToBigNumber(commissionRates ? commissionRates.getMaxRate() : '0').toFixed(),
        maxChangeRate: cosmosSdkDecToBigNumber(commissionRates ? commissionRates.getMaxChangeRate() : '0').toFixed()
      },
      updateTime: commission ? new Date(commission.getUpdateTime().getSeconds()) : new Date()
    };
  };
  ChainGrpcStakingTransformer.grpcValidatorStatusToStatus = function grpcValidatorStatusToStatus(status) {
    switch (status) {
      case 1:
        return BondStatus.UnBonded;
      case 2:
        return BondStatus.UnBonding;
      case 3:
        return BondStatus.Bonded;
      default:
        return BondStatus.UnBonded;
    }
  };
  return ChainGrpcStakingTransformer;
}();

var ChainGrpcWasmTransformer = /*#__PURE__*/function () {
  function ChainGrpcWasmTransformer() {}
  ChainGrpcWasmTransformer.allContractStateResponseToContractAccountsBalanceWithPagination = function allContractStateResponseToContractAccountsBalanceWithPagination(response) {
    var contractAccountsBalance = response.getModelsList().map(function (model) {
      return {
        account: Buffer.from(model.getKey_asB64(), 'base64').toString('utf-8').split('balance').pop(),
        balance: Buffer.from(model.getValue_asB64(), 'base64').toString('utf-8').replace(/['"]+/g, '')
      };
    }).filter(function (_ref) {
      var account = _ref.account;
      return account && account.startsWith('inj');
    });
    return {
      contractAccountsBalance: contractAccountsBalance,
      pagination: grpcPaginationToPagination(response.getPagination())
    };
  };
  ChainGrpcWasmTransformer.contactInfoResponseToContractInfo = function contactInfoResponseToContractInfo(contractInfo) {
    var absoluteTxPosition = contractInfo.getCreated();
    return {
      codeId: contractInfo.getCodeId(),
      creator: contractInfo.getCreator(),
      admin: contractInfo.getAdmin(),
      label: contractInfo.getLabel(),
      created: {
        blockHeight: absoluteTxPosition ? absoluteTxPosition.getBlockHeight() : 0,
        txIndex: absoluteTxPosition ? absoluteTxPosition.getTxIndex() : 0
      },
      ibcPortId: contractInfo.getIbcPortId()
    };
  };
  ChainGrpcWasmTransformer.grpcContractCodeHistoryEntryToContractCodeHistoryEntry = function grpcContractCodeHistoryEntryToContractCodeHistoryEntry(entry) {
    var updated = entry.getUpdated();
    return {
      operation: entry.getOperation(),
      codeId: entry.getCodeId(),
      updated: updated ? {
        blockHeight: updated.getBlockHeight(),
        txIndex: updated.getTxIndex()
      } : undefined,
      msg: fromUtf8(entry.getMsg_asU8())
    };
  };
  ChainGrpcWasmTransformer.grpcCodeInfoResponseToCodeInfoResponse = function grpcCodeInfoResponseToCodeInfoResponse(info) {
    return {
      codeId: info.getCodeId(),
      creator: info.getCreator(),
      dataHash: info.getDataHash()
    };
  };
  ChainGrpcWasmTransformer.contactHistoryResponseToContractHistory = function contactHistoryResponseToContractHistory(response) {
    return {
      entriesList: response.getEntriesList().map(ChainGrpcWasmTransformer.grpcContractCodeHistoryEntryToContractCodeHistoryEntry),
      pagination: grpcPaginationToPagination(response.getPagination())
    };
  };
  ChainGrpcWasmTransformer.contractCodesResponseToContractCodes = function contractCodesResponseToContractCodes(response) {
    return {
      codeInfosList: response.getCodeInfosList().map(ChainGrpcWasmTransformer.grpcCodeInfoResponseToCodeInfoResponse),
      pagination: grpcPaginationToPagination(response.getPagination())
    };
  };
  ChainGrpcWasmTransformer.contractCodeResponseToContractCode = function contractCodeResponseToContractCode(response) {
    return {
      codeInfo: ChainGrpcWasmTransformer.grpcCodeInfoResponseToCodeInfoResponse(response.getCodeInfo()),
      data: response.getData()
    };
  };
  ChainGrpcWasmTransformer.contractByCodeResponseToContractByCode = function contractByCodeResponseToContractByCode(response) {
    return {
      contractsList: response.getContractsList(),
      pagination: grpcPaginationToPagination(response.getPagination())
    };
  };
  return ChainGrpcWasmTransformer;
}();

var ChainGrpcAttestationTransformer = /*#__PURE__*/function () {
  function ChainGrpcAttestationTransformer() {}
  ChainGrpcAttestationTransformer.latestValsetNonce = function latestValsetNonce(response) {
    return {
      valsetnonce: response.getValsetnonce()
    };
  };
  ChainGrpcAttestationTransformer.allValset = function allValset(response) {
    var valsetList = response.getValsetList();
    var valsetObjectList = valsetList.map(ChainGrpcAttestationTransformer.getValsetObject);
    var page = response.getPagination();
    return {
      valsetList: valsetObjectList,
      pagination: grpcPaginationToPagination(page)
    };
  };
  ChainGrpcAttestationTransformer.valsetByNonce = function valsetByNonce(response) {
    var valset = response.getValset();
    if (valset == undefined) {
      return {
        valset: undefined
      };
    }
    return {
      valset: ChainGrpcAttestationTransformer.getValsetObject(valset)
    };
  };
  ChainGrpcAttestationTransformer.latestValset = function latestValset(response) {
    var valset = response.getValset();
    if (valset == undefined) {
      return {
        valset: undefined
      };
    }
    return {
      valset: ChainGrpcAttestationTransformer.getValsetObject(valset)
    };
  };
  ChainGrpcAttestationTransformer.lastEventByValidator = function lastEventByValidator(response) {
    return {
      eventNonce: response.getEventnonce()
    };
  };
  ChainGrpcAttestationTransformer.listOrchestrators = function listOrchestrators(response) {
    var orchestratorSet = response.getOrchestratorSetList();
    return {
      orchestrator_set: orchestratorSet.map(ChainGrpcAttestationTransformer.getOrchestratorObject)
    };
  };
  ChainGrpcAttestationTransformer.getOrchestratorObject = function getOrchestratorObject(orchestrator) {
    return {
      validator: orchestrator.getValidator(),
      orchestrator: orchestrator.getOrchestrator(),
      ethaddress: orchestrator.getOrchestrator()
    };
  };
  ChainGrpcAttestationTransformer.getValsetObject = function getValsetObject(valset) {
    var members = valset.getMembersList();
    var memberObjects = members.map(ChainGrpcAttestationTransformer.getMemberObject);
    return {
      nonce: valset.getNonce(),
      membersList: memberObjects,
      height: valset.getHeight()
    };
  };
  ChainGrpcAttestationTransformer.getMemberObject = function getMemberObject(member) {
    return {
      power: member.getPower(),
      ethereumaddress: member.getEthereumaddress()
    };
  };
  return ChainGrpcAttestationTransformer;
}();

var ChainGrpcMultiChainTransformer = /*#__PURE__*/function () {
  function ChainGrpcMultiChainTransformer() {}
  ChainGrpcMultiChainTransformer.chainConfig = function chainConfig(response) {
    var chainConfig = response.getChainconfig();
    if (chainConfig == undefined) {
      return {
        chainconfig: undefined
      };
    }
    return {
      chainconfig: ChainGrpcMultiChainTransformer.getChainConfigObject(chainConfig)
    };
  };
  ChainGrpcMultiChainTransformer.allChainConfig = function allChainConfig(response) {
    var chainConfigList = response.getChainconfigList();
    var page = response.getPagination();
    return {
      chainconfigList: chainConfigList.map(ChainGrpcMultiChainTransformer.getChainConfigObject),
      pagination: grpcPaginationToPagination(page)
    };
  };
  ChainGrpcMultiChainTransformer.getChainConfigObject = function getChainConfigObject(chainConfig) {
    return chainConfig.toObject();
  };
  return ChainGrpcMultiChainTransformer;
}();

var ChainGrpcCrosschainTransformer = /*#__PURE__*/function () {
  function ChainGrpcCrosschainTransformer() {}
  ChainGrpcCrosschainTransformer.crosschainRequests = function crosschainRequests(response) {
    var pagination = response.getPagination();
    return {
      crosschainrequestList: response.getCrosschainrequestList().map(ChainGrpcCrosschainTransformer.crosschainRequestObj),
      pagination: pagination != null ? ChainGrpcCrosschainTransformer.paginationObject(pagination) : undefined
    };
  };
  ChainGrpcCrosschainTransformer.crosschainRequestConfirmations = function crosschainRequestConfirmations(response) {
    var pagination = response.getPagination();
    return {
      crosschainrequestconfirmList: response.getCrosschainrequestconfirmList().map(ChainGrpcCrosschainTransformer.crosschainRequestConfirmObj),
      pagination: pagination != null ? ChainGrpcCrosschainTransformer.paginationObject(pagination) : undefined
    };
  };
  ChainGrpcCrosschainTransformer.crosschainAckRequests = function crosschainAckRequests(response) {
    var pagination = response.getPagination();
    return {
      crosschainackrequestList: response.getCrosschainackrequestList().map(ChainGrpcCrosschainTransformer.crosschainAckRequestObj),
      pagination: pagination != null ? ChainGrpcCrosschainTransformer.paginationObject(pagination) : undefined
    };
  };
  ChainGrpcCrosschainTransformer.crosschainAckRequestConfirmations = function crosschainAckRequestConfirmations(response) {
    var pagination = response.getPagination();
    return {
      crosschainackrequestconfirmList: response.getCrosschainackrequestconfirmList().map(ChainGrpcCrosschainTransformer.crosschainAckRequestConfirmObj),
      pagination: pagination != null ? ChainGrpcCrosschainTransformer.paginationObject(pagination) : undefined
    };
  };
  ChainGrpcCrosschainTransformer.crosschainRequestConfirmation = function crosschainRequestConfirmation(request) {
    var crosschainrequestconfirm = request.getCrosschainrequestconfirm();
    return {
      crosschainrequestconfirm: crosschainrequestconfirm != null ? ChainGrpcCrosschainTransformer.crosschainRequestConfirmObj(crosschainrequestconfirm) : undefined
    };
  };
  ChainGrpcCrosschainTransformer.crosschainAckRequestConfirmation = function crosschainAckRequestConfirmation(request) {
    var crosschainAckRequestConfirm = request.getCrosschainackrequestconfirm();
    return {
      crosschainackrequestconfirm: crosschainAckRequestConfirm != null ? {
        orchestrator: crosschainAckRequestConfirm.getOrchestrator(),
        acksrcchainid: crosschainAckRequestConfirm.getAcksrcchainid(),
        ackrequestidentifier: crosschainAckRequestConfirm.getAckrequestidentifier(),
        claimhash: crosschainAckRequestConfirm.getClaimhash(),
        ethsigner: crosschainAckRequestConfirm.getEthsigner(),
        signature: crosschainAckRequestConfirm.getSignature()
      } : undefined
    };
  };
  ChainGrpcCrosschainTransformer.crosschainRequestObj = function crosschainRequestObj(request) {
    return {
      srcChainId: request.getSrcChainId(),
      requestIdentifier: request.getRequestIdentifier(),
      blockHeight: request.getBlockHeight(),
      contract: request.getContract(),
      sourceTxHash: request.getSourceTxHash(),
      srcTimestamp: request.getSrcTimestamp(),
      srcTxOrigin: request.getSrcTxOrigin(),
      routeAmount: request.getRouteAmount(),
      routeRecipient: request.getRouteRecipient(),
      destChainId: request.getDestChainId(),
      destGasLimit: request.getDestGasLimit(),
      destGasPrice: request.getDestGasPrice(),
      relayerIncentive: ChainGrpcCrosschainTransformer.coinObject(request.getRelayerIncentive()),
      requestSender: request.getRequestSender(),
      requestMetadata: request.getRequestMetadata(),
      requestPacket: request.getRequestPacket(),
      srcChainType: request.getSrcChainType(),
      destChainType: request.getDestChainType(),
      destTxFeeDeducted: ChainGrpcCrosschainTransformer.coinObject(request.getDestTxFeeDeducted()),
      status: request.getStatus()
    };
  };
  ChainGrpcCrosschainTransformer.crosschainRequestConfirmObj = function crosschainRequestConfirmObj(request) {
    return {
      orchestrator: request.getOrchestrator(),
      sourcechainid: request.getSourcechainid(),
      requestidentifier: request.getRequestidentifier(),
      claimhash: request.getClaimhash(),
      ethsigner: request.getEthsigner(),
      signature: request.getSignature()
    };
  };
  ChainGrpcCrosschainTransformer.crosschainAckRequestObj = function crosschainAckRequestObj(request) {
    return {
      ackSrcChainId: request.getAckSrcChainId(),
      ackRequestIdentifier: request.getAckRequestIdentifier(),
      blockheight: request.getBlockheight(),
      contract: request.getContract(),
      desttxhash: request.getDesttxhash(),
      relayerrouteraddress: request.getRelayerrouteraddress(),
      ackDestChainId: request.getAckDestChainId(),
      requestSender: request.getRequestSender(),
      requestidentifier: request.getRequestidentifier(),
      ackSrcChainType: request.getAckSrcChainType(),
      ackDestChainType: request.getAckDestChainType(),
      feeconsumed: request.getFeeconsumed(),
      execdata: request.getExecdata(),
      execstatus: request.getExecstatus(),
      ethsigner: request.getEthsigner(),
      signature: request.getSignature(),
      ackGasLimit: request.getAckGasLimit(),
      ackGasPrice: request.getAckGasPrice(),
      ackFeeDeducted: ChainGrpcCrosschainTransformer.coinObject(request.getAckFeeDeducted()),
      ackRelayerIncentive: ChainGrpcCrosschainTransformer.coinObject(request.getAckRelayerIncentive()),
      status: request.getStatus()
    };
  };
  ChainGrpcCrosschainTransformer.crosschainAckRequestConfirmObj = function crosschainAckRequestConfirmObj(request) {
    return {
      orchestrator: request.getOrchestrator(),
      acksrcchainid: request.getAcksrcchainid(),
      ackrequestidentifier: request.getAckrequestidentifier(),
      claimhash: request.getClaimhash(),
      ethsigner: request.getEthsigner(),
      signature: request.getSignature()
    };
  };
  ChainGrpcCrosschainTransformer.paginationObject = function paginationObject(pageResponse) {
    return {
      nextKey: pageResponse.getNextKey(),
      total: pageResponse.getTotal()
    };
  };
  ChainGrpcCrosschainTransformer.coinObject = function coinObject(coin) {
    if (coin == null) {
      return undefined;
    }
    return {
      denom: coin.getDenom(),
      amount: coin.getAmount()
    };
  };
  return ChainGrpcCrosschainTransformer;
}();

var ChainGrpcMetastoreTransformer = /*#__PURE__*/function () {
  function ChainGrpcMetastoreTransformer() {}
  ChainGrpcMetastoreTransformer.allMetastoreInfo = function allMetastoreInfo(response) {
    var pagination = response.getPagination();
    return {
      metainfoList: response.getMetainfoList().map(ChainGrpcMetastoreTransformer.metaInfoObject),
      pagination: pagination != null ? ChainGrpcMetastoreTransformer.paginationObject(pagination) : undefined
    };
  };
  ChainGrpcMetastoreTransformer.metastoreInfo = function metastoreInfo(response) {
    var metaInfo = response.getMetainfo();
    return {
      metainfo: metaInfo != null ? ChainGrpcMetastoreTransformer.metaInfoObject(metaInfo) : undefined
    };
  };
  ChainGrpcMetastoreTransformer.metaInfoObject = function metaInfoObject(metaInfo) {
    return {
      chainid: metaInfo.getChainid(),
      dappaddress: metaInfo.getDappaddress(),
      feepayer: metaInfo.getFeepayer(),
      feepayerapproved: metaInfo.getFeepayerapproved()
    };
  };
  ChainGrpcMetastoreTransformer.paginationObject = function paginationObject(pageResponse) {
    return {
      nextKey: pageResponse.getNextKey(),
      total: pageResponse.getTotal()
    };
  };
  return ChainGrpcMetastoreTransformer;
}();

/**
 * The bank module is responsible for handling multi-asset coin transfers between accounts.
 *
 * @group gRPC API
 *
 * @example
 * To use Bank methods, initialise a {@link ChainGrpcBankApi} object to with a gRPC endpoint. An endpoint can be retrieved by using {@link networkEndpoints}.
 * ```ts
 * const endpoint =  getEndpointsForNetwork(Network.Devnet).grpcEndpoint;
 * const bankClient = new ChainGrpcBankApi(endpoint);
 * const response = await bankClient.fetchBalances("router12avkt8c0lk76atge8f3pe2t6fj4jsc8038d742");
 * ```
 */
var ChainGrpcBankApi = /*#__PURE__*/function (_BaseConsumer) {
  _inheritsLoose(ChainGrpcBankApi, _BaseConsumer);
  function ChainGrpcBankApi() {
    return _BaseConsumer.apply(this, arguments) || this;
  }
  var _proto = ChainGrpcBankApi.prototype;
  _proto.fetchModuleParams = /*#__PURE__*/function () {
    var _fetchModuleParams = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            request = new QueryParamsRequest();
            _context.prev = 1;
            _context.next = 4;
            return this.request(request, Query.Params);
          case 4:
            response = _context.sent;
            return _context.abrupt("return", ChainGrpcBankTransformer.moduleParamsResponseToModuleParams(response));
          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](1);
            throw new Error(_context.t0.message);
          case 11:
          case "end":
            return _context.stop();
        }
      }, _callee, this, [[1, 8]]);
    }));
    function fetchModuleParams() {
      return _fetchModuleParams.apply(this, arguments);
    }
    return fetchModuleParams;
  }()
  /**
   * Get balance of a coin.
   *
   * @param accountAddress account address.
   * @param denom coin denomination.
   * @returns balance.
   */
  ;
  _proto.fetchBalance =
  /*#__PURE__*/
  function () {
    var _fetchBalance = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref) {
      var accountAddress, denom, request, response;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            accountAddress = _ref.accountAddress, denom = _ref.denom;
            request = new QueryBalanceRequest();
            request.setAddress(accountAddress);
            request.setDenom(denom);
            _context2.prev = 4;
            _context2.next = 7;
            return this.request(request, Query.Balance);
          case 7:
            response = _context2.sent;
            return _context2.abrupt("return", ChainGrpcBankTransformer.balanceResponseToBalance(response));
          case 11:
            _context2.prev = 11;
            _context2.t0 = _context2["catch"](4);
            throw new Error(_context2.t0.message);
          case 14:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[4, 11]]);
    }));
    function fetchBalance(_x) {
      return _fetchBalance.apply(this, arguments);
    }
    return fetchBalance;
  }()
  /**
   * Get balance of all coins
   *
   * @param address account address.
   * @returns list of balances.
   */
  ;
  _proto.fetchBalances =
  /*#__PURE__*/
  function () {
    var _fetchBalances = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(address) {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            request = new QueryAllBalancesRequest();
            request.setAddress(address);
            _context3.prev = 2;
            _context3.next = 5;
            return this.request(request, Query.AllBalances);
          case 5:
            response = _context3.sent;
            return _context3.abrupt("return", ChainGrpcBankTransformer.balancesResponseToBalances(response));
          case 9:
            _context3.prev = 9;
            _context3.t0 = _context3["catch"](2);
            throw new Error(_context3.t0.message);
          case 12:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this, [[2, 9]]);
    }));
    function fetchBalances(_x2) {
      return _fetchBalances.apply(this, arguments);
    }
    return fetchBalances;
  }()
  /**
   * Get total supply of coins.
   *
   * @param pagination pagination options (optional param).
   * @returns total supply.
   */
  ;
  _proto.fetchTotalSupply =
  /*#__PURE__*/
  function () {
    var _fetchTotalSupply = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(pagination) {
      var request, paginationForRequest, response;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            request = new QueryTotalSupplyRequest();
            paginationForRequest = paginationRequestFromPagination(pagination);
            if (paginationForRequest) {
              request.setPagination(paginationForRequest);
            }
            _context4.prev = 3;
            _context4.next = 6;
            return this.request(request, Query.TotalSupply);
          case 6:
            response = _context4.sent;
            return _context4.abrupt("return", ChainGrpcBankTransformer.totalSupplyResponseToTotalSupply(response));
          case 10:
            _context4.prev = 10;
            _context4.t0 = _context4["catch"](3);
            throw new Error(_context4.t0.message);
          case 13:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this, [[3, 10]]);
    }));
    function fetchTotalSupply(_x3) {
      return _fetchTotalSupply.apply(this, arguments);
    }
    return fetchTotalSupply;
  }();
  return ChainGrpcBankApi;
}(BaseGrpcConsumer);

var ChainGrpcAuthTransformer = /*#__PURE__*/function () {
  function ChainGrpcAuthTransformer() {}
  ChainGrpcAuthTransformer.moduleParamsResponseToModuleParams = function moduleParamsResponseToModuleParams(response) {
    var params = response.getParams();
    return {
      maxMemoCharacters: params.getMaxMemoCharacters(),
      txSigLimit: params.getTxSigLimit(),
      txSizeCostPerByte: params.getTxSizeCostPerByte(),
      sigVerifyCostEd25519: params.getSigVerifyCostEd25519(),
      sigVerifyCostSecp256k1: params.getSigVerifyCostSecp256k1()
    };
  };
  ChainGrpcAuthTransformer.grpcAccountToAccount = function grpcAccountToAccount(ethAccount) {
    var account = EthAccount.deserializeBinary(ethAccount.getValue());
    var baseAccount = account.getBaseAccount();
    var pubKey = baseAccount.getPubKey();
    return {
      codeHash: uint8ArrayToString(account.getCodeHash()),
      baseAccount: {
        address: baseAccount.getAddress(),
        pubKey: pubKey ? {
          key: uint8ArrayToString(pubKey.getValue()),
          typeUrl: pubKey.getTypeUrl()
        } : undefined,
        accountNumber: baseAccount.getAccountNumber(),
        sequence: baseAccount.getSequence()
      }
    };
  };
  ChainGrpcAuthTransformer.accountResponseToAccount = function accountResponseToAccount(response) {
    return ChainGrpcAuthTransformer.grpcAccountToAccount(response.getAccount());
  };
  ChainGrpcAuthTransformer.accountsResponseToAccounts = function accountsResponseToAccounts(response) {
    return {
      pagination: grpcPaginationToPagination(response.getPagination()),
      accounts: response.getAccountsList().map(ChainGrpcAuthTransformer.grpcAccountToAccount)
    };
  };
  return ChainGrpcAuthTransformer;
}();

/**
 * @group gRPC API
 */
var ChainGrpcAuthApi = /*#__PURE__*/function (_BaseConsumer) {
  _inheritsLoose(ChainGrpcAuthApi, _BaseConsumer);
  function ChainGrpcAuthApi() {
    return _BaseConsumer.apply(this, arguments) || this;
  }
  var _proto = ChainGrpcAuthApi.prototype;
  _proto.fetchModuleParams = /*#__PURE__*/function () {
    var _fetchModuleParams = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            request = new QueryParamsRequest$1();
            _context.prev = 1;
            _context.next = 4;
            return this.request(request, Query$1.Params);
          case 4:
            response = _context.sent;
            return _context.abrupt("return", ChainGrpcAuthTransformer.moduleParamsResponseToModuleParams(response));
          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](1);
            throw new Error(_context.t0.message);
          case 11:
          case "end":
            return _context.stop();
        }
      }, _callee, this, [[1, 8]]);
    }));
    function fetchModuleParams() {
      return _fetchModuleParams.apply(this, arguments);
    }
    return fetchModuleParams;
  }()
  /**
   * Get account details.
   * @param address account address.
   * @returns account.
   */
  ;
  _proto.fetchAccount =
  /*#__PURE__*/
  function () {
    var _fetchAccount = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(address) {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            request = new QueryAccountRequest();
            request.setAddress(address);
            _context2.prev = 2;
            _context2.next = 5;
            return this.request(request, Query$1.Account);
          case 5:
            response = _context2.sent;
            return _context2.abrupt("return", ChainGrpcAuthTransformer.accountResponseToAccount(response));
          case 9:
            _context2.prev = 9;
            _context2.t0 = _context2["catch"](2);
            throw new Error(_context2.t0.message);
          case 12:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[2, 9]]);
    }));
    function fetchAccount(_x) {
      return _fetchAccount.apply(this, arguments);
    }
    return fetchAccount;
  }()
  /**
   * Get all accounts.
   * @param pagination
   * @returns accounts.
   */
  ;
  _proto.fetchAccounts =
  /*#__PURE__*/
  function () {
    var _fetchAccounts = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(pagination) {
      var request, paginationForRequest, response;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            request = new QueryAccountsRequest();
            paginationForRequest = paginationRequestFromPagination(pagination);
            if (paginationForRequest) {
              request.setPagination(paginationForRequest);
            }
            _context3.prev = 3;
            _context3.next = 6;
            return this.request(request, Query$1.Accounts);
          case 6:
            response = _context3.sent;
            return _context3.abrupt("return", ChainGrpcAuthTransformer.accountsResponseToAccounts(response));
          case 10:
            _context3.prev = 10;
            _context3.t0 = _context3["catch"](3);
            throw new Error(_context3.t0.message);
          case 13:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this, [[3, 10]]);
    }));
    function fetchAccounts(_x2) {
      return _fetchAccounts.apply(this, arguments);
    }
    return fetchAccounts;
  }();
  return ChainGrpcAuthApi;
}(BaseGrpcConsumer);

/**
 * @group gRPC API
 */
var ChainGrpcDistributionApi = /*#__PURE__*/function (_BaseConsumer) {
  _inheritsLoose(ChainGrpcDistributionApi, _BaseConsumer);
  function ChainGrpcDistributionApi() {
    return _BaseConsumer.apply(this, arguments) || this;
  }
  var _proto = ChainGrpcDistributionApi.prototype;
  _proto.fetchModuleParams = /*#__PURE__*/function () {
    var _fetchModuleParams = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            request = new QueryParamsRequest$2();
            _context.prev = 1;
            _context.next = 4;
            return this.request(request, Query$2.Params);
          case 4:
            response = _context.sent;
            return _context.abrupt("return", ChainGrpcDistributionTransformer.moduleParamsResponseToModuleParams(response));
          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](1);
            throw new Error(_context.t0.message);
          case 11:
          case "end":
            return _context.stop();
        }
      }, _callee, this, [[1, 8]]);
    }));
    function fetchModuleParams() {
      return _fetchModuleParams.apply(this, arguments);
    }
    return fetchModuleParams;
  }()
  /**
   * Get delegatore rewards for staking in a particular validators pool.
   *
   * @param delegatorAddress account address.
   * @param validatorAddress coin denomination.
   * @returns delegator rewards.
   */
  ;
  _proto.fetchDelegatorRewardsForValidator =
  /*#__PURE__*/
  function () {
    var _fetchDelegatorRewardsForValidator = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref) {
      var delegatorAddress, validatorAddress, request, response;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            delegatorAddress = _ref.delegatorAddress, validatorAddress = _ref.validatorAddress;
            request = new QueryDelegationRewardsRequest();
            request.setValidatorAddress(validatorAddress);
            request.setDelegatorAddress(delegatorAddress);
            _context2.prev = 4;
            _context2.next = 7;
            return this.request(request, Query$2.DelegationRewards);
          case 7:
            response = _context2.sent;
            return _context2.abrupt("return", ChainGrpcDistributionTransformer.delegationRewardResponseToReward(response));
          case 11:
            _context2.prev = 11;
            _context2.t0 = _context2["catch"](4);
            throw new Error(_context2.t0.message);
          case 14:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[4, 11]]);
    }));
    function fetchDelegatorRewardsForValidator(_x) {
      return _fetchDelegatorRewardsForValidator.apply(this, arguments);
    }
    return fetchDelegatorRewardsForValidator;
  }()
  /**
   * Get delegatore rewards for staking in a particular validators pool.
   *
   * @param delegatorAddress account address.
   * @param validatorAddress coin denomination.
   * @returns delegator rewards.
   */
  ;
  _proto.fetchDelegatorRewardsForValidatorNoThrow =
  /*#__PURE__*/
  function () {
    var _fetchDelegatorRewardsForValidatorNoThrow = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref2) {
      var delegatorAddress, validatorAddress, request, response;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            delegatorAddress = _ref2.delegatorAddress, validatorAddress = _ref2.validatorAddress;
            request = new QueryDelegationRewardsRequest();
            request.setValidatorAddress(validatorAddress);
            request.setDelegatorAddress(delegatorAddress);
            _context3.prev = 4;
            _context3.next = 7;
            return this.request(request, Query$2.DelegationRewards);
          case 7:
            response = _context3.sent;
            return _context3.abrupt("return", ChainGrpcDistributionTransformer.delegationRewardResponseToReward(response));
          case 11:
            _context3.prev = 11;
            _context3.t0 = _context3["catch"](4);
            if (!_context3.t0.message.includes('does not exist')) {
              _context3.next = 15;
              break;
            }
            return _context3.abrupt("return", []);
          case 15:
            throw new Error(_context3.t0.message);
          case 16:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this, [[4, 11]]);
    }));
    function fetchDelegatorRewardsForValidatorNoThrow(_x2) {
      return _fetchDelegatorRewardsForValidatorNoThrow.apply(this, arguments);
    }
    return fetchDelegatorRewardsForValidatorNoThrow;
  }()
  /**
   * Get total staking rewards for an account address.
   *
   * @param routerAddress account address.
   * @returns accounts rewards.
   */
  ;
  _proto.fetchDelegatorRewards =
  /*#__PURE__*/
  function () {
    var _fetchDelegatorRewards = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(routerAddress) {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            request = new QueryDelegationTotalRewardsRequest();
            request.setDelegatorAddress(routerAddress);
            _context4.prev = 2;
            _context4.next = 5;
            return this.request(request, Query$2.DelegationTotalRewards);
          case 5:
            response = _context4.sent;
            return _context4.abrupt("return", ChainGrpcDistributionTransformer.totalDelegationRewardResponseToTotalReward(response));
          case 9:
            _context4.prev = 9;
            _context4.t0 = _context4["catch"](2);
            throw new Error(_context4.t0.message);
          case 12:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this, [[2, 9]]);
    }));
    function fetchDelegatorRewards(_x3) {
      return _fetchDelegatorRewards.apply(this, arguments);
    }
    return fetchDelegatorRewards;
  }()
  /**
   * Get total staking rewards for an account address.
   *
   * @param routerAddress account address.
   * @returns accounts rewards.
   */
  ;
  _proto.fetchDelegatorRewardsNoThrow =
  /*#__PURE__*/
  function () {
    var _fetchDelegatorRewardsNoThrow = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(routerAddress) {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            request = new QueryDelegationTotalRewardsRequest();
            request.setDelegatorAddress(routerAddress);
            _context5.prev = 2;
            _context5.next = 5;
            return this.request(request, Query$2.DelegationTotalRewards);
          case 5:
            response = _context5.sent;
            return _context5.abrupt("return", ChainGrpcDistributionTransformer.totalDelegationRewardResponseToTotalReward(response));
          case 9:
            _context5.prev = 9;
            _context5.t0 = _context5["catch"](2);
            if (!_context5.t0.message.includes('does not exist')) {
              _context5.next = 13;
              break;
            }
            return _context5.abrupt("return", []);
          case 13:
            throw new Error(_context5.t0.message);
          case 14:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this, [[2, 9]]);
    }));
    function fetchDelegatorRewardsNoThrow(_x4) {
      return _fetchDelegatorRewardsNoThrow.apply(this, arguments);
    }
    return fetchDelegatorRewardsNoThrow;
  }();
  return ChainGrpcDistributionApi;
}(BaseGrpcConsumer);

/**
 * The Gov module is responsible for handling Governance. Fetch information like proposals, votes and tally.
 *
 * @group gRPC API
 *
 * @example
 * To use Gov methods, initialise a {@link ChainGrpcGovApi} object to with a gRPC endpoint. An endpoint can be retrieved by using {@link networkEndpoints}.
 * ```ts
 * const endpoint =  getEndpointsForNetwork(Network.Devnet).grpcEndpoint;
 * const client = new ChainGrpcGovApi(endpoint);
 * const response = await client.fetchProposal(1);
 * ```
 */
var ChainGrpcGovApi = /*#__PURE__*/function (_BaseConsumer) {
  _inheritsLoose(ChainGrpcGovApi, _BaseConsumer);
  function ChainGrpcGovApi() {
    return _BaseConsumer.apply(this, arguments) || this;
  }
  var _proto = ChainGrpcGovApi.prototype;
  _proto.fetchModuleParams = /*#__PURE__*/function () {
    var _fetchModuleParams = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var _this = this;
      var paramTypes, requests, responses, votingParams, depositParams, tallyParams;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            paramTypes = ['voting', 'deposit', 'tallying'];
            requests = paramTypes.map(function (type) {
              var request = new QueryParamsRequest$3();
              request.setParamsType(type);
              return request;
            });
            _context.prev = 2;
            _context.next = 5;
            return Promise.all(requests.map(function (request) {
              return _this.request(request, Query$3.Params);
            }));
          case 5:
            responses = _context.sent;
            votingParams = responses[0], depositParams = responses[1], tallyParams = responses[2];
            return _context.abrupt("return", ChainGrpcGovTransformer.moduleParamsResponseToModuleParamsByType({
              votingParams: votingParams.getVotingParams(),
              tallyParams: tallyParams.getTallyParams(),
              depositParams: depositParams.getDepositParams()
            }));
          case 10:
            _context.prev = 10;
            _context.t0 = _context["catch"](2);
            throw new Error(_context.t0.message);
          case 13:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[2, 10]]);
    }));
    function fetchModuleParams() {
      return _fetchModuleParams.apply(this, arguments);
    }
    return fetchModuleParams;
  }();
  _proto.fetchProposals = /*#__PURE__*/function () {
    var _fetchProposals = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref) {
      var status, pagination, request, paginationForRequest, response;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            status = _ref.status, pagination = _ref.pagination;
            request = new QueryProposalsRequest();
            request.setProposalStatus(status);
            paginationForRequest = paginationRequestFromPagination(pagination);
            if (paginationForRequest) {
              request.setPagination(paginationForRequest);
            }
            _context2.prev = 5;
            _context2.next = 8;
            return this.request(request, Query$3.Proposals);
          case 8:
            response = _context2.sent;
            return _context2.abrupt("return", ChainGrpcGovTransformer.proposalsResponseToProposals(response));
          case 12:
            _context2.prev = 12;
            _context2.t0 = _context2["catch"](5);
            throw new Error(_context2.t0.message);
          case 15:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[5, 12]]);
    }));
    function fetchProposals(_x) {
      return _fetchProposals.apply(this, arguments);
    }
    return fetchProposals;
  }();
  _proto.fetchProposal = /*#__PURE__*/function () {
    var _fetchProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(proposalId) {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            request = new QueryProposalRequest();
            request.setProposalId(proposalId);
            _context3.prev = 2;
            _context3.next = 5;
            return this.request(request, Query$3.Proposal);
          case 5:
            response = _context3.sent;
            return _context3.abrupt("return", ChainGrpcGovTransformer.proposalResponseToProposal(response));
          case 9:
            _context3.prev = 9;
            _context3.t0 = _context3["catch"](2);
            throw new Error(_context3.t0.message);
          case 12:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this, [[2, 9]]);
    }));
    function fetchProposal(_x2) {
      return _fetchProposal.apply(this, arguments);
    }
    return fetchProposal;
  }();
  _proto.fetchProposalDeposits = /*#__PURE__*/function () {
    var _fetchProposalDeposits = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref2) {
      var proposalId, pagination, request, paginationForRequest, response;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            proposalId = _ref2.proposalId, pagination = _ref2.pagination;
            request = new QueryDepositsRequest();
            request.setProposalId(proposalId);
            paginationForRequest = paginationRequestFromPagination(pagination);
            if (paginationForRequest) {
              request.setPagination(paginationForRequest);
            }
            _context4.prev = 5;
            _context4.next = 8;
            return this.request(request, Query$3.Deposits);
          case 8:
            response = _context4.sent;
            return _context4.abrupt("return", ChainGrpcGovTransformer.depositsResponseToDeposits(response));
          case 12:
            _context4.prev = 12;
            _context4.t0 = _context4["catch"](5);
            throw new Error(_context4.t0.message);
          case 15:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this, [[5, 12]]);
    }));
    function fetchProposalDeposits(_x3) {
      return _fetchProposalDeposits.apply(this, arguments);
    }
    return fetchProposalDeposits;
  }();
  _proto.fetchProposalVotes = /*#__PURE__*/function () {
    var _fetchProposalVotes = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(_ref3) {
      var proposalId, pagination, request, paginationForRequest, response;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            proposalId = _ref3.proposalId, pagination = _ref3.pagination;
            request = new QueryVotesRequest();
            request.setProposalId(proposalId);
            paginationForRequest = paginationRequestFromPagination(pagination);
            if (paginationForRequest) {
              request.setPagination(paginationForRequest);
            }
            _context5.prev = 5;
            _context5.next = 8;
            return this.request(request, Query$3.Votes);
          case 8:
            response = _context5.sent;
            return _context5.abrupt("return", ChainGrpcGovTransformer.votesResponseToVotes(response));
          case 12:
            _context5.prev = 12;
            _context5.t0 = _context5["catch"](5);
            throw new Error(_context5.t0.message);
          case 15:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this, [[5, 12]]);
    }));
    function fetchProposalVotes(_x4) {
      return _fetchProposalVotes.apply(this, arguments);
    }
    return fetchProposalVotes;
  }();
  _proto.fetchProposalTally = /*#__PURE__*/function () {
    var _fetchProposalTally = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(proposalId) {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            request = new QueryTallyResultRequest();
            request.setProposalId(proposalId);
            _context6.prev = 2;
            _context6.next = 5;
            return this.request(request, Query$3.TallyResult);
          case 5:
            response = _context6.sent;
            return _context6.abrupt("return", ChainGrpcGovTransformer.tallyResultResponseToTallyResult(response));
          case 9:
            _context6.prev = 9;
            _context6.t0 = _context6["catch"](2);
            throw new Error(_context6.t0.message);
          case 12:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this, [[2, 9]]);
    }));
    function fetchProposalTally(_x5) {
      return _fetchProposalTally.apply(this, arguments);
    }
    return fetchProposalTally;
  }();
  return ChainGrpcGovApi;
}(BaseGrpcConsumer);

/**
 * The IBC module provides functions for denom trace (base denom and its path)
 *
 * @group gRPC API
 *
 * @example
 * To use IBC methods, initialise a {@link ChainGrpcIbcApi} object to with a gRPC endpoint. An endpoint can be retrieved by using {@link networkEndpoints}.
 * ```ts
 * const endpoint =  getEndpointsForNetwork(Network.Devnet).grpcEndpoint;
 * const client = new ChainGrpcIbcApi(endpoint);
 * const response = await client.fetchDenomsTrace();
 * ```
 */
var ChainGrpcIbcApi = /*#__PURE__*/function (_BaseConsumer) {
  _inheritsLoose(ChainGrpcIbcApi, _BaseConsumer);
  function ChainGrpcIbcApi() {
    return _BaseConsumer.apply(this, arguments) || this;
  }
  var _proto = ChainGrpcIbcApi.prototype;
  /**
   *
   * @param hash
   * @returns
   */
  _proto.fetchDenomTrace =
  /*#__PURE__*/
  function () {
    var _fetchDenomTrace = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(hash) {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            request = new QueryDenomTraceRequest();
            request.setHash(hash);
            _context.prev = 2;
            _context.next = 5;
            return this.request(request, Query$4.DenomTrace);
          case 5:
            response = _context.sent;
            return _context.abrupt("return", response.getDenomTrace().toObject());
          case 9:
            _context.prev = 9;
            _context.t0 = _context["catch"](2);
            throw new Error(_context.t0.message);
          case 12:
          case "end":
            return _context.stop();
        }
      }, _callee, this, [[2, 9]]);
    }));
    function fetchDenomTrace(_x) {
      return _fetchDenomTrace.apply(this, arguments);
    }
    return fetchDenomTrace;
  }()
  /**
   *
   * @returns
   */
  ;
  _proto.fetchDenomsTrace =
  /*#__PURE__*/
  function () {
    var _fetchDenomsTrace = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            request = new QueryDenomTracesRequest();
            _context2.prev = 1;
            _context2.next = 4;
            return this.request(request, Query$4.DenomTraces);
          case 4:
            response = _context2.sent;
            return _context2.abrupt("return", response.getDenomTracesList().map(function (trace) {
              return trace.toObject();
            }));
          case 8:
            _context2.prev = 8;
            _context2.t0 = _context2["catch"](1);
            throw new Error(_context2.t0.message);
          case 11:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[1, 8]]);
    }));
    function fetchDenomsTrace() {
      return _fetchDenomsTrace.apply(this, arguments);
    }
    return fetchDenomsTrace;
  }();
  return ChainGrpcIbcApi;
}(BaseGrpcConsumer);

/**
 * @group gRPC API
 */
var ChainGrpcMintApi = /*#__PURE__*/function (_BaseConsumer) {
  _inheritsLoose(ChainGrpcMintApi, _BaseConsumer);
  function ChainGrpcMintApi() {
    return _BaseConsumer.apply(this, arguments) || this;
  }
  var _proto = ChainGrpcMintApi.prototype;
  _proto.fetchModuleParams = /*#__PURE__*/function () {
    var _fetchModuleParams = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            request = new QueryParamsRequest$4();
            _context.prev = 1;
            _context.next = 4;
            return this.request(request, Query$5.Params);
          case 4:
            response = _context.sent;
            return _context.abrupt("return", ChainGrpcMintTransformer.moduleParamsResponseToModuleParams(response));
          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](1);
            throw new Error(_context.t0.message);
          case 11:
          case "end":
            return _context.stop();
        }
      }, _callee, this, [[1, 8]]);
    }));
    function fetchModuleParams() {
      return _fetchModuleParams.apply(this, arguments);
    }
    return fetchModuleParams;
  }();
  _proto.fetchInflation = /*#__PURE__*/function () {
    var _fetchInflation = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            request = new QueryInflationRequest();
            _context2.prev = 1;
            _context2.next = 4;
            return this.request(request, Query$5.Inflation);
          case 4:
            response = _context2.sent;
            return _context2.abrupt("return", {
              inflation: cosmosSdkDecToBigNumber(new BigNumberInBase(uint8ArrayToString(response.getInflation()))).toFixed()
            });
          case 8:
            _context2.prev = 8;
            _context2.t0 = _context2["catch"](1);
            throw new Error(_context2.t0.message);
          case 11:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[1, 8]]);
    }));
    function fetchInflation() {
      return _fetchInflation.apply(this, arguments);
    }
    return fetchInflation;
  }();
  _proto.fetchAnnualProvisions = /*#__PURE__*/function () {
    var _fetchAnnualProvisions = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            request = new QueryAnnualProvisionsRequest();
            _context3.prev = 1;
            _context3.next = 4;
            return this.request(request, Query$5.AnnualProvisions);
          case 4:
            response = _context3.sent;
            return _context3.abrupt("return", {
              annualProvisions: cosmosSdkDecToBigNumber(new BigNumberInBase(uint8ArrayToString(response.getAnnualProvisions()))).toFixed()
            });
          case 8:
            _context3.prev = 8;
            _context3.t0 = _context3["catch"](1);
            throw new Error(_context3.t0.message);
          case 11:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this, [[1, 8]]);
    }));
    function fetchAnnualProvisions() {
      return _fetchAnnualProvisions.apply(this, arguments);
    }
    return fetchAnnualProvisions;
  }();
  return ChainGrpcMintApi;
}(BaseGrpcConsumer);

/**
 * @group gRPC API
 */
var ChainGrpcStakingApi = /*#__PURE__*/function (_BaseConsumer) {
  _inheritsLoose(ChainGrpcStakingApi, _BaseConsumer);
  function ChainGrpcStakingApi() {
    return _BaseConsumer.apply(this, arguments) || this;
  }
  var _proto = ChainGrpcStakingApi.prototype;
  _proto.fetchModuleParams = /*#__PURE__*/function () {
    var _fetchModuleParams = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            request = new QueryParamsRequest$5();
            _context.prev = 1;
            _context.next = 4;
            return this.request(request, Query$6.Params);
          case 4:
            response = _context.sent;
            return _context.abrupt("return", ChainGrpcStakingTransformer.moduleParamsResponseToModuleParams(response));
          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](1);
            throw new Error(_context.t0.message);
          case 11:
          case "end":
            return _context.stop();
        }
      }, _callee, this, [[1, 8]]);
    }));
    function fetchModuleParams() {
      return _fetchModuleParams.apply(this, arguments);
    }
    return fetchModuleParams;
  }();
  _proto.fetchPool = /*#__PURE__*/function () {
    var _fetchPool = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            request = new QueryPoolRequest();
            _context2.prev = 1;
            _context2.next = 4;
            return this.request(request, Query$6.Pool);
          case 4:
            response = _context2.sent;
            return _context2.abrupt("return", ChainGrpcStakingTransformer.poolResponseToPool(response));
          case 8:
            _context2.prev = 8;
            _context2.t0 = _context2["catch"](1);
            throw new Error(_context2.t0.message);
          case 11:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[1, 8]]);
    }));
    function fetchPool() {
      return _fetchPool.apply(this, arguments);
    }
    return fetchPool;
  }();
  _proto.fetchValidators = /*#__PURE__*/function () {
    var _fetchValidators = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            request = new QueryValidatorsRequest();
            _context3.prev = 1;
            _context3.next = 4;
            return this.request(request, Query$6.Validators);
          case 4:
            response = _context3.sent;
            return _context3.abrupt("return", ChainGrpcStakingTransformer.validatorsResponseToValidators(response));
          case 8:
            _context3.prev = 8;
            _context3.t0 = _context3["catch"](1);
            throw new Error(_context3.t0.message);
          case 11:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this, [[1, 8]]);
    }));
    function fetchValidators() {
      return _fetchValidators.apply(this, arguments);
    }
    return fetchValidators;
  }();
  _proto.fetchValidator = /*#__PURE__*/function () {
    var _fetchValidator = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(address) {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            request = new QueryValidatorRequest();
            request.setValidatorAddr(address);
            _context4.prev = 2;
            _context4.next = 5;
            return this.request(request, Query$6.Validator);
          case 5:
            response = _context4.sent;
            return _context4.abrupt("return", ChainGrpcStakingTransformer.validatorResponseToValidator(response));
          case 9:
            _context4.prev = 9;
            _context4.t0 = _context4["catch"](2);
            throw new Error(_context4.t0.message);
          case 12:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this, [[2, 9]]);
    }));
    function fetchValidator(_x) {
      return _fetchValidator.apply(this, arguments);
    }
    return fetchValidator;
  }();
  _proto.fetchValidatorDelegations = /*#__PURE__*/function () {
    var _fetchValidatorDelegations = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(_ref) {
      var validatorAddress, pagination, request, paginationForRequest, response;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            validatorAddress = _ref.validatorAddress, pagination = _ref.pagination;
            request = new QueryValidatorDelegationsRequest();
            request.setValidatorAddr(validatorAddress);
            paginationForRequest = paginationRequestFromPagination(pagination);
            if (paginationForRequest) {
              request.setPagination(paginationForRequest);
            }
            _context5.prev = 5;
            _context5.next = 8;
            return this.request(request, Query$6.ValidatorDelegations);
          case 8:
            response = _context5.sent;
            return _context5.abrupt("return", ChainGrpcStakingTransformer.delegationsResponseToDelegations(response));
          case 12:
            _context5.prev = 12;
            _context5.t0 = _context5["catch"](5);
            throw new Error(_context5.t0.message);
          case 15:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this, [[5, 12]]);
    }));
    function fetchValidatorDelegations(_x2) {
      return _fetchValidatorDelegations.apply(this, arguments);
    }
    return fetchValidatorDelegations;
  }();
  _proto.fetchValidatorDelegationsNoThrow = /*#__PURE__*/function () {
    var _fetchValidatorDelegationsNoThrow = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref2) {
      var validatorAddress, pagination, request, paginationForRequest, response;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            validatorAddress = _ref2.validatorAddress, pagination = _ref2.pagination;
            request = new QueryValidatorDelegationsRequest();
            request.setValidatorAddr(validatorAddress);
            paginationForRequest = paginationRequestFromPagination(pagination);
            if (paginationForRequest) {
              request.setPagination(paginationForRequest);
            }
            _context6.prev = 5;
            _context6.next = 8;
            return this.request(request, Query$6.ValidatorDelegations);
          case 8:
            response = _context6.sent;
            return _context6.abrupt("return", ChainGrpcStakingTransformer.delegationsResponseToDelegations(response));
          case 12:
            _context6.prev = 12;
            _context6.t0 = _context6["catch"](5);
            if (!_context6.t0.message.includes('does not exist')) {
              _context6.next = 16;
              break;
            }
            return _context6.abrupt("return", {
              delegations: [],
              pagination: {
                total: 0,
                next: ''
              }
            });
          case 16:
            throw new Error(_context6.t0.message);
          case 17:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this, [[5, 12]]);
    }));
    function fetchValidatorDelegationsNoThrow(_x3) {
      return _fetchValidatorDelegationsNoThrow.apply(this, arguments);
    }
    return fetchValidatorDelegationsNoThrow;
  }();
  _proto.fetchValidatorUnbondingDelegations = /*#__PURE__*/function () {
    var _fetchValidatorUnbondingDelegations = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(_ref3) {
      var validatorAddress, pagination, request, paginationForRequest, response;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            validatorAddress = _ref3.validatorAddress, pagination = _ref3.pagination;
            request = new QueryValidatorUnbondingDelegationsRequest();
            request.setValidatorAddr(validatorAddress);
            paginationForRequest = paginationRequestFromPagination(pagination);
            if (paginationForRequest) {
              request.setPagination(paginationForRequest);
            }
            _context7.prev = 5;
            _context7.next = 8;
            return this.request(request, Query$6.ValidatorUnbondingDelegations);
          case 8:
            response = _context7.sent;
            return _context7.abrupt("return", ChainGrpcStakingTransformer.unBondingDelegationsResponseToUnBondingDelegations(response));
          case 12:
            _context7.prev = 12;
            _context7.t0 = _context7["catch"](5);
            throw new Error(_context7.t0.message);
          case 15:
          case "end":
            return _context7.stop();
        }
      }, _callee7, this, [[5, 12]]);
    }));
    function fetchValidatorUnbondingDelegations(_x4) {
      return _fetchValidatorUnbondingDelegations.apply(this, arguments);
    }
    return fetchValidatorUnbondingDelegations;
  }();
  _proto.fetchValidatorUnbondingDelegationsNoThrow = /*#__PURE__*/function () {
    var _fetchValidatorUnbondingDelegationsNoThrow = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(_ref4) {
      var validatorAddress, pagination, request, paginationForRequest, response;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            validatorAddress = _ref4.validatorAddress, pagination = _ref4.pagination;
            request = new QueryValidatorUnbondingDelegationsRequest();
            request.setValidatorAddr(validatorAddress);
            paginationForRequest = paginationRequestFromPagination(pagination);
            if (paginationForRequest) {
              request.setPagination(paginationForRequest);
            }
            _context8.prev = 5;
            _context8.next = 8;
            return this.request(request, Query$6.ValidatorUnbondingDelegations);
          case 8:
            response = _context8.sent;
            return _context8.abrupt("return", ChainGrpcStakingTransformer.unBondingDelegationsResponseToUnBondingDelegations(response));
          case 12:
            _context8.prev = 12;
            _context8.t0 = _context8["catch"](5);
            if (!_context8.t0.message.includes('does not exist')) {
              _context8.next = 16;
              break;
            }
            return _context8.abrupt("return", {
              unbondingDelegations: [],
              pagination: {
                total: 0,
                next: ''
              }
            });
          case 16:
            throw new Error(_context8.t0.message);
          case 17:
          case "end":
            return _context8.stop();
        }
      }, _callee8, this, [[5, 12]]);
    }));
    function fetchValidatorUnbondingDelegationsNoThrow(_x5) {
      return _fetchValidatorUnbondingDelegationsNoThrow.apply(this, arguments);
    }
    return fetchValidatorUnbondingDelegationsNoThrow;
  }();
  _proto.fetchDelegation = /*#__PURE__*/function () {
    var _fetchDelegation = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(_ref5) {
      var routerAddress, validatorAddress, request, response;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            routerAddress = _ref5.routerAddress, validatorAddress = _ref5.validatorAddress;
            request = new QueryDelegationRequest();
            request.setDelegatorAddr(routerAddress);
            request.setValidatorAddr(validatorAddress);
            _context9.prev = 4;
            _context9.next = 7;
            return this.request(request, Query$6.Delegation);
          case 7:
            response = _context9.sent;
            return _context9.abrupt("return", ChainGrpcStakingTransformer.delegationResponseToDelegation(response));
          case 11:
            _context9.prev = 11;
            _context9.t0 = _context9["catch"](4);
            throw new Error(_context9.t0.message);
          case 14:
          case "end":
            return _context9.stop();
        }
      }, _callee9, this, [[4, 11]]);
    }));
    function fetchDelegation(_x6) {
      return _fetchDelegation.apply(this, arguments);
    }
    return fetchDelegation;
  }();
  _proto.fetchDelegations = /*#__PURE__*/function () {
    var _fetchDelegations = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(_ref6) {
      var routerAddress, pagination, request, paginationForRequest, response;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            routerAddress = _ref6.routerAddress, pagination = _ref6.pagination;
            request = new QueryDelegatorDelegationsRequest();
            request.setDelegatorAddr(routerAddress);
            paginationForRequest = paginationRequestFromPagination(pagination);
            if (paginationForRequest) {
              request.setPagination(paginationForRequest);
            }
            _context10.prev = 5;
            _context10.next = 8;
            return this.request(request, Query$6.DelegatorDelegations);
          case 8:
            response = _context10.sent;
            return _context10.abrupt("return", ChainGrpcStakingTransformer.delegationsResponseToDelegations(response));
          case 12:
            _context10.prev = 12;
            _context10.t0 = _context10["catch"](5);
            throw new Error(_context10.t0.message);
          case 15:
          case "end":
            return _context10.stop();
        }
      }, _callee10, this, [[5, 12]]);
    }));
    function fetchDelegations(_x7) {
      return _fetchDelegations.apply(this, arguments);
    }
    return fetchDelegations;
  }();
  _proto.fetchDelegationsNoThrow = /*#__PURE__*/function () {
    var _fetchDelegationsNoThrow = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(_ref7) {
      var routerAddress, pagination, request, paginationForRequest, response;
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            routerAddress = _ref7.routerAddress, pagination = _ref7.pagination;
            request = new QueryDelegatorDelegationsRequest();
            request.setDelegatorAddr(routerAddress);
            paginationForRequest = paginationRequestFromPagination(pagination);
            if (paginationForRequest) {
              request.setPagination(paginationForRequest);
            }
            _context11.prev = 5;
            _context11.next = 8;
            return this.request(request, Query$6.DelegatorDelegations);
          case 8:
            response = _context11.sent;
            return _context11.abrupt("return", ChainGrpcStakingTransformer.delegationsResponseToDelegations(response));
          case 12:
            _context11.prev = 12;
            _context11.t0 = _context11["catch"](5);
            if (!_context11.t0.message.includes('does not exist')) {
              _context11.next = 16;
              break;
            }
            return _context11.abrupt("return", {
              delegations: [],
              pagination: {
                total: 0,
                next: ''
              }
            });
          case 16:
            throw new Error(_context11.t0.message);
          case 17:
          case "end":
            return _context11.stop();
        }
      }, _callee11, this, [[5, 12]]);
    }));
    function fetchDelegationsNoThrow(_x8) {
      return _fetchDelegationsNoThrow.apply(this, arguments);
    }
    return fetchDelegationsNoThrow;
  }();
  _proto.fetchDelegators = /*#__PURE__*/function () {
    var _fetchDelegators = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(_ref8) {
      var validatorAddress, pagination, request, paginationForRequest, response;
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            validatorAddress = _ref8.validatorAddress, pagination = _ref8.pagination;
            request = new QueryValidatorDelegationsRequest();
            request.setValidatorAddr(validatorAddress);
            paginationForRequest = paginationRequestFromPagination(pagination);
            if (paginationForRequest) {
              request.setPagination(paginationForRequest);
            }
            _context12.prev = 5;
            _context12.next = 8;
            return this.request(request, Query$6.ValidatorDelegations);
          case 8:
            response = _context12.sent;
            return _context12.abrupt("return", ChainGrpcStakingTransformer.delegationsResponseToDelegations(response));
          case 12:
            _context12.prev = 12;
            _context12.t0 = _context12["catch"](5);
            throw new Error(_context12.t0.message);
          case 15:
          case "end":
            return _context12.stop();
        }
      }, _callee12, this, [[5, 12]]);
    }));
    function fetchDelegators(_x9) {
      return _fetchDelegators.apply(this, arguments);
    }
    return fetchDelegators;
  }();
  _proto.fetchDelegatorsNoThrow = /*#__PURE__*/function () {
    var _fetchDelegatorsNoThrow = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(_ref9) {
      var validatorAddress, pagination, request, paginationForRequest, response;
      return _regeneratorRuntime().wrap(function _callee13$(_context13) {
        while (1) switch (_context13.prev = _context13.next) {
          case 0:
            validatorAddress = _ref9.validatorAddress, pagination = _ref9.pagination;
            request = new QueryValidatorDelegationsRequest();
            request.setValidatorAddr(validatorAddress);
            paginationForRequest = paginationRequestFromPagination(pagination);
            if (paginationForRequest) {
              request.setPagination(paginationForRequest);
            }
            _context13.prev = 5;
            _context13.next = 8;
            return this.request(request, Query$6.ValidatorDelegations);
          case 8:
            response = _context13.sent;
            return _context13.abrupt("return", ChainGrpcStakingTransformer.delegationsResponseToDelegations(response));
          case 12:
            _context13.prev = 12;
            _context13.t0 = _context13["catch"](5);
            if (!_context13.t0.message.includes('does not exist')) {
              _context13.next = 16;
              break;
            }
            return _context13.abrupt("return", {
              delegations: [],
              pagination: {
                total: 0,
                next: ''
              }
            });
          case 16:
            throw new Error(_context13.t0.message);
          case 17:
          case "end":
            return _context13.stop();
        }
      }, _callee13, this, [[5, 12]]);
    }));
    function fetchDelegatorsNoThrow(_x10) {
      return _fetchDelegatorsNoThrow.apply(this, arguments);
    }
    return fetchDelegatorsNoThrow;
  }();
  _proto.fetchUnbondingDelegations = /*#__PURE__*/function () {
    var _fetchUnbondingDelegations = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(_ref10) {
      var routerAddress, pagination, request, paginationForRequest, response;
      return _regeneratorRuntime().wrap(function _callee14$(_context14) {
        while (1) switch (_context14.prev = _context14.next) {
          case 0:
            routerAddress = _ref10.routerAddress, pagination = _ref10.pagination;
            request = new QueryDelegatorUnbondingDelegationsRequest();
            request.setDelegatorAddr(routerAddress);
            paginationForRequest = paginationRequestFromPagination(pagination);
            if (paginationForRequest) {
              request.setPagination(paginationForRequest);
            }
            _context14.prev = 5;
            _context14.next = 8;
            return this.request(request, Query$6.DelegatorUnbondingDelegations);
          case 8:
            response = _context14.sent;
            return _context14.abrupt("return", ChainGrpcStakingTransformer.unBondingDelegationsResponseToUnBondingDelegations(response));
          case 12:
            _context14.prev = 12;
            _context14.t0 = _context14["catch"](5);
            throw new Error(_context14.t0.message);
          case 15:
          case "end":
            return _context14.stop();
        }
      }, _callee14, this, [[5, 12]]);
    }));
    function fetchUnbondingDelegations(_x11) {
      return _fetchUnbondingDelegations.apply(this, arguments);
    }
    return fetchUnbondingDelegations;
  }();
  _proto.fetchUnbondingDelegationsNoThrow = /*#__PURE__*/function () {
    var _fetchUnbondingDelegationsNoThrow = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(_ref11) {
      var routerAddress, pagination, request, paginationForRequest, response;
      return _regeneratorRuntime().wrap(function _callee15$(_context15) {
        while (1) switch (_context15.prev = _context15.next) {
          case 0:
            routerAddress = _ref11.routerAddress, pagination = _ref11.pagination;
            request = new QueryDelegatorUnbondingDelegationsRequest();
            request.setDelegatorAddr(routerAddress);
            paginationForRequest = paginationRequestFromPagination(pagination);
            if (paginationForRequest) {
              request.setPagination(paginationForRequest);
            }
            _context15.prev = 5;
            _context15.next = 8;
            return this.request(request, Query$6.DelegatorUnbondingDelegations);
          case 8:
            response = _context15.sent;
            return _context15.abrupt("return", ChainGrpcStakingTransformer.unBondingDelegationsResponseToUnBondingDelegations(response));
          case 12:
            _context15.prev = 12;
            _context15.t0 = _context15["catch"](5);
            if (!_context15.t0.message.includes('does not exist')) {
              _context15.next = 16;
              break;
            }
            return _context15.abrupt("return", {
              unbondingDelegations: [],
              pagination: {
                total: 0,
                next: ''
              }
            });
          case 16:
            throw new Error(_context15.t0.message);
          case 17:
          case "end":
            return _context15.stop();
        }
      }, _callee15, this, [[5, 12]]);
    }));
    function fetchUnbondingDelegationsNoThrow(_x12) {
      return _fetchUnbondingDelegationsNoThrow.apply(this, arguments);
    }
    return fetchUnbondingDelegationsNoThrow;
  }();
  _proto.fetchReDelegations = /*#__PURE__*/function () {
    var _fetchReDelegations = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(_ref12) {
      var routerAddress, pagination, request, paginationForRequest, response;
      return _regeneratorRuntime().wrap(function _callee16$(_context16) {
        while (1) switch (_context16.prev = _context16.next) {
          case 0:
            routerAddress = _ref12.routerAddress, pagination = _ref12.pagination;
            request = new QueryRedelegationsRequest();
            request.setDelegatorAddr(routerAddress);
            paginationForRequest = paginationRequestFromPagination(pagination);
            if (paginationForRequest) {
              request.setPagination(paginationForRequest);
            }
            _context16.prev = 5;
            _context16.next = 8;
            return this.request(request, Query$6.Redelegations);
          case 8:
            response = _context16.sent;
            return _context16.abrupt("return", ChainGrpcStakingTransformer.reDelegationsResponseToReDelegations(response));
          case 12:
            _context16.prev = 12;
            _context16.t0 = _context16["catch"](5);
            throw new Error(_context16.t0.message);
          case 15:
          case "end":
            return _context16.stop();
        }
      }, _callee16, this, [[5, 12]]);
    }));
    function fetchReDelegations(_x13) {
      return _fetchReDelegations.apply(this, arguments);
    }
    return fetchReDelegations;
  }();
  _proto.fetchReDelegationsNoThrow = /*#__PURE__*/function () {
    var _fetchReDelegationsNoThrow = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(_ref13) {
      var routerAddress, pagination, request, paginationForRequest, response;
      return _regeneratorRuntime().wrap(function _callee17$(_context17) {
        while (1) switch (_context17.prev = _context17.next) {
          case 0:
            routerAddress = _ref13.routerAddress, pagination = _ref13.pagination;
            request = new QueryRedelegationsRequest();
            request.setDelegatorAddr(routerAddress);
            paginationForRequest = paginationRequestFromPagination(pagination);
            if (paginationForRequest) {
              request.setPagination(paginationForRequest);
            }
            _context17.prev = 5;
            _context17.next = 8;
            return this.request(request, Query$6.Redelegations);
          case 8:
            response = _context17.sent;
            return _context17.abrupt("return", ChainGrpcStakingTransformer.reDelegationsResponseToReDelegations(response));
          case 12:
            _context17.prev = 12;
            _context17.t0 = _context17["catch"](5);
            if (!_context17.t0.message.includes('does not exist')) {
              _context17.next = 16;
              break;
            }
            return _context17.abrupt("return", {
              redelegations: [],
              pagination: {
                total: 0,
                next: ''
              }
            });
          case 16:
            throw new Error(_context17.t0.message);
          case 17:
          case "end":
            return _context17.stop();
        }
      }, _callee17, this, [[5, 12]]);
    }));
    function fetchReDelegationsNoThrow(_x14) {
      return _fetchReDelegationsNoThrow.apply(this, arguments);
    }
    return fetchReDelegationsNoThrow;
  }();
  return ChainGrpcStakingApi;
}(BaseGrpcConsumer);

/**
 * @group gRPC API
 * @hidden
 */
var ChainGrpcClient = function ChainGrpcClient(endpoint) {
  this.auth = new ChainGrpcAuthApi(endpoint);
  this.bank = new ChainGrpcBankApi(endpoint);
  this.distribution = new ChainGrpcDistributionApi(endpoint);
  this.gov = new ChainGrpcGovApi(endpoint);
  this.ibc = new ChainGrpcIbcApi(endpoint);
  this.mint = new ChainGrpcMintApi(endpoint);
  this.staking = new ChainGrpcStakingApi(endpoint);
};

/**
 * @hidden
 */
var BaseRestConsumer = /*#__PURE__*/function () {
  function BaseRestConsumer(endpoint) {
    this.client = new HttpClient(endpoint);
  }
  var _proto = BaseRestConsumer.prototype;
  _proto.get = /*#__PURE__*/function () {
    var _get = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(endpoint, params) {
      var error, message;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (params === void 0) {
              params = {};
            }
            _context.prev = 1;
            return _context.abrupt("return", this.client.get(endpoint, params));
          case 5:
            _context.prev = 5;
            _context.t0 = _context["catch"](1);
            error = _context.t0;
            if (!axios.isAxiosError(error)) {
              _context.next = 11;
              break;
            }
            message = error.response ? typeof error.response.data === 'string' ? error.response.data : error.response.statusText : "The request to " + endpoint + " has failed.";
            throw new HttpRequestException(new Error(message), {
              code: error.response ? error.response.status : StatusCodes.BAD_REQUEST,
              method: HttpRequestMethod.Get
            });
          case 11:
            throw new HttpRequestException(new Error(error.message), {
              code: UnspecifiedErrorCode,
              contextModule: HttpRequestMethod.Get
            });
          case 12:
          case "end":
            return _context.stop();
        }
      }, _callee, this, [[1, 5]]);
    }));
    function get(_x, _x2) {
      return _get.apply(this, arguments);
    }
    return get;
  }();
  _proto.post = /*#__PURE__*/function () {
    var _post = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(endpoint, params) {
      var error, message;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            if (params === void 0) {
              params = {};
            }
            _context2.prev = 1;
            return _context2.abrupt("return", this.client.post(endpoint, params));
          case 5:
            _context2.prev = 5;
            _context2.t0 = _context2["catch"](1);
            error = _context2.t0;
            if (!axios.isAxiosError(error)) {
              _context2.next = 11;
              break;
            }
            message = error.response ? typeof error.response.data === 'string' ? error.response.data : error.response.statusText : "The request to " + endpoint + " has failed.";
            throw new HttpRequestException(new Error(message), {
              code: error.response ? error.response.status : StatusCodes.BAD_REQUEST,
              contextModule: HttpRequestMethod.Post
            });
          case 11:
            throw new HttpRequestException(new Error(error.message), {
              code: UnspecifiedErrorCode,
              contextModule: HttpRequestMethod.Post
            });
          case 12:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[1, 5]]);
    }));
    function post(_x3, _x4) {
      return _post.apply(this, arguments);
    }
    return post;
  }();
  return BaseRestConsumer;
}();

var ProposalStatus;
(function (ProposalStatus) {
  ProposalStatus[ProposalStatus["PROPOSAL_STATUS_UNSPECIFIED"] = 0] = "PROPOSAL_STATUS_UNSPECIFIED";
  ProposalStatus[ProposalStatus["PROPOSAL_STATUS_DEPOSIT_PERIOD"] = 1] = "PROPOSAL_STATUS_DEPOSIT_PERIOD";
  ProposalStatus[ProposalStatus["PROPOSAL_STATUS_VOTING_PERIOD"] = 2] = "PROPOSAL_STATUS_VOTING_PERIOD";
  ProposalStatus[ProposalStatus["PROPOSAL_STATUS_PASSED"] = 3] = "PROPOSAL_STATUS_PASSED";
  ProposalStatus[ProposalStatus["PROPOSAL_STATUS_REJECTED"] = 4] = "PROPOSAL_STATUS_REJECTED";
  ProposalStatus[ProposalStatus["PROPOSAL_STATUS_FAILED"] = 5] = "PROPOSAL_STATUS_FAILED";
})(ProposalStatus || (ProposalStatus = {}));
var VoteOption;
(function (VoteOption) {
  VoteOption[VoteOption["VOTE_OPTION_UNSPECIFIED"] = 0] = "VOTE_OPTION_UNSPECIFIED";
  VoteOption[VoteOption["VOTE_OPTION_YES"] = 1] = "VOTE_OPTION_YES";
  VoteOption[VoteOption["VOTE_OPTION_ABSTAIN"] = 2] = "VOTE_OPTION_ABSTAIN";
  VoteOption[VoteOption["VOTE_OPTION_NO"] = 3] = "VOTE_OPTION_NO";
  VoteOption[VoteOption["VOTE_OPTION_NO_WITH_VETO"] = 4] = "VOTE_OPTION_NO_WITH_VETO";
})(VoteOption || (VoteOption = {}));

function getClaimHash(object) {
  return sha256(object);
}

function getValsetUpdatedClaimHash(claimHashObject) {
  var claimHash = new ValsetUpdatedClaimHash();
  var bridgeValidators = claimHashObject.membersList.map(function (validatorObj) {
    var bridgeValidator = new BridgeValidator();
    bridgeValidator.setPower(validatorObj.power);
    bridgeValidator.setEthereumaddress(validatorObj.ethereumaddress);
    return bridgeValidator;
  });
  claimHash.setChainid(claimHashObject.chainid);
  claimHash.setContract(claimHashObject.contract);
  claimHash.setEventnonce(claimHashObject.eventnonce);
  claimHash.setValsetnonce(claimHashObject.valsetnonce);
  claimHash.setBlockheight(claimHashObject.blockheight);
  claimHash.setMembersList(bridgeValidators);
  claimHash.setSourcetxhash(claimHashObject.sourcetxhash);
  return getClaimHash(claimHash.serializeBinary());
}

/**
 * gets CrosschainClaimHash
 * @param crosschainRequest
 * @returns
 */
function getCrosschainClaimHash(crosschainRequest) {
  var claimHash = new CrosschainRequestClaimHash();
  claimHash.setSrcChainId(crosschainRequest.srcChainId);
  claimHash.setContract(crosschainRequest.contract);
  claimHash.setRequestIdentifier(crosschainRequest.requestIdentifier);
  claimHash.setBlockHeight(crosschainRequest.blockHeight);
  claimHash.setSourceTxHash(crosschainRequest.sourceTxHash);
  claimHash.setSrcTimestamp(crosschainRequest.srcTimestamp);
  claimHash.setSrcTxOrigin(crosschainRequest.srcTxOrigin);
  claimHash.setRouteAmount(crosschainRequest.routeAmount);
  claimHash.setRouteRecipient(crosschainRequest.routeRecipient);
  claimHash.setDestChainId(crosschainRequest.destChainId);
  claimHash.setRequestSender(crosschainRequest.requestSender);
  claimHash.setRequestMetadata(crosschainRequest.requestMetadata);
  claimHash.setRequestPacket(crosschainRequest.requestPacket);
  claimHash.setSrcChainType(crosschainRequest.srcChainType);
  claimHash.setDestChainType(crosschainRequest.destChainType);
  return getClaimHash(claimHash.serializeBinary());
}
/**
 * gets CrosschainAckClaimHash
 * @param crosschainAckRequest
 * @returns
 */
function getCrosschainAckClaimHash(crosschainAckRequest) {
  var claimHash = new CrosschainAckRequestClaimHash();
  claimHash.setAckSrcChainId(crosschainAckRequest.ackSrcChainId);
  claimHash.setContract(crosschainAckRequest.contract);
  claimHash.setAckRequestIdentifier(crosschainAckRequest.ackRequestIdentifier);
  claimHash.setBlockheight(crosschainAckRequest.blockheight);
  claimHash.setDesttxhash(crosschainAckRequest.desttxhash);
  claimHash.setRelayerrouteraddress(crosschainAckRequest.relayerrouteraddress);
  claimHash.setAckDestChainId(crosschainAckRequest.ackDestChainId);
  claimHash.setRequestSender(crosschainAckRequest.requestSender);
  claimHash.setRequestidentifier(crosschainAckRequest.requestidentifier);
  claimHash.setAckSrcChainType(crosschainAckRequest.ackSrcChainType);
  claimHash.setAckDestChainType(crosschainAckRequest.ackDestChainType);
  claimHash.setFeeconsumed(crosschainAckRequest.feeconsumed);
  claimHash.setExecdata(crosschainAckRequest.execdata);
  claimHash.setExecstatus(crosschainAckRequest.execstatus);
  return getClaimHash(claimHash.serializeBinary());
}
function getCrosschainAckReceiptClaimHash(crosschainAckReceipt) {
  var claimHash = new CrosschainAckReceiptClaimHash();
  claimHash.setAckreceiptsrcchainid(crosschainAckReceipt.acksrcchainid);
  claimHash.setContract(crosschainAckReceipt.contract);
  claimHash.setAckReceiptIdentifier(crosschainAckReceipt.ackrequestidentifier);
  claimHash.setAckReceiptBlockheight(crosschainAckReceipt.ackReceiptBlockheight);
  claimHash.setAckReceiptTxhash(crosschainAckReceipt.ackReceiptTxhash);
  claimHash.setRelayerrouteraddress(crosschainAckReceipt.relayerrouteraddress);
  claimHash.setRequestidentifier(crosschainAckReceipt.requestidentifier);
  claimHash.setAcksrcchainid(crosschainAckReceipt.acksrcchainid);
  claimHash.setRequestidentifier(crosschainAckReceipt.requestidentifier);
  claimHash.setAcksrcchainid(crosschainAckReceipt.acksrcchainid);
  claimHash.setAckrequestidentifier(crosschainAckReceipt.ackrequestidentifier);
  claimHash.setFeeconsumed(crosschainAckReceipt.feeconsumed);
  return getClaimHash(claimHash.serializeBinary());
}

var ChainModule = /*#__PURE__*/_extends({}, ChainErrorModule);

/**
 * @group REST API
 */
var ChainRestAuthApi = /*#__PURE__*/function (_BaseRestConsumer) {
  _inheritsLoose(ChainRestAuthApi, _BaseRestConsumer);
  function ChainRestAuthApi() {
    return _BaseRestConsumer.apply(this, arguments) || this;
  }
  var _proto = ChainRestAuthApi.prototype;
  /**
   * Looks up the account information for the Router address.
   *
   * @param address address of account to look up
   */
  _proto.fetchAccount =
  /*#__PURE__*/
  function () {
    var _fetchAccount = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(address) {
      var response;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return this.get("cosmos/auth/v1beta1/accounts/" + address);
          case 3:
            response = _context.sent;
            return _context.abrupt("return", response.data);
          case 7:
            _context.prev = 7;
            _context.t0 = _context["catch"](0);
            if (!(_context.t0 instanceof HttpRequestException)) {
              _context.next = 11;
              break;
            }
            throw _context.t0;
          case 11:
            throw new HttpRequestException(new Error(_context.t0.message), {
              code: UnspecifiedErrorCode,
              contextModule: ChainModule.Auth
            });
          case 12:
          case "end":
            return _context.stop();
        }
      }, _callee, this, [[0, 7]]);
    }));
    function fetchAccount(_x) {
      return _fetchAccount.apply(this, arguments);
    }
    return fetchAccount;
  }()
  /**
   * Looks up the account information for any cosmos chain address.
   *
   * @param address address of account to look up
   */
  ;
  _proto.fetchCosmosAccount =
  /*#__PURE__*/
  function () {
    var _fetchCosmosAccount = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(address) {
      var isRouterAddress, response, baseAccount;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            isRouterAddress = address.startsWith('router');
            _context2.next = 4;
            return this.get("cosmos/auth/v1beta1/accounts/" + address);
          case 4:
            response = _context2.sent;
            baseAccount = isRouterAddress ? response.data.account.base_account : response.data.account;
            return _context2.abrupt("return", baseAccount);
          case 9:
            _context2.prev = 9;
            _context2.t0 = _context2["catch"](0);
            if (!(_context2.t0 instanceof HttpRequestException)) {
              _context2.next = 13;
              break;
            }
            throw _context2.t0;
          case 13:
            throw new HttpRequestException(new Error(_context2.t0.message), {
              code: UnspecifiedErrorCode,
              contextModule: ChainModule.Auth
            });
          case 14:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[0, 9]]);
    }));
    function fetchCosmosAccount(_x2) {
      return _fetchCosmosAccount.apply(this, arguments);
    }
    return fetchCosmosAccount;
  }();
  return ChainRestAuthApi;
}(BaseRestConsumer);

/**
 * @group REST API
 * @hidden
 */
var ChainRestClient = function ChainRestClient(endpoint) {
  this.auth = new ChainRestAuthApi(endpoint);
};

/**
 * The Wasm module manages contract state and info.
 *
 * @group gRPC API
 *
 * @example
 * To use Wasm methods, initialise a {@link ChainGrpcWasmApi} object to with a gRPC endpoint. An endpoint can be retrieved by using {@link networkEndpoints}.
 * ```ts
 * const endpoint =  getEndpointsForNetwork(Network.Devnet).grpcEndpoint;
 * const client = new ChainGrpcWasmApi(endpoint);
 * const response = await client.fetchContractInfo(<contract-address>);
 * ```
 */
var ChainGrpcWasmApi = /*#__PURE__*/function (_BaseConsumer) {
  _inheritsLoose(ChainGrpcWasmApi, _BaseConsumer);
  function ChainGrpcWasmApi() {
    var _this;
    _this = _BaseConsumer.apply(this, arguments) || this;
    _this.module = ChainModule.Wasm;
    return _this;
  }
  /**
   * Get balance of a contract.
   *
   * @param contractAddress contract address.
   * @returns balance.
   */
  var _proto = ChainGrpcWasmApi.prototype;
  _proto.fetchContractAccountsBalance =
  /*#__PURE__*/
  function () {
    var _fetchContractAccountsBalance = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
      var contractAddress, pagination, request, paginationForRequest, response;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            contractAddress = _ref.contractAddress, pagination = _ref.pagination;
            request = new QueryAllContractStateRequest();
            request.setAddress(contractAddress);
            paginationForRequest = paginationRequestFromPagination(pagination);
            if (paginationForRequest) {
              request.setPagination(paginationForRequest);
            }
            _context.prev = 5;
            _context.next = 8;
            return this.request(request, Query$7.AllContractState);
          case 8:
            response = _context.sent;
            return _context.abrupt("return", ChainGrpcWasmTransformer.allContractStateResponseToContractAccountsBalanceWithPagination(response));
          case 12:
            _context.prev = 12;
            _context.t0 = _context["catch"](5);
            if (!(_context.t0 instanceof GrpcUnaryRequestException)) {
              _context.next = 16;
              break;
            }
            throw _context.t0;
          case 16:
            throw new GrpcUnaryRequestException(_context.t0, {
              code: UnspecifiedErrorCode,
              contextModule: this.module
            });
          case 17:
          case "end":
            return _context.stop();
        }
      }, _callee, this, [[5, 12]]);
    }));
    function fetchContractAccountsBalance(_x) {
      return _fetchContractAccountsBalance.apply(this, arguments);
    }
    return fetchContractAccountsBalance;
  }()
  /**
   * Get contract info.
   *
   * @param contractAddress contract address.
   * @returns contract info.
   */
  ;
  _proto.fetchContractInfo =
  /*#__PURE__*/
  function () {
    var _fetchContractInfo = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(contractAddress) {
      var request, response, contractInfo;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            request = new QueryAllContractStateRequest();
            request.setAddress(contractAddress);
            _context2.prev = 2;
            _context2.next = 5;
            return this.request(request, Query$7.ContractInfo);
          case 5:
            response = _context2.sent;
            contractInfo = response.getContractInfo();
            if (contractInfo) {
              _context2.next = 9;
              break;
            }
            return _context2.abrupt("return");
          case 9:
            return _context2.abrupt("return", ChainGrpcWasmTransformer.contactInfoResponseToContractInfo(contractInfo));
          case 12:
            _context2.prev = 12;
            _context2.t0 = _context2["catch"](2);
            if (!(_context2.t0 instanceof GrpcUnaryRequestException)) {
              _context2.next = 16;
              break;
            }
            throw _context2.t0;
          case 16:
            throw new GrpcUnaryRequestException(_context2.t0, {
              code: UnspecifiedErrorCode,
              contextModule: this.module
            });
          case 17:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[2, 12]]);
    }));
    function fetchContractInfo(_x2) {
      return _fetchContractInfo.apply(this, arguments);
    }
    return fetchContractInfo;
  }()
  /**
   * Get contract's history.
   *
   * @param contractAddress contract address.
   * @returns contract history.
   */
  ;
  _proto.fetchContractHistory =
  /*#__PURE__*/
  function () {
    var _fetchContractHistory = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(contractAddress) {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            request = new QueryContractHistoryRequest();
            request.setAddress(contractAddress);
            _context3.prev = 2;
            _context3.next = 5;
            return this.request(request, Query$7.ContractHistory);
          case 5:
            response = _context3.sent;
            return _context3.abrupt("return", ChainGrpcWasmTransformer.contactHistoryResponseToContractHistory(response));
          case 9:
            _context3.prev = 9;
            _context3.t0 = _context3["catch"](2);
            if (!(_context3.t0 instanceof GrpcUnaryRequestException)) {
              _context3.next = 13;
              break;
            }
            throw _context3.t0;
          case 13:
            throw new GrpcUnaryRequestException(_context3.t0, {
              code: UnspecifiedErrorCode,
              contextModule: this.module
            });
          case 14:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this, [[2, 9]]);
    }));
    function fetchContractHistory(_x3) {
      return _fetchContractHistory.apply(this, arguments);
    }
    return fetchContractHistory;
  }()
  /**
   * Get contract's state of the query made.
   *
   * @param contractAddress contract address.
   * @param queryData query data.
   * @returns smart contract state data.
   */
  ;
  _proto.fetchSmartContractState =
  /*#__PURE__*/
  function () {
    var _fetchSmartContractState = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(contractAddress, query) {
      var request, response, _response$toObject, data, responseText;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            request = new QuerySmartContractStateRequest();
            request.setAddress(contractAddress);
            if (query) {
              request.setQueryData(query);
            }
            _context4.prev = 3;
            _context4.next = 6;
            return this.request(request, Query$7.SmartContractState);
          case 6:
            response = _context4.sent;
            _response$toObject = response.toObject(), data = _response$toObject.data;
            responseText = fromBase64(data.toString());
            return _context4.abrupt("return", {
              data: responseText
            });
          case 12:
            _context4.prev = 12;
            _context4.t0 = _context4["catch"](3);
            if (!(_context4.t0 instanceof GrpcUnaryRequestException)) {
              _context4.next = 16;
              break;
            }
            throw _context4.t0;
          case 16:
            throw new GrpcUnaryRequestException(_context4.t0, {
              code: UnspecifiedErrorCode,
              contextModule: this.module
            });
          case 17:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this, [[3, 12]]);
    }));
    function fetchSmartContractState(_x4, _x5) {
      return _fetchSmartContractState.apply(this, arguments);
    }
    return fetchSmartContractState;
  }()
  /**
   *
   * @param contractAddress contract address.
   * @param queryData query data.
   * @returns raw contract state data.
   */
  ;
  _proto.fetchRawContractState =
  /*#__PURE__*/
  function () {
    var _fetchRawContractState = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(contractAddress, query) {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            request = new QueryRawContractStateRequest();
            request.setAddress(contractAddress);
            if (query) {
              request.setQueryData(query);
            }
            _context5.prev = 3;
            _context5.next = 6;
            return this.request(request, Query$7.RawContractState);
          case 6:
            response = _context5.sent;
            return _context5.abrupt("return", response.toObject());
          case 10:
            _context5.prev = 10;
            _context5.t0 = _context5["catch"](3);
            if (!(_context5.t0 instanceof GrpcUnaryRequestException)) {
              _context5.next = 14;
              break;
            }
            throw _context5.t0;
          case 14:
            throw new GrpcUnaryRequestException(_context5.t0, {
              code: UnspecifiedErrorCode,
              contextModule: this.module
            });
          case 15:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this, [[3, 10]]);
    }));
    function fetchRawContractState(_x6, _x7) {
      return _fetchRawContractState.apply(this, arguments);
    }
    return fetchRawContractState;
  }();
  _proto.fetchContractCodes = /*#__PURE__*/function () {
    var _fetchContractCodes = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(pagination) {
      var request, paginationForRequest, response;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            request = new QueryCodesRequest();
            paginationForRequest = paginationRequestFromPagination(pagination);
            if (paginationForRequest) {
              request.setPagination(paginationForRequest);
            }
            _context6.prev = 3;
            _context6.next = 6;
            return this.request(request, Query$7.Codes);
          case 6:
            response = _context6.sent;
            return _context6.abrupt("return", ChainGrpcWasmTransformer.contractCodesResponseToContractCodes(response));
          case 10:
            _context6.prev = 10;
            _context6.t0 = _context6["catch"](3);
            if (!(_context6.t0 instanceof GrpcUnaryRequestException)) {
              _context6.next = 14;
              break;
            }
            throw _context6.t0;
          case 14:
            throw new GrpcUnaryRequestException(_context6.t0, {
              code: UnspecifiedErrorCode,
              contextModule: this.module
            });
          case 15:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this, [[3, 10]]);
    }));
    function fetchContractCodes(_x8) {
      return _fetchContractCodes.apply(this, arguments);
    }
    return fetchContractCodes;
  }();
  _proto.fetchContractCode = /*#__PURE__*/function () {
    var _fetchContractCode = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(codeId) {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            request = new QueryCodeRequest();
            request.setCodeId(codeId);
            _context7.prev = 2;
            _context7.next = 5;
            return this.request(request, Query$7.Code);
          case 5:
            response = _context7.sent;
            return _context7.abrupt("return", ChainGrpcWasmTransformer.contractCodeResponseToContractCode(response));
          case 9:
            _context7.prev = 9;
            _context7.t0 = _context7["catch"](2);
            if (!(_context7.t0 instanceof GrpcUnaryRequestException)) {
              _context7.next = 13;
              break;
            }
            throw _context7.t0;
          case 13:
            throw new GrpcUnaryRequestException(_context7.t0, {
              code: UnspecifiedErrorCode,
              contextModule: this.module
            });
          case 14:
          case "end":
            return _context7.stop();
        }
      }, _callee7, this, [[2, 9]]);
    }));
    function fetchContractCode(_x9) {
      return _fetchContractCode.apply(this, arguments);
    }
    return fetchContractCode;
  }();
  _proto.fetchContractCodeContracts = /*#__PURE__*/function () {
    var _fetchContractCodeContracts = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(codeId, pagination) {
      var request, paginationForRequest, response;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            request = new QueryContractsByCodeRequest();
            request.setCodeId(codeId);
            paginationForRequest = paginationRequestFromPagination(pagination);
            if (paginationForRequest) {
              request.setPagination(paginationForRequest);
            }
            _context8.prev = 4;
            _context8.next = 7;
            return this.request(request, Query$7.ContractsByCode);
          case 7:
            response = _context8.sent;
            return _context8.abrupt("return", ChainGrpcWasmTransformer.contractByCodeResponseToContractByCode(response));
          case 11:
            _context8.prev = 11;
            _context8.t0 = _context8["catch"](4);
            if (!(_context8.t0 instanceof GrpcUnaryRequestException)) {
              _context8.next = 15;
              break;
            }
            throw _context8.t0;
          case 15:
            throw new GrpcUnaryRequestException(_context8.t0, {
              code: UnspecifiedErrorCode,
              contextModule: this.module
            });
          case 16:
          case "end":
            return _context8.stop();
        }
      }, _callee8, this, [[4, 11]]);
    }));
    function fetchContractCodeContracts(_x10, _x11) {
      return _fetchContractCodeContracts.apply(this, arguments);
    }
    return fetchContractCodeContracts;
  }();
  return ChainGrpcWasmApi;
}(BaseGrpcConsumer);

/**
 * The Attestation module is responsible for Valset (Validator set) and vote management.
 *
 * @group gRPC API
 *
 * @example
 * To use Attestation methods, initialise a {@link ChainGrpcAttestationApi} object to with a gRPC endpoint. An endpoint can be retrieved by using {@link networkEndpoints}.
 * ```ts
 * const endpoint =  getEndpointsForNetwork(Network.Devnet).grpcEndpoint;
 * const client = new ChainGrpcAttestationApi(endpoint.grpcEndpoint);
 * const response = await client.fetchLatestValsetNonce();
 * ```
 */
var ChainGrpcAttestationApi = /*#__PURE__*/function (_BaseConsumer) {
  _inheritsLoose(ChainGrpcAttestationApi, _BaseConsumer);
  function ChainGrpcAttestationApi() {
    return _BaseConsumer.apply(this, arguments) || this;
  }
  var _proto = ChainGrpcAttestationApi.prototype;
  /**
   * Fetch latest valset nonce
   * @returns latest valset nonce.
   */
  _proto.fetchLatestValsetNonce =
  /*#__PURE__*/
  function () {
    var _fetchLatestValsetNonce = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            request = new QueryLatestValsetNonceRequest();
            _context.prev = 1;
            _context.next = 4;
            return this.request(request, Query$8.LatestValsetNonce);
          case 4:
            response = _context.sent;
            return _context.abrupt("return", ChainGrpcAttestationTransformer.latestValsetNonce(response));
          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](1);
            throw new Error(_context.t0.message);
          case 11:
          case "end":
            return _context.stop();
        }
      }, _callee, this, [[1, 8]]);
    }));
    function fetchLatestValsetNonce() {
      return _fetchLatestValsetNonce.apply(this, arguments);
    }
    return fetchLatestValsetNonce;
  }()
  /**
   * Fetches all valsets
   * @returns all valsets.
   */
  ;
  _proto.fetchAllValsets =
  /*#__PURE__*/
  function () {
    var _fetchAllValsets = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            request = new QueryAllValsetRequest();
            _context2.prev = 1;
            _context2.next = 4;
            return this.request(request, Query$8.ValsetAll);
          case 4:
            response = _context2.sent;
            return _context2.abrupt("return", ChainGrpcAttestationTransformer.allValset(response));
          case 8:
            _context2.prev = 8;
            _context2.t0 = _context2["catch"](1);
            throw new Error(_context2.t0.message);
          case 11:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[1, 8]]);
    }));
    function fetchAllValsets() {
      return _fetchAllValsets.apply(this, arguments);
    }
    return fetchAllValsets;
  }()
  /**
   *
   * @param valsetNonce nonce of valset.
   * @returns valset.
   */
  ;
  _proto.fetchValsetByNonce =
  /*#__PURE__*/
  function () {
    var _fetchValsetByNonce = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(valsetNonce) {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            request = new QueryGetValsetRequest();
            request.setNonce(valsetNonce);
            _context3.prev = 2;
            _context3.next = 5;
            return this.request(request, Query$8.Valset);
          case 5:
            response = _context3.sent;
            return _context3.abrupt("return", ChainGrpcAttestationTransformer.valsetByNonce(response));
          case 9:
            _context3.prev = 9;
            _context3.t0 = _context3["catch"](2);
            throw new Error(_context3.t0.message);
          case 12:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this, [[2, 9]]);
    }));
    function fetchValsetByNonce(_x) {
      return _fetchValsetByNonce.apply(this, arguments);
    }
    return fetchValsetByNonce;
  }()
  /**
   *
   * @returns latest valset.
   */
  ;
  _proto.fetchLatestValset =
  /*#__PURE__*/
  function () {
    var _fetchLatestValset = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            request = new QueryLatestValsetRequest();
            _context4.prev = 1;
            _context4.next = 4;
            return this.request(request, Query$8.LatestValset);
          case 4:
            response = _context4.sent;
            return _context4.abrupt("return", ChainGrpcAttestationTransformer.latestValset(response));
          case 8:
            _context4.prev = 8;
            _context4.t0 = _context4["catch"](1);
            throw new Error(_context4.t0.message);
          case 11:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this, [[1, 8]]);
    }));
    function fetchLatestValset() {
      return _fetchLatestValset.apply(this, arguments);
    }
    return fetchLatestValset;
  }()
  /**
   *
   * @param chainType chain type.
   * @param chainId chain ID.
   * @param valAddress validator address.
   * @returns last event nonce for a validator.
   */
  ;
  _proto.fetchLastEventByValidator =
  /*#__PURE__*/
  function () {
    var _fetchLastEventByValidator = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(chainId, valAddress) {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            request = new QueryLastEventNonceRequest();
            request.setChainId(chainId);
            request.setValidatorAddress(valAddress);
            _context5.prev = 3;
            _context5.next = 6;
            return this.request(request, Query$8.LastEventNonce);
          case 6:
            response = _context5.sent;
            return _context5.abrupt("return", ChainGrpcAttestationTransformer.lastEventByValidator(response));
          case 10:
            _context5.prev = 10;
            _context5.t0 = _context5["catch"](3);
            throw new Error(_context5.t0.message);
          case 13:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this, [[3, 10]]);
    }));
    function fetchLastEventByValidator(_x2, _x3) {
      return _fetchLastEventByValidator.apply(this, arguments);
    }
    return fetchLastEventByValidator;
  }()
  /**
   *
   * @returns list of all orchestrators.
   */
  ;
  _proto.fetchAllOrchestrators =
  /*#__PURE__*/
  function () {
    var _fetchAllOrchestrators = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            request = new QueryListOrchestratorsRequest();
            _context6.prev = 1;
            _context6.next = 4;
            return this.request(request, Query$8.ListOrchestrators);
          case 4:
            response = _context6.sent;
            return _context6.abrupt("return", ChainGrpcAttestationTransformer.listOrchestrators(response));
          case 8:
            _context6.prev = 8;
            _context6.t0 = _context6["catch"](1);
            throw new Error(_context6.t0.message);
          case 11:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this, [[1, 8]]);
    }));
    function fetchAllOrchestrators() {
      return _fetchAllOrchestrators.apply(this, arguments);
    }
    return fetchAllOrchestrators;
  }();
  return ChainGrpcAttestationApi;
}(BaseGrpcConsumer);

/**
 * The Multichain module is responsible for persisting the configuration of all supported chains by the Router chain and provides chain configuration related methods.
 *
 * @group gRPC API
 *
 * @example
 * To use Multichain methods, initialise a {@link ChainGrpcMultiChainApi} object to with a gRPC endpoint. An endpoint can be retrieved by using {@link networkEndpoints}.
 * ```ts
 * const endpoint =  getEndpointsForNetwork(Network.Devnet).grpcEndpoint;
 * const bankClient = new ChainGrpcMultiChainApi(endpoint.grpcEndpoint);
 * const response = await bankClient.fetchAllChainConfig();
 * ```
 */
var ChainGrpcMultiChainApi = /*#__PURE__*/function (_BaseConsumer) {
  _inheritsLoose(ChainGrpcMultiChainApi, _BaseConsumer);
  function ChainGrpcMultiChainApi() {
    return _BaseConsumer.apply(this, arguments) || this;
  }
  var _proto = ChainGrpcMultiChainApi.prototype;
  /**
   *
   * @param chainType chain type.
   * @param chainId chain ID.
   * @returns chain configuration.
   */
  _proto.fetchChainConfig =
  /*#__PURE__*/
  function () {
    var _fetchChainConfig = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(chainId) {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            request = new QueryGetChainConfigRequest();
            request.setChainId(chainId);
            _context.prev = 2;
            _context.next = 5;
            return this.request(request, Query$9.ChainConfig);
          case 5:
            response = _context.sent;
            return _context.abrupt("return", response.toObject());
          case 9:
            _context.prev = 9;
            _context.t0 = _context["catch"](2);
            throw new Error(_context.t0.message);
          case 12:
          case "end":
            return _context.stop();
        }
      }, _callee, this, [[2, 9]]);
    }));
    function fetchChainConfig(_x) {
      return _fetchChainConfig.apply(this, arguments);
    }
    return fetchChainConfig;
  }()
  /**
   *
   * @returns chain configuration list for all supported chains.
   */
  ;
  _proto.fetchAllChainConfig =
  /*#__PURE__*/
  function () {
    var _fetchAllChainConfig = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            request = new QueryAllChainConfigRequest();
            _context2.prev = 1;
            _context2.next = 4;
            return this.request(request, Query$9.ChainConfigAll);
          case 4:
            response = _context2.sent;
            return _context2.abrupt("return", response.toObject());
          case 8:
            _context2.prev = 8;
            _context2.t0 = _context2["catch"](1);
            throw new Error(_context2.t0.message);
          case 11:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[1, 8]]);
    }));
    function fetchAllChainConfig() {
      return _fetchAllChainConfig.apply(this, arguments);
    }
    return fetchAllChainConfig;
  }()
  /**
   *
   * @param chainId
   * @returns
   */
  ;
  _proto.fetchContractConfig =
  /*#__PURE__*/
  function () {
    var _fetchContractConfig = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(chainId) {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            request = new QueryAllContractConfigByChainIdRequest();
            request.setChainId(chainId);
            _context3.prev = 2;
            _context3.next = 5;
            return this.request(request, Query$9.ContractConfigByChainId);
          case 5:
            response = _context3.sent;
            return _context3.abrupt("return", response.toObject());
          case 9:
            _context3.prev = 9;
            _context3.t0 = _context3["catch"](2);
            throw new Error(_context3.t0.message);
          case 12:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this, [[2, 9]]);
    }));
    function fetchContractConfig(_x2) {
      return _fetchContractConfig.apply(this, arguments);
    }
    return fetchContractConfig;
  }()
  /**
   *
   * @returns
   */
  ;
  _proto.fetchAllContractConfig =
  /*#__PURE__*/
  function () {
    var _fetchAllContractConfig = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            request = new QueryAllContractConfigRequest();
            _context4.prev = 1;
            _context4.next = 4;
            return this.request(request, Query$9.ContractConfigAll);
          case 4:
            response = _context4.sent;
            return _context4.abrupt("return", response.toObject());
          case 8:
            _context4.prev = 8;
            _context4.t0 = _context4["catch"](1);
            throw new Error(_context4.t0.message);
          case 11:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this, [[1, 8]]);
    }));
    function fetchAllContractConfig() {
      return _fetchAllContractConfig.apply(this, arguments);
    }
    return fetchAllContractConfig;
  }();
  return ChainGrpcMultiChainApi;
}(BaseGrpcConsumer);

/**
 * The Crosschain module is responsible for handling inbound, outbound and crosstalk requests.
 *
 * @group gRPC API
 *
 * @example
 * To use Crosschain methods, initialise a {@link ChainGrpcCrosschainApi} object to with a gRPC endpoint. An endpoint can be retrieved by using {@link networkEndpoints}.
 * ```ts
 * const endpoint =  getEndpointsForNetwork(Network.Devnet).grpcEndpoint;
 * const client = new ChainGrpcCrosschainApi(endpoint);
 * const response = await client.fetchCrosschainRequests();
 * ```
 */
var ChainGrpcCrosschainApi = /*#__PURE__*/function (_BaseConsumer) {
  _inheritsLoose(ChainGrpcCrosschainApi, _BaseConsumer);
  function ChainGrpcCrosschainApi() {
    return _BaseConsumer.apply(this, arguments) || this;
  }
  var _proto = ChainGrpcCrosschainApi.prototype;
  /**
   * Fetches all crosschain requests
   * @param pageRequestObject
   * @returns
   */
  _proto.fetchCrosschainRequests =
  /*#__PURE__*/
  function () {
    var _fetchCrosschainRequests = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(pageRequestObject) {
      var request, pageRequest, response;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            request = new QueryAllCrosschainRequestRequest(); // TODO: refactor to common transform
            if (pageRequestObject != null) {
              pageRequest = new PageRequest();
              pageRequest.setKey(pageRequestObject.key);
              pageRequest.setOffset(pageRequestObject.offset);
              pageRequest.setLimit(pageRequestObject.offset);
              pageRequest.setCountTotal(pageRequestObject.countTotal);
              pageRequest.setReverse(pageRequestObject.reverse);
              request.setPagination(pageRequest);
            }
            _context.prev = 2;
            _context.next = 5;
            return this.request(request, Query$a.CrosschainRequestAll);
          case 5:
            response = _context.sent;
            return _context.abrupt("return", response.toObject());
          case 9:
            _context.prev = 9;
            _context.t0 = _context["catch"](2);
            throw new Error(_context.t0.message);
          case 12:
          case "end":
            return _context.stop();
        }
      }, _callee, this, [[2, 9]]);
    }));
    function fetchCrosschainRequests(_x) {
      return _fetchCrosschainRequests.apply(this, arguments);
    }
    return fetchCrosschainRequests;
  }()
  /**
   * Fetch crosschain request confirmations
   * @param sourceChainId
   * @param requestIdentifier
   * @param claimHash
   * @param pageRequestObject
   * @returns
   */
  ;
  _proto.fetchCrosschainRequestConfirmations =
  /*#__PURE__*/
  function () {
    var _fetchCrosschainRequestConfirmations = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(sourceChainId, requestIdentifier, claimHash, pageRequestObject) {
      var request, pageRequest, response;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            request = new QueryAllCrosschainRequestConfirmRequest();
            request.setSourcechainid(sourceChainId);
            request.setRequestidentifier(requestIdentifier);
            request.setClaimhash(claimHash);
            // TODO: refactor to common transform
            if (pageRequestObject != null) {
              pageRequest = new PageRequest();
              pageRequest.setKey(pageRequestObject.key);
              pageRequest.setOffset(pageRequestObject.offset);
              pageRequest.setLimit(pageRequestObject.offset);
              pageRequest.setCountTotal(pageRequestObject.countTotal);
              pageRequest.setReverse(pageRequestObject.reverse);
              request.setPagination(pageRequest);
            }
            _context2.prev = 5;
            _context2.next = 8;
            return this.request(request, Query$a.CrosschainRequestConfirmAll);
          case 8:
            response = _context2.sent;
            return _context2.abrupt("return", response.toObject());
          case 12:
            _context2.prev = 12;
            _context2.t0 = _context2["catch"](5);
            throw new Error(_context2.t0.message);
          case 15:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[5, 12]]);
    }));
    function fetchCrosschainRequestConfirmations(_x2, _x3, _x4, _x5) {
      return _fetchCrosschainRequestConfirmations.apply(this, arguments);
    }
    return fetchCrosschainRequestConfirmations;
  }()
  /**
   * Fetch crosschain ack requests
   * @param pageRequestObject
   * @returns
   */
  ;
  _proto.fetchCrosschainAckRequests =
  /*#__PURE__*/
  function () {
    var _fetchCrosschainAckRequests = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(pageRequestObject) {
      var request, pageRequest, response;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            request = new QueryAllCrosschainAckRequestRequest();
            if (pageRequestObject != null) {
              pageRequest = new PageRequest();
              pageRequest.setKey(pageRequestObject.key);
              pageRequest.setOffset(pageRequestObject.offset);
              pageRequest.setLimit(pageRequestObject.offset);
              pageRequest.setCountTotal(pageRequestObject.countTotal);
              pageRequest.setReverse(pageRequestObject.reverse);
              request.setPagination(pageRequest);
            }
            _context3.prev = 2;
            _context3.next = 5;
            return this.request(request, Query$a.CrosschainAckRequestAll);
          case 5:
            response = _context3.sent;
            return _context3.abrupt("return", response.toObject());
          case 9:
            _context3.prev = 9;
            _context3.t0 = _context3["catch"](2);
            throw new Error(_context3.t0.message);
          case 12:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this, [[2, 9]]);
    }));
    function fetchCrosschainAckRequests(_x6) {
      return _fetchCrosschainAckRequests.apply(this, arguments);
    }
    return fetchCrosschainAckRequests;
  }()
  /**
   * Fetch crosschain ack request confirmations
   * @param sourceChainId
   * @param requestIdentifier
   * @param claimHash
   * @param pageRequestObject
   * @returns
   */
  ;
  _proto.fetchCrosschainAckRequestConfirmations =
  /*#__PURE__*/
  function () {
    var _fetchCrosschainAckRequestConfirmations = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(sourceChainId, requestIdentifier, claimHash, pageRequestObject) {
      var request, pageRequest, response;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            request = new QueryAllCrosschainAckRequestConfirmRequest();
            request.setAcksrcchainid(sourceChainId);
            request.setAckrequestidentifier(requestIdentifier);
            request.setClaimhash(claimHash);
            // TODO: refactor to common transform
            if (pageRequestObject != null) {
              pageRequest = new PageRequest();
              pageRequest.setKey(pageRequestObject.key);
              pageRequest.setOffset(pageRequestObject.offset);
              pageRequest.setLimit(pageRequestObject.offset);
              pageRequest.setCountTotal(pageRequestObject.countTotal);
              pageRequest.setReverse(pageRequestObject.reverse);
              request.setPagination(pageRequest);
            }
            _context4.prev = 5;
            _context4.next = 8;
            return this.request(request, Query$a.CrosschainAckRequestConfirmAll);
          case 8:
            response = _context4.sent;
            return _context4.abrupt("return", response.toObject());
          case 12:
            _context4.prev = 12;
            _context4.t0 = _context4["catch"](5);
            throw new Error(_context4.t0.message);
          case 15:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this, [[5, 12]]);
    }));
    function fetchCrosschainAckRequestConfirmations(_x7, _x8, _x9, _x10) {
      return _fetchCrosschainAckRequestConfirmations.apply(this, arguments);
    }
    return fetchCrosschainAckRequestConfirmations;
  }()
  /**
   * Fetch crosschain request confirmation
   * @param sourceChainId
   * @param requestIdentifier
   * @param claimHash
   * @param orchestrator
   * @returns
   */
  ;
  _proto.fetchCrosschainRequestConfirmation =
  /*#__PURE__*/
  function () {
    var _fetchCrosschainRequestConfirmation = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(sourceChainId, requestIdentifier, claimHash, orchestrator) {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            request = new QueryGetCrosschainRequestConfirmRequest();
            request.setSourcechainid(sourceChainId);
            request.setRequestidentifier(requestIdentifier);
            request.setClaimhash(claimHash);
            request.setOrchestrator(orchestrator);
            _context5.prev = 5;
            _context5.next = 8;
            return this.request(request, Query$a.CrosschainRequestConfirm);
          case 8:
            response = _context5.sent;
            return _context5.abrupt("return", response.toObject());
          case 12:
            _context5.prev = 12;
            _context5.t0 = _context5["catch"](5);
            throw new Error(_context5.t0.message);
          case 15:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this, [[5, 12]]);
    }));
    function fetchCrosschainRequestConfirmation(_x11, _x12, _x13, _x14) {
      return _fetchCrosschainRequestConfirmation.apply(this, arguments);
    }
    return fetchCrosschainRequestConfirmation;
  }()
  /**
   * Fetch crosschain ack request confirmation
   * @param sourceChainId
   * @param requestIdentifier
   * @param claimHash
   * @param orchestrator
   * @returns
   */
  ;
  _proto.fetchCrosschainAckRequestConfirmation =
  /*#__PURE__*/
  function () {
    var _fetchCrosschainAckRequestConfirmation = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(sourceChainId, requestIdentifier, claimHash, orchestrator) {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            request = new QueryGetCrosschainAckRequestConfirmRequest();
            request.setAcksrcchainid(sourceChainId);
            request.setAckrequestidentifier(requestIdentifier);
            request.setClaimhash(claimHash);
            request.setOrchestrator(orchestrator);
            _context6.prev = 5;
            _context6.next = 8;
            return this.request(request, Query$a.CrosschainAckRequestConfirm);
          case 8:
            response = _context6.sent;
            return _context6.abrupt("return", response.toObject());
          case 12:
            _context6.prev = 12;
            _context6.t0 = _context6["catch"](5);
            throw new Error(_context6.t0.message);
          case 15:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this, [[5, 12]]);
    }));
    function fetchCrosschainAckRequestConfirmation(_x15, _x16, _x17, _x18) {
      return _fetchCrosschainAckRequestConfirmation.apply(this, arguments);
    }
    return fetchCrosschainAckRequestConfirmation;
  }()
  /**
   * fetch CrosschainAckRequestConfirmation
   *
   * @param sourceChainId
   * @param requestIdentifier
   * @returns
   */
  ;
  _proto.fetchCrosschainAckRequest =
  /*#__PURE__*/
  function () {
    var _fetchCrosschainAckRequest = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(sourceChainId, requestIdentifier) {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            request = new QueryGetCrosschainAckRequestConfirmRequest();
            request.setAcksrcchainid(sourceChainId);
            request.setAckrequestidentifier(requestIdentifier);
            _context7.prev = 3;
            _context7.next = 6;
            return this.request(request, Query$a.CrosschainAckRequest);
          case 6:
            response = _context7.sent;
            return _context7.abrupt("return", response.toObject());
          case 10:
            _context7.prev = 10;
            _context7.t0 = _context7["catch"](3);
            throw new Error(_context7.t0.message);
          case 13:
          case "end":
            return _context7.stop();
        }
      }, _callee7, this, [[3, 10]]);
    }));
    function fetchCrosschainAckRequest(_x19, _x20) {
      return _fetchCrosschainAckRequest.apply(this, arguments);
    }
    return fetchCrosschainAckRequest;
  }()
  /**
   * fetch CrosschainRequest
   *
   * @param sourceChainId
   * @param requestIdentifier
   * @returns
   */
  ;
  _proto.fetchCrosschainRequest =
  /*#__PURE__*/
  function () {
    var _fetchCrosschainRequest = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(sourceChainId, requestIdentifier) {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            request = new QueryGetCrosschainRequestRequest();
            request.setSourcechainid(sourceChainId);
            request.setRequestidentifier(requestIdentifier);
            _context8.prev = 3;
            _context8.next = 6;
            return this.request(request, Query$a.CrosschainRequest);
          case 6:
            response = _context8.sent;
            return _context8.abrupt("return", response.toObject());
          case 10:
            _context8.prev = 10;
            _context8.t0 = _context8["catch"](3);
            throw new Error(_context8.t0.message);
          case 13:
          case "end":
            return _context8.stop();
        }
      }, _callee8, this, [[3, 10]]);
    }));
    function fetchCrosschainRequest(_x21, _x22) {
      return _fetchCrosschainRequest.apply(this, arguments);
    }
    return fetchCrosschainRequest;
  }()
  /**
   * fetch CrosschainAckReceipt
   *
   * @param ackReceiptSrcChainId
   * @param ackReceiptIdentifier
   * @returns
   */
  ;
  _proto.fetchCrosschainAckReceipt =
  /*#__PURE__*/
  function () {
    var _fetchCrosschainAckReceipt = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(ackReceiptSrcChainId, ackReceiptIdentifier) {
      var request, response;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            request = new QueryGetCrosschainAckReceiptRequest();
            request.setAckreceiptsrcchainid(ackReceiptSrcChainId);
            request.setAckreceiptidentifier(ackReceiptIdentifier);
            _context9.prev = 3;
            _context9.next = 6;
            return this.request(request, Query$a.CrosschainAckReceipt);
          case 6:
            response = _context9.sent;
            return _context9.abrupt("return", response.toObject());
          case 10:
            _context9.prev = 10;
            _context9.t0 = _context9["catch"](3);
            throw new Error(_context9.t0.message);
          case 13:
          case "end":
            return _context9.stop();
        }
      }, _callee9, this, [[3, 10]]);
    }));
    function fetchCrosschainAckReceipt(_x23, _x24) {
      return _fetchCrosschainAckReceipt.apply(this, arguments);
    }
    return fetchCrosschainAckReceipt;
  }();
  return ChainGrpcCrosschainApi;
}(BaseGrpcConsumer);

/**
 * @group REST API
 */
var ChainRestTendermintApi = /*#__PURE__*/function (_BaseRestConsumer) {
  _inheritsLoose(ChainRestTendermintApi, _BaseRestConsumer);
  function ChainRestTendermintApi() {
    return _BaseRestConsumer.apply(this, arguments) || this;
  }
  var _proto = ChainRestTendermintApi.prototype;
  /**
   * Fetches latest block.
   */
  _proto.fetchLatestBlock =
  /*#__PURE__*/
  function () {
    var _fetchLatestBlock = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var _yield$this$client$ge, data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return this.client.get("cosmos/base/tendermint/v1beta1/blocks/latest");
          case 2:
            _yield$this$client$ge = _context.sent;
            data = _yield$this$client$ge.data;
            return _context.abrupt("return", data.block);
          case 5:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function fetchLatestBlock() {
      return _fetchLatestBlock.apply(this, arguments);
    }
    return fetchLatestBlock;
  }()
  /**
   * Fetches node info.
   */
  ;
  _proto.fetchNodeInfo =
  /*#__PURE__*/
  function () {
    var _fetchNodeInfo = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var _yield$this$client$ge2, data;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return this.client.get("cosmos/base/tendermint/v1beta1/node_info");
          case 2:
            _yield$this$client$ge2 = _context2.sent;
            data = _yield$this$client$ge2.data;
            return _context2.abrupt("return", {
              nodeInfo: data.default_node_info,
              applicationVersion: data.application_version
            });
          case 5:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function fetchNodeInfo() {
      return _fetchNodeInfo.apply(this, arguments);
    }
    return fetchNodeInfo;
  }();
  return ChainRestTendermintApi;
}(BaseRestConsumer);

var getMappedTokensByAddress = function getMappedTokensByAddress(tokens) {
  return Object.keys(tokens).filter(function (token) {
    return !!tokens[token].address;
  }).reduce(function (result, token) {
    var _extends2;
    return _extends({}, result, (_extends2 = {}, _extends2[tokens[token].address.toLowerCase()] = tokens[token], _extends2));
  }, {});
};

var TokenMetaUtil = /*#__PURE__*/function () {
  function TokenMetaUtil(tokens) {
    this.tokens = tokens;
    this.tokensByAddress = getMappedTokensByAddress(tokens);
  }
  var _proto = TokenMetaUtil.prototype;
  _proto.getMetaBySymbol = function getMetaBySymbol(symbol) {
    var tokensBySymbol = this.tokens;
    var tokenSymbol = symbol.toUpperCase();
    if (!tokensBySymbol[tokenSymbol]) {
      return;
    }
    return tokensBySymbol[tokenSymbol];
  };
  _proto.getMetaByAddress = function getMetaByAddress(address) {
    var tokensByAddress = this.tokensByAddress;
    var erc20Address = address.toLowerCase();
    if (!tokensByAddress[erc20Address]) {
      return;
    }
    return tokensByAddress[erc20Address];
  };
  _proto.getCoinGeckoIdFromSymbol = function getCoinGeckoIdFromSymbol(symbol) {
    var tokensBySymbol = this.tokens;
    var symbolToUppercase = symbol.toUpperCase();
    if (!tokensBySymbol[symbolToUppercase]) {
      return '';
    }
    return tokensBySymbol[symbolToUppercase].coinGeckoId || '';
  };
  return TokenMetaUtil;
}();

var tokens = {
  BTC: {
    name: 'Bitcoin',
    logo: 'bitcoin.svg',
    symbol: 'BTC',
    decimals: 8,
    address: '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599',
    coinGeckoId: 'bitcoin'
  },
  wBTC: {
    name: 'Wrapped Bitcoin',
    logo: 'wbtc.svg',
    symbol: 'wBTC',
    decimals: 8,
    address: '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599',
    coinGeckoId: 'wrapped-bitcoin'
  },
  WBTC: {
    name: 'Wrapped Bitcoin',
    logo: 'wbtc.svg',
    symbol: 'wBTC',
    decimals: 8,
    address: '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599',
    coinGeckoId: 'wrapped-bitcoin'
  },
  ETH: {
    name: 'Ethereum',
    logo: 'ethereum.svg',
    symbol: 'ETH',
    decimals: 18,
    address: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    coinGeckoId: 'ethereum'
  },
  WETH: {
    name: 'Wrapped Ethereum',
    logo: 'ethereum.svg',
    symbol: 'wETH',
    decimals: 18,
    address: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    coinGeckoId: 'ethereum'
  },
  wETH: {
    name: 'Wrapped Ethereum',
    logo: 'ethereum.svg',
    symbol: 'wETH',
    decimals: 18,
    address: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    coinGeckoId: 'ethereum'
  },
  INJ: {
    name: 'Injective',
    logo: 'injective-v3.svg',
    symbol: 'INJ',
    decimals: 18,
    address: '0xe28b3b32b6c345a34ff64674606124dd5aceca30',
    coinGeckoId: 'injective-protocol'
  },
  USDT: {
    name: 'Tether',
    logo: 'usdt.svg',
    symbol: 'USDT',
    decimals: 6,
    address: '0xdac17f958d2ee523a2206206994597c13d831ec7',
    coinGeckoId: 'tether'
  },
  USDC: {
    name: 'USD Coin',
    logo: 'usdc.svg',
    symbol: 'USDC',
    decimals: 6,
    address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
    coinGeckoId: 'usd-coin'
  },
  GRT: {
    name: 'Graph Token',
    logo: 'graphToken.svg',
    symbol: 'GRT',
    decimals: 18,
    address: '0xc944e90c64b2c07662a292be6244bdf05cda44a7',
    coinGeckoId: 'the-graph'
  },
  SNX: {
    name: 'Synthetix Network Token',
    logo: 'synthetix.svg',
    decimals: 18,
    symbol: 'SNX',
    address: '0xc011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f',
    coinGeckoId: 'havven'
  },
  BNB: {
    name: 'Binance Coin',
    logo: 'bnb.svg',
    decimals: 18,
    symbol: 'BNB',
    address: '0xb8c77482e45f1f44de1745f52c74426c631bdd52',
    coinGeckoId: 'binancecoin'
  },
  AAVE: {
    name: 'Aave',
    logo: 'AAVE.svg',
    symbol: 'AAVE',
    decimals: 18,
    address: '0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9',
    coinGeckoId: 'aave'
  },
  YFI: {
    name: 'yearn.finance',
    logo: 'yfi.svg',
    symbol: 'YFI',
    decimals: 18,
    address: '0x0bc529c00c6401aef6d220be8c6ea1667f6ad93e',
    coinGeckoId: 'yearn-finance'
  },
  COMP: {
    name: 'Compound',
    logo: 'comp.svg',
    symbol: 'COMP',
    decimals: 18,
    address: '0xc00e94cb662c3520282e6f5717214004a7f26888',
    coinGeckoId: 'compound-coin'
  },
  ZRX: {
    name: '0x',
    logo: 'zrx.svg',
    symbol: 'ZRX',
    decimals: 18,
    address: '0xe41d2489571d322189246dafa5ebde1f4699f498',
    coinGeckoId: '0x'
  },
  MATIC: {
    name: 'Polygon',
    logo: 'matic.svg',
    symbol: 'MATIC',
    decimals: 18,
    address: '0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0',
    coinGeckoId: 'matic-network'
  },
  UNI: {
    name: 'Uniswap',
    logo: 'uni.svg',
    symbol: 'UNI',
    decimals: 18,
    address: '0x1f9840a85d5af5bf1d1762f925bdaddc4201f984',
    coinGeckoId: 'uniswap'
  },
  DAI: {
    name: 'Dai',
    logo: 'dai.svg',
    symbol: 'DAI',
    decimals: 18,
    address: '0x6b175474e89094c44da98b954eedeac495271d0f',
    coinGeckoId: 'dai'
  },
  LINK: {
    name: 'Chainlink',
    logo: 'chainlink.svg',
    symbol: 'LINK',
    decimals: 18,
    address: '0x514910771af9ca656af840dff83e8264ecf986ca',
    coinGeckoId: 'chainlink'
  },
  SUSHI: {
    name: 'SushiSwap',
    logo: 'sushi.svg',
    symbol: 'SUSHI',
    decimals: 18,
    address: '0x6b3595068778dd592e39a122f4f5a5cf09c90fe2',
    coinGeckoId: 'sushi'
  },
  AXS: {
    name: 'Axie Infinity',
    logo: 'axs.svg',
    symbol: 'AXS',
    decimals: 18,
    address: '0xbb0e17ef65f82ab018d8edd776e8dd940327b28b',
    coinGeckoId: 'axie-infinity'
  },
  /* 20 Oct */
  '1INCH': {
    address: '0x111111111117dc0aa78b770fa6a738034120c302',
    coinGeckoId: '1inch',
    name: '1inch',
    symbol: '1INCH',
    decimals: 18,
    logo: 'https://static.alchemyapi.io/images/assets/8104.png'
  },
  BAT: {
    address: '0x0d8775f648430679a709e98d2b0cb6250d2887ef',
    coinGeckoId: 'basic-attention-token',
    name: 'Basic Attention Token',
    symbol: 'BAT',
    decimals: 18,
    logo: 'https://static.alchemyapi.io/images/assets/1697.png'
  },
  BUSD: {
    address: '0x4fabb145d64652a948d72533023f6e7a623c7c53',
    coinGeckoId: 'binance-usd',
    name: 'Binance USD',
    symbol: 'BUSD',
    decimals: 18,
    logo: 'https://static.alchemyapi.io/images/assets/4687.png'
  },
  CEL: {
    address: '0xaaaebe6fe48e54f431b0c390cfaf0b017d09d42d',
    coinGeckoId: 'celsius-degree-token',
    name: 'Celsius',
    symbol: 'CEL',
    decimals: 4,
    logo: 'https://static.alchemyapi.io/images/assets/2700.png'
  },
  CELL: {
    address: '0x26c8afbbfe1ebaca03c2bb082e69d0476bffe099',
    coinGeckoId: 'cellframe',
    name: 'Cellframe',
    symbol: 'CELL',
    decimals: 18,
    logo: 'https://static.alchemyapi.io/images/assets/8992.png'
  },
  CHZ: {
    address: '0x3506424f91fd33084466f402d5d97f05f8e3b4af',
    coinGeckoId: 'chiliz',
    name: 'Chiliz',
    symbol: 'CHZ',
    decimals: 18,
    logo: 'https://static.alchemyapi.io/images/assets/4066.png'
  },
  DEFI5: {
    address: '0xfa6de2697d59e88ed7fc4dfe5a33dac43565ea41',
    coinGeckoId: 'defi-top-5-tokens-index',
    name: 'DEFI Top 5 Tokens Index',
    symbol: 'DEFI5',
    decimals: 18,
    logo: 'https://static.alchemyapi.io/images/assets/8430.png'
  },
  ENJ: {
    address: '0xf629cbd94d3791c9250152bd8dfbdf380e2a3b9c',
    coinGeckoId: 'enjincoin',
    name: 'Enjin Coin',
    symbol: 'ENJ',
    decimals: 18,
    logo: 'https://static.alchemyapi.io/images/assets/2130.png'
  },
  EVAI: {
    address: '0x50f09629d0afdf40398a3f317cc676ca9132055c',
    coinGeckoId: 'evai',
    name: 'Evai.io',
    symbol: 'EVAI',
    decimals: 8,
    logo: 'https://static.alchemyapi.io/images/assets/9805.png'
  },
  FTM: {
    address: '0x4e15361fd6b4bb609fa63c81a2be19d873717870',
    coinGeckoId: 'fantom',
    name: 'Fantom',
    symbol: 'FTM',
    decimals: 18,
    logo: 'https://static.alchemyapi.io/images/assets/3513.png'
  },
  HT: {
    address: '0x6f259637dcd74c767781e37bc6133cd6a68aa161',
    coinGeckoId: 'huobi-token',
    name: 'Huobi Token',
    symbol: 'HT',
    decimals: 18,
    logo: 'https://static.alchemyapi.io/images/assets/2502.png'
  },
  NEXO: {
    address: '0xb62132e35a6c13ee1ee0f84dc5d40bad8d815206',
    coinGeckoId: 'nexo',
    name: 'Nexo',
    symbol: 'NEXO',
    decimals: 18,
    logo: 'https://static.alchemyapi.io/images/assets/2694.png'
  },
  NOIA: {
    address: '0xa8c8cfb141a3bb59fea1e2ea6b79b5ecbcd7b6ca',
    coinGeckoId: 'noia-network',
    name: 'Syntropy',
    symbol: 'NOIA',
    decimals: 18,
    logo: 'https://static.alchemyapi.io/images/assets/4191.png'
  },
  OCEAN: {
    address: '0x967da4048cd07ab37855c090aaf366e4ce1b9f48',
    coinGeckoId: 'ocean-protocol',
    name: 'Ocean Protocol',
    symbol: 'OCEAN',
    decimals: 18,
    logo: 'https://static.alchemyapi.io/images/assets/3911.png'
  },
  PAXG: {
    address: '0x45804880de22913dafe09f4980848ece6ecbaf78',
    coinGeckoId: 'pax-gold',
    name: 'PAX Gold',
    symbol: 'PAXG',
    decimals: 18,
    logo: 'https://static.alchemyapi.io/images/assets/4705.png'
  },
  POOL: {
    address: '0x0cec1a9154ff802e7934fc916ed7ca50bde6844e',
    coinGeckoId: 'pooltogether',
    name: 'PoolTogether',
    symbol: 'POOL',
    decimals: 18,
    logo: 'https://static.alchemyapi.io/images/assets/8508.png'
  },
  RUNE: {
    address: '0x3155BA85D5F96b2d030a4966AF206230e46849cb',
    coinGeckoId: 'thorchain-erc20',
    name: 'THORChain (ERC20)',
    symbol: 'RUNE',
    decimals: 18,
    logo: 'https://static.alchemyapi.io/images/assets/8272.png'
  },
  SHIB: {
    address: '0x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce',
    coinGeckoId: 'shiba-inu',
    name: 'SHIBA INU',
    symbol: 'SHIB',
    decimals: 18,
    logo: 'https://static.alchemyapi.io/images/assets/5994.png'
  },
  STARS: {
    address: '0xc55c2175e90a46602fd42e931f62b3acc1a013ca',
    coinGeckoId: 'mogul-productions',
    name: 'Mogul Productions',
    symbol: 'STARS',
    decimals: 18,
    logo: 'https://static.alchemyapi.io/images/assets/8996.png'
  },
  STT: {
    address: '0xaC9Bb427953aC7FDDC562ADcA86CF42D988047Fd',
    coinGeckoId: 'scatter-cx',
    name: 'Scatter.cx',
    symbol: 'STT',
    decimals: 18,
    logo: ''
  },
  SWAP: {
    address: '0xcc4304a31d09258b0029ea7fe63d032f52e44efe',
    coinGeckoId: 'trustswap',
    name: 'TrustSwap',
    symbol: 'SWAP',
    decimals: 18,
    logo: 'https://static.alchemyapi.io/images/assets/5829.png'
  },
  UMA: {
    address: '0x04fa0d235c4abf4bcf4787af4cf447de572ef828',
    coinGeckoId: 'uma',
    name: 'UMA',
    symbol: 'UMA',
    decimals: 18,
    logo: 'https://static.alchemyapi.io/images/assets/5617.png'
  },
  UTK: {
    address: '0xdc9ac3c20d1ed0b540df9b1fedc10039df13f99c',
    coinGeckoId: 'utrust',
    name: 'Utrust',
    symbol: 'UTK',
    decimals: 18,
    logo: 'https://static.alchemyapi.io/images/assets/2320.png'
  },
  /* 25 Oct */
  ATOM: {
    address: '0x8D983cb9388EaC77af0474fA441C4815500Cb7BB',
    coinGeckoId: 'cosmos',
    name: 'Cosmos',
    symbol: 'ATOM',
    decimals: 6,
    logo: 'atom.svg'
  },
  UATOM: {
    address: '0x8D983cb9388EaC77af0474fA441C4815500Cb7BB',
    coinGeckoId: 'cosmos',
    name: 'Cosmos',
    symbol: 'ATOM',
    decimals: 6,
    logo: 'atom.svg'
  },
  UPHOTON: {
    address: '0x8D983cb9388EaC77af0474fA441C4815500Cb7BB',
    coinGeckoId: 'cosmos',
    name: 'Cosmos Testnet',
    symbol: 'UPHOTON',
    decimals: 6,
    logo: 'atom.svg'
  },
  LUNA: {
    address: '0xd2877702675e6ceb975b4a1dff9fb7baf4c91ea9',
    coinGeckoId: 'terra-luna',
    name: 'Terra',
    symbol: 'LUNA',
    decimals: 6,
    logo: 'luna.png'
  },
  ULUNA: {
    address: '0xd2877702675e6ceb975b4a1dff9fb7baf4c91ea9',
    coinGeckoId: 'terra-luna',
    name: 'Terra',
    symbol: 'LUNA',
    decimals: 6,
    logo: 'luna.png'
  },
  UST: {
    address: '0xa47c8bf37f92aBed4A126BDA807A7b7498661acD',
    coinGeckoId: 'terrausd',
    name: 'TerraUSD',
    symbol: 'UST',
    decimals: 6,
    logo: 'ust.png'
  },
  UUSD: {
    address: '0xa47c8bf37f92aBed4A126BDA807A7b7498661acD',
    coinGeckoId: 'terrausd',
    name: 'TerraUSD',
    symbol: 'UST',
    decimals: 6,
    logo: 'ust.png'
  },
  GF: {
    address: '0xaaef88cea01475125522e117bfe45cf32044e238',
    coinGeckoId: 'guildfi',
    name: 'GuildFi',
    symbol: 'GF',
    decimals: 18,
    logo: 'gf.png'
  },
  XBX: {
    address: '0x080b12e80c9b45e97c23b6ad10a16b3e2a123949',
    coinGeckoId: '',
    name: 'BurnX',
    symbol: 'XBX',
    decimals: 18,
    logo: 'xbx.png'
  },
  OSMO: {
    address: '',
    coinGeckoId: 'osmosis',
    name: 'Osmosis',
    symbol: 'OSMO',
    decimals: 6,
    logo: 'osmo.png'
  },
  UOSMO: {
    address: '',
    coinGeckoId: 'osmosis',
    name: 'Osmosis',
    symbol: 'OSMO',
    decimals: 6,
    logo: 'osmo.png'
  },
  TAB: {
    name: 'Injective',
    logo: 'injective-v3.svg',
    symbol: 'TAB',
    decimals: 18,
    address: '0x36B3D7ACe7201E28040eFf30e815290D7b37ffaD',
    coinGeckoId: 'injective-protocol'
  },
  HUAHUA: {
    name: 'Chihuahua',
    logo: 'chihuahua.jpeg',
    symbol: 'HUAHUA',
    decimals: 6,
    address: '',
    coinGeckoId: 'chihuahua-token'
  },
  UHUAHUA: {
    name: 'Chihuahua',
    logo: 'chihuahua.jpeg',
    symbol: 'HUAHUA',
    decimals: 6,
    address: '',
    coinGeckoId: 'chihuahua-token'
  },
  JUNO: {
    name: 'Juno',
    logo: 'juno.jpeg',
    symbol: 'JUNO',
    decimals: 6,
    address: '',
    coinGeckoId: 'juno-network'
  },
  UJUNO: {
    name: 'Juno',
    logo: 'juno.jpeg',
    symbol: 'JUNO',
    decimals: 6,
    address: '',
    coinGeckoId: 'juno-network'
  },
  AXL: {
    name: 'Axelar',
    logo: 'axelar.jpeg',
    symbol: 'AXL',
    decimals: 6,
    address: '0x3eacbDC6C382ea22b78aCc158581A55aaF4ef3Cc',
    coinGeckoId: ''
  },
  UAXL: {
    name: 'Axelar',
    logo: 'axelar.jpeg',
    symbol: 'AXL',
    decimals: 6,
    address: '0x3eacbDC6C382ea22b78aCc158581A55aaF4ef3Cc',
    coinGeckoId: ''
  },
  BAYC: {
    name: 'Bored Ape Yacht Club',
    logo: 'bayc.svg',
    symbol: 'BAYC',
    decimals: 18,
    address: '',
    coinGeckoId: ''
  },
  /** 18.03.2022 */
  APE: {
    name: 'Ape Coin',
    logo: 'ape.png',
    symbol: 'APE',
    decimals: 18,
    address: '0x4d224452801aced8b2f0aebe155379bb5d594381',
    coinGeckoId: 'apecoin'
  },
  USCRT: {
    name: 'Secret Network',
    logo: 'scrt.png',
    symbol: 'SCRT',
    decimals: 6,
    address: '',
    coinGeckoId: 'secret'
  },
  SCRT: {
    name: 'Secret Network',
    logo: 'scrt.png',
    symbol: 'SCRT',
    decimals: 6,
    address: '',
    coinGeckoId: 'secret'
  },
  XPRT: {
    name: 'Persistence',
    logo: 'xprt.svg',
    symbol: 'XPRT',
    decimals: 6,
    address: '',
    coinGeckoId: 'persistence'
  },
  UXPRT: {
    name: 'Persistence',
    logo: 'xprt.svg',
    symbol: 'XPRT',
    decimals: 6,
    address: '',
    coinGeckoId: 'persistence'
  },
  EVMOS: {
    name: 'Evmos',
    logo: 'evmos.svg',
    symbol: 'EVMOS',
    decimals: 18,
    address: '',
    coinGeckoId: 'evmos'
  },
  AEVMOS: {
    name: 'Evmos',
    logo: 'evmos.svg',
    symbol: 'EVMOS',
    decimals: 18,
    address: '',
    coinGeckoId: 'evmos'
  },
  UAEVMOS: {
    name: 'Evmos',
    logo: 'evmos.svg',
    symbol: 'EVMOS',
    decimals: 18,
    address: '',
    coinGeckoId: 'evmos'
  },
  STX: {
    name: 'Stacks',
    logo: 'stacks.png',
    symbol: 'STX',
    decimals: 6,
    address: '',
    coinGeckoId: 'blockstack'
  },
  DOT: {
    name: 'Polkadot',
    logo: 'dot.jpeg',
    symbol: 'DOT',
    decimals: 10,
    address: '0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080',
    coinGeckoId: 'polkadot'
  },
  'DOT-PLANCK': {
    name: 'Polkadot',
    logo: 'dot.jpeg',
    symbol: 'DOT',
    decimals: 10,
    address: '0xFfFFfFff1FcaCBd218EDc0EbA20Fc2308C778080',
    coinGeckoId: 'polkadot'
  }
};

var testnetSymbolToAddressMap = {
  INJ: '0x85AbEac4F09762e28a49D7dA91260A46766F4F79',
  USDT: '0x87aB3B4C8661e07D6372361211B96ed4Dc36B1B5',
  APE: '0x44C21afAaF20c270EBbF5914Cfc3b5022173FEB7',
  USDC: '0xf9152067989BDc8783fF586624124C05A529A5D1',
  WETH: '0xdB309Bb079EB419C18fe7D568c61cD2FdB65D9aF'
};
var devnetSymbolToAddressMap = {
  INJ: '0xBe8d71D26525440A03311cc7fa372262c5354A3c'
};

var tokensBySymbolForTestnet = /*#__PURE__*/Object.keys(tokens).reduce(function (result, token) {
  var _extends2;
  var tokenKey = token;
  var testnetAddressFromMap = testnetSymbolToAddressMap[tokenKey];
  var testnetAddress = testnetAddressFromMap || tokens[token].address;
  return _extends({}, result, (_extends2 = {}, _extends2[token.toUpperCase()] = _extends({}, tokens[token], {
    address: testnetAddress
  }), _extends2));
}, {});
var tokensBySymbolForDevnet = /*#__PURE__*/Object.keys(tokens).reduce(function (result, token) {
  var _extends3;
  var tokenKey = token;
  var testnetAddressFromMap = devnetSymbolToAddressMap[tokenKey];
  var testnetAddress = testnetAddressFromMap || tokens[token].address;
  return _extends({}, result, (_extends3 = {}, _extends3[token.toUpperCase()] = _extends({}, tokens[token], {
    address: testnetAddress
  }), _extends3));
}, {});

var TokenMetaUtilFactory = /*#__PURE__*/function () {
  function TokenMetaUtilFactory() {}
  TokenMetaUtilFactory.make = function make(network) {
    if (network === void 0) {
      network = Network.Mainnet;
    }
    switch (network) {
      case Network.Mainnet:
        return new TokenMetaUtil(tokens);
      case Network.Devnet:
        return new TokenMetaUtil(tokensBySymbolForDevnet);
      case Network.Local:
        return new TokenMetaUtil(tokens);
      case Network.Testnet:
        return new TokenMetaUtil(tokensBySymbolForTestnet);
      default:
        return new TokenMetaUtil(tokens);
    }
  };
  return TokenMetaUtilFactory;
}();

var canonicalChannelIds = ['channel-1', 'channel-4', 'channel-5', 'channel-6', 'channel-8', 'channel-74', 'channel-76', 'channel-78', 'channel-82', 'channel-83', 'channel-84', 'channel-88'];

var TokenType;
(function (TokenType) {
  TokenType["Native"] = "native";
  TokenType["Erc20"] = "erc20";
  TokenType["Ibc"] = "ibc";
  TokenType["Cw20"] = "cw20";
  TokenType["InsuranceFund"] = "insuranceFund";
})(TokenType || (TokenType = {}));

var getTokenTypeFromDenom = function getTokenTypeFromDenom(denom) {
  if (denom === ROUTER_DENOM) {
    return TokenType.Native;
  }
  if (denom.startsWith('peggy')) {
    return TokenType.Erc20;
  }
  if (denom.startsWith('ibc')) {
    return TokenType.Ibc;
  }
  if (denom.startsWith('share')) {
    return TokenType.InsuranceFund;
  }
  return TokenType.Cw20;
};
var checkIsIbcDenomCanonical = function checkIsIbcDenomCanonical(path) {
  var pathParts = path.replace('transfer/', '').split('/');
  /** More than one channelId */
  if (pathParts.length > 1) {
    return false;
  }
  var channelId = pathParts[0];
  return canonicalChannelIds.includes(channelId);
};
var tokenMetaToToken = function tokenMetaToToken(tokenMeta, denom) {
  if (!tokenMeta) {
    return;
  }
  return {
    denom: denom,
    logo: tokenMeta.logo,
    symbol: tokenMeta.symbol,
    name: tokenMeta.name,
    decimals: tokenMeta.decimals,
    address: tokenMeta.address,
    tokenType: getTokenTypeFromDenom(denom),
    coinGeckoId: tokenMeta.coinGeckoId
  };
};
/**
 * @group Util
 */
var Denom = /*#__PURE__*/function () {
  function Denom(denom, network) {
    if (network === void 0) {
      network = Network.Mainnet;
    }
    this.denom = denom;
    var endpoints = getEndpointsForNetwork(network);
    this.ibcApi = new ChainGrpcIbcApi(endpoints.grpcEndpoint);
    this.tokenMetaUtil = TokenMetaUtilFactory.make(network);
  }
  var _proto = Denom.prototype;
  _proto.getPeggyDenomToken = /*#__PURE__*/function () {
    var _getPeggyDenomToken = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var denom, tokenMeta;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            denom = this.denom;
            _context.next = 3;
            return this.getPeggyDenomTokenMeta();
          case 3:
            tokenMeta = _context.sent;
            return _context.abrupt("return", Promise.resolve(tokenMetaToToken(tokenMeta, denom)));
          case 5:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function getPeggyDenomToken() {
      return _getPeggyDenomToken.apply(this, arguments);
    }
    return getPeggyDenomToken;
  }();
  _proto.getIbcDenomToken = /*#__PURE__*/function () {
    var _getIbcDenomToken = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var denom, _yield$this$fetchDeno, baseDenom, path, tokenMeta;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            denom = this.denom;
            _context2.next = 3;
            return this.fetchDenomTrace();
          case 3:
            _yield$this$fetchDeno = _context2.sent;
            baseDenom = _yield$this$fetchDeno.baseDenom;
            path = _yield$this$fetchDeno.path;
            _context2.next = 8;
            return new Denom(baseDenom).getDenomToken();
          case 8:
            tokenMeta = _context2.sent;
            return _context2.abrupt("return", _extends({
              baseDenom: baseDenom,
              isCanonical: checkIsIbcDenomCanonical(path),
              channelId: path.replace('transfer/', '')
            }, tokenMetaToToken(tokenMeta, denom)));
          case 10:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function getIbcDenomToken() {
      return _getIbcDenomToken.apply(this, arguments);
    }
    return getIbcDenomToken;
  }();
  _proto.getDenomToken = /*#__PURE__*/function () {
    var _getDenomToken = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      var denom, isDenom, bySymbol, byAddress, tokenMeta;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            denom = this.denom;
            isDenom = denom.startsWith('ibc/') || denom.startsWith('peggy') || denom.toLowerCase() === ROUTER_DENOM;
            if (isDenom) {
              _context3.next = 10;
              break;
            }
            bySymbol = this.getTokenMetaDataBySymbol();
            if (!bySymbol) {
              _context3.next = 6;
              break;
            }
            return _context3.abrupt("return", tokenMetaToToken(bySymbol, denom));
          case 6:
            byAddress = this.getTokenMetaDataByAddress();
            if (!byAddress) {
              _context3.next = 9;
              break;
            }
            return _context3.abrupt("return", tokenMetaToToken(byAddress, denom));
          case 9:
            return _context3.abrupt("return", {
              denom: denom,
              name: denom,
              tokenType: getTokenTypeFromDenom(denom),
              logo: '',
              symbol: '',
              decimals: 18,
              address: '',
              coinGeckoId: ''
            });
          case 10:
            _context3.next = 12;
            return this.getDenomTokenMeta();
          case 12:
            tokenMeta = _context3.sent;
            return _context3.abrupt("return", tokenMetaToToken(tokenMeta, denom));
          case 14:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function getDenomToken() {
      return _getDenomToken.apply(this, arguments);
    }
    return getDenomToken;
  }();
  _proto.getDenomTokenThrow = /*#__PURE__*/function () {
    var _getDenomTokenThrow = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
      var denom, tokenMeta;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            denom = this.denom;
            _context4.next = 3;
            return this.getDenomToken();
          case 3:
            tokenMeta = _context4.sent;
            if (tokenMeta) {
              _context4.next = 6;
              break;
            }
            throw new Error("Token meta for " + denom + " denom does not exist");
          case 6:
            return _context4.abrupt("return", tokenMetaToToken(tokenMeta, denom));
          case 7:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this);
    }));
    function getDenomTokenThrow() {
      return _getDenomTokenThrow.apply(this, arguments);
    }
    return getDenomTokenThrow;
  }();
  _proto.getCoinGeckoId = function getCoinGeckoId() {
    var tokenMetaUtil = this.tokenMetaUtil,
      denom = this.denom;
    return tokenMetaUtil.getCoinGeckoIdFromSymbol(denom);
  };
  _proto.getTokenMetaDataBySymbol = function getTokenMetaDataBySymbol() {
    var tokenMetaUtil = this.tokenMetaUtil,
      denom = this.denom;
    return tokenMetaUtil.getMetaBySymbol(denom);
  };
  _proto.getTokenMetaDataByAddress = function getTokenMetaDataByAddress() {
    var tokenMetaUtil = this.tokenMetaUtil,
      denom = this.denom;
    return tokenMetaUtil.getMetaByAddress(denom);
  };
  _proto.fetchDenomTrace = /*#__PURE__*/function () {
    var _fetchDenomTrace = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
      var denom, denomTrace;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            denom = this.denom;
            _context5.next = 3;
            return this.ibcApi.fetchDenomTrace(denom.replace('ibc/', ''));
          case 3:
            denomTrace = _context5.sent;
            if (denomTrace) {
              _context5.next = 6;
              break;
            }
            throw new Error("Denom trace not found for " + denom);
          case 6:
            return _context5.abrupt("return", {
              path: denomTrace.path,
              baseDenom: denomTrace.baseDenom
            });
          case 7:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this);
    }));
    function fetchDenomTrace() {
      return _fetchDenomTrace.apply(this, arguments);
    }
    return fetchDenomTrace;
  }();
  _proto.getPeggyDenomTokenMeta = function getPeggyDenomTokenMeta() {
    var denom = this.denom;
    var tokenMetaUtil = this.tokenMetaUtil;
    if (denom.toLowerCase() === ROUTER_DENOM) {
      return tokenMetaUtil.getMetaBySymbol('INJ');
    }
    var address = denom.startsWith('peggy') ? denom.replace('peggy', '') : denom;
    return tokenMetaUtil.getMetaByAddress(address);
  };
  _proto.getIbcDenomTokenMeta = /*#__PURE__*/function () {
    var _getIbcDenomTokenMeta = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
      var tokenMetaUtil, _yield$this$fetchDeno2, symbol;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            tokenMetaUtil = this.tokenMetaUtil;
            _context6.next = 3;
            return this.fetchDenomTrace();
          case 3:
            _yield$this$fetchDeno2 = _context6.sent;
            symbol = _yield$this$fetchDeno2.baseDenom;
            return _context6.abrupt("return", tokenMetaUtil.getMetaBySymbol(symbol));
          case 6:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this);
    }));
    function getIbcDenomTokenMeta() {
      return _getIbcDenomTokenMeta.apply(this, arguments);
    }
    return getIbcDenomTokenMeta;
  }();
  _proto.getDenomTokenMeta = /*#__PURE__*/function () {
    var _getDenomTokenMeta = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
      var denom;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            denom = this.denom;
            return _context7.abrupt("return", denom.startsWith('ibc/') ? this.getIbcDenomTokenMeta() : this.getPeggyDenomTokenMeta());
          case 2:
          case "end":
            return _context7.stop();
        }
      }, _callee7, this);
    }));
    function getDenomTokenMeta() {
      return _getDenomTokenMeta.apply(this, arguments);
    }
    return getDenomTokenMeta;
  }();
  return Denom;
}();

/**
 * @group Util
 */
function addLeading0x(str) {
  if (!str.startsWith('0x')) return '0x' + str;else return str;
}
function uint8ArrayToHex(arr) {
  return Buffer.from(arr).toString('hex');
}
function hexToUnit8Array(str) {
  return new Uint8Array(Buffer.from(str, 'hex'));
}
function decompress(startsWith02Or03) {
  // if already decompressed an not has trailing 04
  var testBuffer = Buffer.from(startsWith02Or03, 'hex');
  if (testBuffer.length === 64) startsWith02Or03 = '04' + startsWith02Or03;
  var decompressed = uint8ArrayToHex(publicKeyConvert(hexToUnit8Array(startsWith02Or03), false));
  // remove trailing 04
  decompressed = decompressed.substring(2);
  return decompressed;
}
var PublicKey = /*#__PURE__*/function () {
  function PublicKey(key, type) {
    this.key = key;
    this.type = type || '/ethermint.crypto.v1.ethsecp256k1.PubKey';
  }
  PublicKey.fromBase64 = function fromBase64(publicKey, type) {
    return new PublicKey(Buffer.from(publicKey, 'base64'), type);
  };
  PublicKey.fromHex = function fromHex(privateKey) {
    var isString = typeof privateKey === 'string';
    var privateKeyHex = isString && privateKey.startsWith('0x') ? privateKey.slice(2) : privateKey;
    var privateKeyBuff = Buffer.from(privateKeyHex.toString(), 'hex');
    var publicKeyByte = secp256k1__default.publicKeyCreate(privateKeyBuff, true);
    var type = '/ethermint.crypto.v1.ethsecp256k1.PubKey';
    return new PublicKey(publicKeyByte, type);
  };
  var _proto = PublicKey.prototype;
  _proto.toPubKeyBytes = function toPubKeyBytes() {
    return this.key;
  };
  _proto.toBase64 = function toBase64() {
    return Buffer.from(this.toPubKeyBytes()).toString('base64');
  };
  _proto.toHex = function toHex() {
    return Buffer.from(this.toPubKeyBytes()).toString('hex');
  };
  _proto.toBech32 = function toBech32() {
    return bech32.encode(BECH32_PUBKEY_ACC_PREFIX, this.key);
  };
  _proto.toAddress = function toAddress() {
    var publicKeyHex = this.toHex();
    var decompressedPublicKey = decompress(publicKeyHex);
    var addressBuffer = Buffer.from(keccak256(toBuffer(addLeading0x(decompressedPublicKey))), 'hex').subarray(-20);
    return Address.fromHex(addressBuffer.toString('hex').toLowerCase());
  };
  _proto.toProto = function toProto() {
    var proto = new PubKey$2();
    proto.setKey(this.key);
    return proto;
  };
  _proto.toAny = function toAny() {
    var proto = this.toProto();
    var message = new Any();
    message.setTypeUrl(this.type);
    message.setValue(Buffer.from(proto.serializeBinary()).toString('base64'));
    return message;
  };
  return PublicKey;
}();

/**
 * Class for wrapping SigningKey that is used for signature creation and public key derivation.
 *
 * @group Util
 */
var PrivateKey = /*#__PURE__*/function () {
  function PrivateKey(wallet) {
    this.wallet = wallet;
  }
  /**
   * Generate new private key with random mnemonic phrase
   * @returns { privateKey: PrivateKey, mnemonic: string }
   */
  PrivateKey.generate = function generate() {
    var mnemonic = bip39.generateMnemonic();
    var privateKey = PrivateKey.fromMnemonic(mnemonic);
    return {
      privateKey: privateKey,
      mnemonic: mnemonic
    };
  }
  /**
   * Create a PrivateKey instance from a given mnemonic phrase and a HD derivation path.
   * If path is not given, default to Band's HD prefix 494 and all other indexes being zeroes.
   * @param {string} words the mnemonic phrase
   * @param {string|undefined} path the HD path that follows the BIP32 standard (optional)
   * @returns {PrivateKey} Initialized PrivateKey object
   */;
  PrivateKey.fromMnemonic = function fromMnemonic(words, path) {
    if (path === void 0) {
      path = DEFAULT_DERIVATION_PATH;
    }
    return new PrivateKey(Wallet$1.fromMnemonic(words, path));
  }
  /**
   * Create a PrivateKey instance from a given private key and a HD derivation path.
   * If path is not given, default to Band's HD prefix 494 and all other indexes being zeroes.
   * @param {string} privateKey  the private key
   * @returns {PrivateKey} Initialized PrivateKey object
   */;
  PrivateKey.fromPrivateKey = function fromPrivateKey(privateKey) {
    return new PrivateKey(new Wallet$1(privateKey));
  }
  /**
   * Return a hex representation of signing key.
   * @returns {string}
   */;
  var _proto = PrivateKey.prototype;
  _proto.toHex = function toHex() {
    return this.wallet.address.startsWith('0x') ? this.wallet.address : "0x" + this.wallet.address;
  }
  /**
   * Return the PublicKey associated with this private key.
   * @returns {PublicKey} a Public key that can be used to verify the signatures made with this PrivateKey
   **/;
  _proto.toPublicKey = function toPublicKey() {
    return PublicKey.fromHex(this.wallet.privateKey);
  }
  /**
   * Return the Address associated with this private key.
   * @returns {Address}
   **/;
  _proto.toAddress = function toAddress() {
    return Address.fromHex(this.toHex());
  }
  /**
   * Return the Router address associated with this private key.
   * @returns {string}
   **/;
  _proto.toBech32 = function toBech32() {
    return Address.fromHex(this.toHex()).toBech32();
  }
  /**
   * Sign the given message using the wallet's _signingKey function.
   * @param {string} messageBytes: the message that will be hashed and signed, a Buffer made of bytes
   * @returns {Uint8Array} a signature of this private key over the given message
   */;
  _proto.sign =
  /*#__PURE__*/
  function () {
    var _sign = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(messageBytes) {
      var wallet, msgHash, signature, splitSignature$1;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            wallet = this.wallet; //@ts-ignore
            msgHash = keccak256$1(messageBytes);
            _context.next = 4;
            return wallet._signingKey().signDigest(msgHash);
          case 4:
            signature = _context.sent;
            splitSignature$1 = splitSignature(signature);
            return _context.abrupt("return", arrayify(concat([splitSignature$1.r, splitSignature$1.s])));
          case 7:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function sign(_x) {
      return _sign.apply(this, arguments);
    }
    return sign;
  }()
  /**
   * Sign the given message using the edcsa sign_deterministic function.
   * @param {Buffer} messageBytes: the message that will be hashed and signed, a Buffer made of bytes
   * @returns {Uint8Array} a signature of this private key over the given message
   */
  ;
  _proto.signEcda =
  /*#__PURE__*/
  function () {
    var _signEcda = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(messageBytes) {
      var wallet, msgHash, privateKeyHex, privateKey, _secp256k1$ecdsaSign, signature;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            wallet = this.wallet;
            msgHash = keccak256$1(messageBytes);
            privateKeyHex = wallet.privateKey.startsWith('0x') ? wallet.privateKey.slice(2) : wallet.privateKey;
            privateKey = Uint8Array.from(Buffer.from(privateKeyHex, 'hex'));
            _secp256k1$ecdsaSign = secp256k1__default.ecdsaSign(msgHash, privateKey), signature = _secp256k1$ecdsaSign.signature;
            return _context2.abrupt("return", signature);
          case 6:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function signEcda(_x2) {
      return _signEcda.apply(this, arguments);
    }
    return signEcda;
  }()
  /**
   * Sign the given message using the wallet's _signingKey function.
   * @param {string} messageHashedBytes: the message that will be signed, a Buffer made of bytes
   * @returns {Uint8Array} a signature of this private key over the given message
   */
  ;
  _proto.signHashed =
  /*#__PURE__*/
  function () {
    var _signHashed = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(messageHashedBytes) {
      var wallet, signature, splitSignature$1;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            wallet = this.wallet;
            _context3.next = 3;
            return wallet._signingKey().signDigest(messageHashedBytes);
          case 3:
            signature = _context3.sent;
            splitSignature$1 = splitSignature(signature);
            return _context3.abrupt("return", arrayify(concat([splitSignature$1.r, splitSignature$1.s])));
          case 6:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function signHashed(_x3) {
      return _signHashed.apply(this, arguments);
    }
    return signHashed;
  }()
  /**
   * Sign the given message using the edcsa sign_deterministic function.
   * @param {Buffer} messageHashedBytes: the message that will be signed, a Buffer made of bytes
   * @returns {Uint8Array} a signature of this private key over the given message
   */
  ;
  _proto.signHashedEcda =
  /*#__PURE__*/
  function () {
    var _signHashedEcda = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(messageHashedBytes) {
      var wallet, privateKeyHex, privateKey, _secp256k1$ecdsaSign2, signature;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            wallet = this.wallet;
            privateKeyHex = wallet.privateKey.startsWith('0x') ? wallet.privateKey.slice(2) : wallet.privateKey;
            privateKey = Uint8Array.from(Buffer.from(privateKeyHex, 'hex'));
            _secp256k1$ecdsaSign2 = secp256k1__default.ecdsaSign(messageHashedBytes, privateKey), signature = _secp256k1$ecdsaSign2.signature;
            return _context4.abrupt("return", signature);
          case 5:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this);
    }));
    function signHashedEcda(_x4) {
      return _signHashedEcda.apply(this, arguments);
    }
    return signHashedEcda;
  }();
  return PrivateKey;
}();

var createAnyMessage = function createAnyMessage(msg) {
  var message = new Any();
  message.setTypeUrl("" + (msg.type.startsWith('/') ? '' : '/') + msg.type);
  message.setValue(msg.value.serializeBinary());
  return message;
};
var createAny = function createAny(value, type) {
  var message = new Any();
  message.setTypeUrl(type);
  message.setValue(value);
  return message;
};
/**
 * Used when we want to pass a Msg class instead of the {type, message}
 * object of the Message (using the toDirectSign() method)
 * @returns
 */
var createTransactionFromMsg = function createTransactionFromMsg(params) {
  var messages = Array.isArray(params.message) ? params.message : [params.message];
  return createTransaction(_extends({}, params, {
    message: messages.map(function (m) {
      return m.toDirectSign();
    })
  }));
};
/**
 * Used when we get a DirectSignResponse from
 * Cosmos native wallets like Keplr, Leap, etc after
 * the TxRaw has been signed.
 *
 * The reason why we need to create a new TxRaw and
 * not use the one that we passed to signing is that the users
 * can change the gas fees and that will alter the original
 * TxRaw which will cause signature miss match if we broadcast
 * that transaction on chain
 * @returns TxRaw
 */
var createTxRawFromSigResponse = function createTxRawFromSigResponse(signatureResponse) {
  var txRaw = new TxRaw$1();
  txRaw.setAuthInfoBytes(signatureResponse.signed.authInfoBytes);
  txRaw.setBodyBytes(signatureResponse.signed.bodyBytes);
  txRaw.setSignaturesList([signatureResponse.signature.signature]);
  return txRaw;
};
/**
 * Used when we don't have account details and block details
 * and we pass the message and the user's address only
 * @returns
 */
var createTransactionForAddressAndMsg = /*#__PURE__*/function () {
  var _ref = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {
    var messages, chainRestAuthApi, tendermintRestApi, accountDetails, baseAccount, latestBlock, latestHeight, timeoutHeight, pubKey;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          messages = Array.isArray(params.message) ? params.message : [params.message]; // Clients
          chainRestAuthApi = new ChainRestAuthApi(params.endpoint);
          tendermintRestApi = new ChainRestTendermintApi(params.endpoint);
          /** Account Details * */
          _context.next = 5;
          return chainRestAuthApi.fetchCosmosAccount(params.address);
        case 5:
          accountDetails = _context.sent;
          baseAccount = BaseAccount.fromRestCosmosApi(accountDetails);
          /** Block Details */
          _context.next = 9;
          return tendermintRestApi.fetchLatestBlock();
        case 9:
          latestBlock = _context.sent;
          latestHeight = latestBlock.header.height;
          timeoutHeight = new BigNumberInBase(latestHeight).plus(DEFAULT_TIMEOUT_HEIGHT);
          pubKey = params.pubKey || baseAccount.pubKey.key;
          if (pubKey) {
            _context.next = 15;
            break;
          }
          throw new GeneralException(new Error("The pubKey for " + params.address + " is missing."));
        case 15:
          return _context.abrupt("return", createTransaction(_extends({}, params, {
            pubKey: params.pubKey || Buffer.from(baseAccount.pubKey.key).toString('base64'),
            sequence: Number(baseAccount.sequence),
            accountNumber: Number(baseAccount.accountNumber),
            timeoutHeight: timeoutHeight.toNumber(),
            message: messages.map(function (m) {
              return m.toDirectSign();
            })
          })));
        case 16:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function createTransactionForAddressAndMsg(_x) {
    return _ref.apply(this, arguments);
  };
}();
var createTransactionAndCosmosSignDoc = function createTransactionAndCosmosSignDoc(args) {
  var result = createTransaction(args);
  var _ref2 = Array.isArray(result.signers) ? result.signers : [result.signers],
    signer = _ref2[0];
  return _extends({}, result, {
    cosmosSignDoc: SignDoc$1.fromPartial({
      bodyBytes: result.bodyBytes,
      authInfoBytes: result.authInfoBytes,
      accountNumber: signer.accountNumber,
      chainId: args.chainId
    })
  });
};
var createCosmosSignDocFromTransaction = function createCosmosSignDocFromTransaction(args) {
  return SignDoc$1.fromPartial({
    bodyBytes: args.txRaw.getBodyBytes_asU8(),
    authInfoBytes: args.txRaw.getAuthInfoBytes_asU8(),
    accountNumber: args.accountNumber,
    chainId: args.chainId
  });
};
var createTransactionAndCosmosSignDocForAddressAndMsg = /*#__PURE__*/function () {
  var _ref3 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {
    var result, _ref4, signer;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return createTransactionForAddressAndMsg(params);
        case 2:
          result = _context2.sent;
          _ref4 = Array.isArray(result.signers) ? result.signers : [result.signers], signer = _ref4[0];
          return _context2.abrupt("return", _extends({}, result, {
            cosmosSignDoc: SignDoc$1.fromPartial({
              bodyBytes: result.bodyBytes,
              authInfoBytes: result.authInfoBytes,
              accountNumber: signer.accountNumber,
              chainId: params.chainId
            })
          }));
        case 5:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function createTransactionAndCosmosSignDocForAddressAndMsg(_x2) {
    return _ref3.apply(this, arguments);
  };
}();
var createTxRawEIP712 = function createTxRawEIP712(txRaw, extension) {
  var body = TxBody$1.deserializeBinary(txRaw.getBodyBytes_asU8());
  var extensionAny = createAny(extension.serializeBinary(), '/ethermint.types.v1.ExtensionOptionsWeb3Tx');
  body.addExtensionOptions(extensionAny);
  txRaw.setBodyBytes(body.serializeBinary());
  return txRaw;
};
var createWeb3Extension = function createWeb3Extension(_ref5) {
  var ethereumChainId = _ref5.ethereumChainId,
    feePayer = _ref5.feePayer,
    feePayerSig = _ref5.feePayerSig;
  var web3Extension = new ExtensionOptionsWeb3Tx();
  web3Extension.setTypeddatachainid(ethereumChainId);
  if (feePayer) {
    web3Extension.setFeepayer(feePayer);
  }
  if (feePayerSig) {
    web3Extension.setFeepayersig(feePayerSig);
  }
  return web3Extension;
};
var getRouterSignerAddress = function getRouterSignerAddress(address) {
  if (!address) {
    return '';
  }
  if (address.startsWith('router')) {
    return address;
  }
  if (address.startsWith('0x')) {
    return getRouterAddress(address);
  }
  return '';
};
var getEthereumSignerAddress = function getEthereumSignerAddress(address) {
  if (!address) {
    return '';
  }
  if (address.startsWith('0x')) {
    return address;
  }
  if (address.startsWith('router')) {
    return getAddressFromRouterAddress(address);
  }
  return '';
};

//import { SignDoc as CosmosSignDoc } from 'cosmjs-types/cosmos/tx/v1beta1/tx';
var SIGN_DIRECT = SignMode$1.SIGN_MODE_DIRECT;
var SIGN_AMINO = SignMode$1.SIGN_MODE_LEGACY_AMINO_JSON;
var getPublicKey = function getPublicKey(_ref) {
  var chainId = _ref.chainId,
    key = _ref.key;
  var proto;
  var path;
  if (chainId.startsWith('router') || chainId.startsWith('evmos')) {
    proto = new PubKey$2();
    path = '/ethermint.crypto.v1.ethsecp256k1.PubKey';
  } else {
    proto = new PubKey$3();
    path = '/cosmos.crypto.secp256k1.PubKey';
  }
  proto.setKey(Buffer.from(key, 'base64'));
  return createAny(proto.serializeBinary(), path);
};
var createBody = function createBody(_ref2) {
  var message = _ref2.message,
    _ref2$memo = _ref2.memo,
    memo = _ref2$memo === void 0 ? '' : _ref2$memo,
    timeoutHeight = _ref2.timeoutHeight;
  var messages = Array.isArray(message) ? message : [message];
  var txBody = new TxBody$1();
  txBody.setMessagesList(messages.map(function (message) {
    return createAnyMessage({
      value: message.message,
      type: message.type
    });
  }));
  txBody.setMemo(memo);
  if (timeoutHeight) {
    txBody.setTimeoutHeight(timeoutHeight);
  }
  return txBody;
};
var createFee = function createFee(_ref3) {
  var fee = _ref3.fee,
    payer = _ref3.payer,
    gasLimit = _ref3.gasLimit;
  var feeAmount = new Coin$1();
  feeAmount.setAmount(fee.amount);
  feeAmount.setDenom(fee.denom);
  var feeProto = new Fee$1();
  feeProto.setGasLimit(gasLimit);
  feeProto.setAmountList([feeAmount]);
  if (payer) {
    feeProto.setPayer(payer);
  }
  return feeProto;
};
var createSigners = function createSigners(_ref4) {
  var chainId = _ref4.chainId,
    mode = _ref4.mode,
    signers = _ref4.signers;
  return signers.map(function (s) {
    return createSignerInfo({
      mode: mode,
      chainId: chainId,
      publicKey: s.pubKey,
      sequence: s.sequence
    });
  });
};
var createSignerInfo = function createSignerInfo(_ref5) {
  var chainId = _ref5.chainId,
    publicKey = _ref5.publicKey,
    sequence = _ref5.sequence,
    mode = _ref5.mode;
  var pubKey = getPublicKey({
    chainId: chainId,
    key: publicKey
  });
  var single = new ModeInfo$1.Single();
  single.setMode(mode);
  var modeInfo = new ModeInfo$1();
  modeInfo.setSingle(single);
  var signerInfo = new SignerInfo$1();
  signerInfo.setPublicKey(pubKey);
  signerInfo.setSequence(sequence);
  signerInfo.setModeInfo(modeInfo);
  return signerInfo;
};
var createAuthInfo = function createAuthInfo(_ref6) {
  var signerInfo = _ref6.signerInfo,
    fee = _ref6.fee;
  var authInfo = new AuthInfo$1();
  authInfo.setSignerInfosList(signerInfo);
  authInfo.setFee(fee);
  return authInfo;
};
var createSigDoc = function createSigDoc(_ref7) {
  var bodyBytes = _ref7.bodyBytes,
    authInfoBytes = _ref7.authInfoBytes,
    chainId = _ref7.chainId,
    accountNumber = _ref7.accountNumber;
  var signDoc = new SignDoc$2();
  signDoc.setAccountNumber(accountNumber);
  signDoc.setChainId(chainId);
  signDoc.setBodyBytes(bodyBytes);
  signDoc.setAuthInfoBytes(authInfoBytes);
  return signDoc;
};
/**
 * @hidden
 * @typedef {Object} CreateTransactionWithSignersArgs
 * @param {CreateTransactionWithSignersArgs} params
 * @property {MsgArg | MsgArg[]} message - the Cosmos messages to wrap them in a transaction
 * @property {string} memo - the memo to attach to the transaction
 * @property {StdFee} fee - the fee to attach to the transaction
 * @property {SignerDetails} signers - the signers of the transaction
 * @property {number} number - the account number to attach to the transaction
 * @property {number} chainId - the chain-id to attach to the transaction
 * @property {string} pubKey - the account pubKey to attach to the transaction (in base64)
 *
 * @typedef {Object} CreateTransactionResult
 * @property {TxRaw} txRaw  - the Tx raw that was created
 * @property {SignDoc} signDoc  - the SignDoc that was created - used for signing of the transaction
 * @property {SignerDetails} signers  - the signers of the transaction
 * @property {Uint8Array} bodyBytes  - the body bytes of the transaction
 * @property {Uint8Array} authInfoBytes  - the auth info bytes of the transaction
 * @property {Uint8Array} signBytes  - the sign bytes of the transaction (SignDoc serialized to binary)
 * @property {Uint8Array} signHashedBytes  - the sign bytes of the transaction (SignDoc serialized to binary) and hashed using keccak256
 * @returns {CreateTransactionResult} result
 */
var createTransactionWithSigners = function createTransactionWithSigners(_ref8) {
  var signers = _ref8.signers,
    chainId = _ref8.chainId,
    message = _ref8.message,
    timeoutHeight = _ref8.timeoutHeight,
    _ref8$memo = _ref8.memo,
    memo = _ref8$memo === void 0 ? '' : _ref8$memo,
    _ref8$fee = _ref8.fee,
    fee = _ref8$fee === void 0 ? DEFAULT_STD_FEE : _ref8$fee,
    _ref8$signMode = _ref8.signMode,
    signMode = _ref8$signMode === void 0 ? SIGN_DIRECT : _ref8$signMode;
  var actualSigners = Array.isArray(signers) ? signers : [signers];
  var signer = actualSigners[0];
  var body = createBody({
    message: message,
    memo: memo,
    timeoutHeight: timeoutHeight
  });
  var feeMessage = createFee({
    fee: fee.amount[0],
    payer: fee == null ? void 0 : fee.payer,
    gasLimit: parseInt(fee.gas, 10)
  });
  var signInfo = createSigners({
    chainId: chainId,
    mode: signMode,
    signers: actualSigners
  });
  var authInfo = createAuthInfo({
    signerInfo: signInfo,
    fee: feeMessage
  });
  var signDoc = createSigDoc({
    chainId: chainId,
    bodyBytes: body.serializeBinary(),
    authInfoBytes: authInfo.serializeBinary(),
    accountNumber: signer.accountNumber
  });
  var toSignBytes = Buffer.from(signDoc.serializeBinary());
  var toSignHash = keccak256$1(Buffer.from(signDoc.serializeBinary()));
  var txRaw = new TxRaw$1();
  txRaw.setAuthInfoBytes(authInfo.serializeBinary());
  txRaw.setBodyBytes(body.serializeBinary());
  return {
    txRaw: txRaw,
    signDoc: signDoc,
    signers: signers,
    signer: signer,
    signBytes: toSignBytes,
    signHashedBytes: toSignHash,
    bodyBytes: body.serializeBinary(),
    authInfoBytes: authInfo.serializeBinary()
  };
};
/**
 * @typedef {Object} CreateTransactionArgs
 * @param {CreateTransactionArgs} params
 * @property {MsgArg | MsgArg[]} message - the Cosmos messages to wrap them in a transaction
 * @property {string} memo - the memo to attach to the transaction
 * @property {StdFee} fee - the fee to attach to the transaction
 * @property {string} sequence - the account sequence to attach to the transaction
 * @property {number} number - the account number to attach to the transaction
 * @property {number} chainId - the chain-id to attach to the transaction
 * @property {string} pubKey - the account pubKey to attach to the transaction (in base64)
 *
 * @typedef {Object} CreateTransactionResult
 * @property {TxRaw} txRaw  // the Tx raw that was created
 * @property {SignDoc} signDoc  // the SignDoc that was created - used for signing of the transaction
 * @property {number} accountNumber  // the account number of the signer of the transaction
 * @property {Uint8Array} bodyBytes  // the body bytes of the transaction
 * @property {Uint8Array} authInfoBytes  // the auth info bytes of the transaction
 * @property {Uint8Array} signBytes  // the sign bytes of the transaction (SignDoc serialized to binary)
 * @property {Uint8Array} signHashedBytes  // the sign bytes of the transaction (SignDoc serialized to binary) and hashed using keccak256
 * @returns {CreateTransactionResult} result
 */
var createTransaction = function createTransaction(args) {
  return createTransactionWithSigners(_extends({}, args, {
    signers: {
      pubKey: args.pubKey,
      accountNumber: args.accountNumber,
      sequence: args.sequence
    }
  }));
};
var getTransactionPartsFromTxRaw = function getTransactionPartsFromTxRaw(txRaw) {
  var authInfo = AuthInfo$1.deserializeBinary(txRaw.getAuthInfoBytes_asU8());
  var body = TxBody$1.deserializeBinary(txRaw.getBodyBytes_asU8());
  return {
    body: body,
    authInfo: authInfo,
    signatures: txRaw.getSignaturesList_asU8()
  };
};

/**
 * Function used to generate EIP712 types based on a message object
 * and its structure (recursive)
 */
var objectKeysToEip712Types = function objectKeysToEip712Types(object, primaryType) {
  if (primaryType === void 0) {
    primaryType = 'MsgValue';
  }
  var output = new Map();
  var types = new Array();
  for (var property in snakeCaseKeys(object)) {
    if (property === '@type' || property === 'type') {
      continue;
    }
    var val = snakeCaseKeys(object)[property];
    var type = typeof val;
    if (type === 'boolean') {
      types.push({
        name: property,
        type: 'bool'
      });
    } else if (type === 'number' || type === 'bigint') {
      types.push({
        name: property,
        type: numberTypeToReflectionNumberType(property)
      });
    } else if (type === 'string') {
      types.push({
        name: property,
        type: 'string'
      });
    } else if (type === 'object') {
      if (Array.isArray(val) && val.length === 0) {
        throw new GeneralException(new Error('Array with length 0 found'));
      } else if (Array.isArray(val) && val.length > 0) {
        var arrayFirstType = typeof val[0];
        var isPrimitive = arrayFirstType === 'boolean' || arrayFirstType === 'number' || arrayFirstType === 'string';
        if (isPrimitive) {
          for (var arrayEntry in val) {
            if (typeof arrayEntry !== arrayFirstType) {
              throw new GeneralException(new Error('Array with different types found'));
            }
          }
          if (arrayFirstType === 'boolean') {
            types.push({
              name: property,
              type: 'bool[]'
            });
          } else if (arrayFirstType === 'number') {
            types.push({
              name: property,
              type: 'number[]'
            });
          } else if (arrayFirstType === 'string') {
            types.push({
              name: property,
              type: 'string[]'
            });
          }
        } else if (arrayFirstType === 'object') {
          var propertyType = appendTypePrefixToPropertyType(snakeToPascal(property), primaryType);
          var recursiveOutput = objectKeysToEip712Types(val[0], propertyType);
          var recursiveTypes = recursiveOutput.get(propertyType);
          types.push({
            name: property,
            type: propertyType + "[]"
          });
          output.set(propertyType, recursiveTypes);
          //@ts-ignore
          for (var _iterator = _createForOfIteratorHelperLoose(recursiveOutput.keys()), _step; !(_step = _iterator()).done;) {
            var key = _step.value;
            if (key !== primaryType) {
              output.set(key, recursiveOutput.get(key));
            }
          }
        } else {
          throw new GeneralException(new Error('Array with elements of unknown type found'));
        }
      } else {
        var _propertyType = appendTypePrefixToPropertyType(snakeToPascal(property), primaryType);
        var _recursiveOutput = objectKeysToEip712Types(val, _propertyType);
        var _recursiveTypes = _recursiveOutput.get(_propertyType);
        types.push({
          name: property,
          type: _propertyType
        });
        output.set(_propertyType, _recursiveTypes);
        //@ts-ignore
        for (var _iterator2 = _createForOfIteratorHelperLoose(_recursiveOutput.keys()), _step2; !(_step2 = _iterator2()).done;) {
          var _key = _step2.value;
          if (_key !== primaryType) {
            output.set(_key, _recursiveOutput.get(_key));
          }
        }
      }
    } else {
      throw new GeneralException(new Error("Type " + property + " not found"));
    }
  }
  output.set(primaryType, types);
  return output;
};
/**
 * JavaScript doesn't know the exact number types that
 * we represent these fields on chain so we have to map
 * them in their chain representation from the number value
 * that is available in JavaScript
 */
var numberTypeToReflectionNumberType = function numberTypeToReflectionNumberType(property) {
  switch (property) {
    case 'order_mask':
      return 'int32';
    case 'order_type':
      return 'int32';
    case 'oracle_type':
      return 'int32';
    case 'round':
      return 'uint64';
    case 'oracle_scale_factor':
      return 'uint64';
    case 'expiry':
      return 'int64';
    case 'option':
      return 'int32';
    case 'proposal_id':
      return 'uint64';
    default:
      return 'uint64';
  }
};
/**
 * We need to represent some of the values in a proper format acceptable by the chain.
 *
 * 1. We need to represent some values from a number to string
 * This needs to be done for every number value except for maps (ex: vote option)
 *
 * 2. We need to convert every `sdk.Dec` value from a raw value to shifted by 1e18 value
 * ex: 0.01 -> 0.01000000000000000000, 1 -> 1.000000000000000000
 *
 * 3. For some fields, like 'amount' in the 'MsgIncreasePositionMargin' we have
 * to also specify the Message type to apply the sdk.Dec conversion because there
 * are other amount fields in other messages as well and we don't want to affect them
 */
var mapValuesToProperValueType = function mapValuesToProperValueType(object, messageTypeUrl) {
  var numberToStringKeys = ['proposal_id', 'round', 'oracle_scale_factor', 'timeout_timestamp', 'revision_height', 'revision_number', 'expiry'];
  var sdkDecKeys = ['min_price_tick_size', 'price', 'quantity', 'margin', 'trigger_price', 'min_quantity_tick_size'];
  var sdkDecKeyWithTypeMaps = {
    'exchange/MsgIncreasePositionMargin': ['amount']
  };
  return Object.keys(object).reduce(function (result, key) {
    var _extends7;
    var value = object[key];
    if (!value) {
      return result;
    }
    if (typeof value === 'object') {
      var _extends3;
      if (Array.isArray(value)) {
        var _extends2;
        return _extends({}, result, (_extends2 = {}, _extends2[key] = value.map(function (item) {
          return mapValuesToProperValueType(item);
        }), _extends2));
      }
      return _extends({}, result, (_extends3 = {}, _extends3[key] = mapValuesToProperValueType(value), _extends3));
    }
    if (typeof value === 'number') {
      if (numberToStringKeys.includes(key)) {
        var _extends4;
        return _extends({}, result, (_extends4 = {}, _extends4[key] = value.toString(), _extends4));
      }
      // Maybe some other check needed
    }

    if (typeof value === 'string') {
      if (sdkDecKeys.includes(key)) {
        var _extends5;
        return _extends({}, result, (_extends5 = {}, _extends5[key] = numberToCosmosSdkDecString(value), _extends5));
      }
      // Message Type Specific checks
      if (messageTypeUrl) {
        var typeInMap = Object.keys(sdkDecKeyWithTypeMaps).find(function (key) {
          return key === messageTypeUrl;
        });
        if (typeInMap) {
          var _sdkDecKeys = sdkDecKeyWithTypeMaps[typeInMap];
          if (_sdkDecKeys.includes(key)) {
            var _extends6;
            return _extends({}, result, (_extends6 = {}, _extends6[key] = numberToCosmosSdkDecString(value), _extends6));
          }
        }
      }
    }
    return _extends({}, result, (_extends7 = {}, _extends7[key] = value, _extends7));
  }, {});
};
/**
 * Append Type prefix to a Level0 EIP712 type
 * including its parent property type
 */
var appendTypePrefixToPropertyType = function appendTypePrefixToPropertyType(property, parentProperty) {
  if (parentProperty === void 0) {
    parentProperty = '';
  }
  var propertyWithoutTypePrefix = property.replace('Type', '');
  var parentPropertyWithoutTypePrefix = parentProperty === 'MsgValue' ? '' : parentProperty.replace('Type', '');
  return "Type" + (parentPropertyWithoutTypePrefix + propertyWithoutTypePrefix);
};
/**
 * Mapping a path type to amino type for messages
 */
var protoTypeToAminoType = function protoTypeToAminoType(type) {
  var actualType = type.startsWith('/') ? type.substring(1) : type;
  switch (actualType) {
    // Auth
    case 'cosmos.auth.v1beta1.MsgUpdateParams':
      return 'cosmos-sdk/x/auth/MsgUpdateParams';
    // Authz
    case 'cosmos.authz.v1beta1.MsgGrant':
      return 'cosmos-sdk/MsgGrant';
    case 'cosmos.authz.v1beta1.MsgRevoke':
      return 'cosmos-sdk/MsgRevoke';
    case 'cosmos.authz.v1beta1.MsgExec':
      return 'cosmos-sdk/MsgExec';
    // Bank
    case 'cosmos.bank.v1beta1.MsgSend':
      return 'cosmos-sdk/MsgSend';
    case 'cosmos.bank.v1beta1.MsgMultiSend':
      return 'cosmos-sdk/MsgMultiSend';
    case 'cosmos.bank.v1beta1.MsgUpdateParams':
      return 'cosmos-sdk/x/bank/MsgUpdateParams';
    // Distribution
    case 'cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward':
      return 'cosmos-sdk/MsgWithdrawDelegationReward';
    case 'cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission':
      return 'cosmos-sdk/MsgWithdrawValCommission';
    case 'cosmos.distribution.v1beta1.MsgSetWithdrawAddress':
      return 'cosmos-sdk/MsgModifyWithdrawAddress';
    case 'cosmos.distribution.v1beta1.MsgFundCommunityPool':
      return 'cosmos-sdk/MsgFundCommunityPool';
    case 'cosmos.distribution.v1beta1.MsgUpdateParams':
      return 'cosmos-sdk/distribution/MsgUpdateParams';
    // Gov
    case 'cosmos.gov.v1beta1.MsgSubmitProposal':
      return 'cosmos-sdk/MsgSubmitProposal';
    case 'cosmos.gov.v1beta1.MsgDeposit':
      return 'cosmos-sdk/MsgDeposit';
    case 'cosmos.gov.v1beta1.MsgVote':
      return 'cosmos-sdk/MsgVote';
    case 'cosmos.gov.v1beta1.MsgVoteWeighted':
      return 'cosmos-sdk/MsgVoteWeighted';
    // Staking
    case 'cosmos.staking.v1beta1.MsgCreateValidator':
      return 'cosmos-sdk/MsgCreateValidator';
    case 'cosmos.staking.v1beta1.MsgEditValidator':
      return 'cosmos-sdk/MsgEditValidator';
    case 'cosmos.staking.v1beta1.MsgDelegate':
      return 'cosmos-sdk/MsgDelegate';
    case 'cosmos.staking.v1beta1.MsgUndelegate':
      return 'cosmos-sdk/MsgUndelegate';
    case 'cosmos.staking.v1beta1.MsgBeginRedelegate':
      return 'cosmos-sdk/MsgBeginRedelegate';
    case 'cosmos.staking.v1beta1.MsgCancelUnbondingDelegation':
      return 'cosmos-sdk/MsgCancelUnbondingDelegation';
    case 'cosmos.staking.v1beta1.MsgUpdateParams':
      return 'cosmos-sdk/x/staking/MsgUpdateParams';
    // IBC
    case 'ibc.applications.transfer.v1.MsgTransfer':
      return 'cosmos-sdk/MsgTransfer';
    default:
      throw new GeneralException(new Error('Unknown message type: ' + type));
  }
};

var getEip712Domain = function getEip712Domain(ethereumChainId) {
  return {
    domain: {
      name: 'Cosmos Web3',
      version: '1.0.0',
      chainId: ethereumChainId,
      salt: '0',
      verifyingContract: 'cosmos'
    }
  };
};
var getDefaultEip712Types = function getDefaultEip712Types() {
  return {
    types: {
      EIP712Domain: [{
        name: 'name',
        type: 'string'
      }, {
        name: 'version',
        type: 'string'
      }, {
        name: 'chainId',
        type: 'uint256'
      }, {
        name: 'verifyingContract',
        type: 'string'
      }, {
        name: 'salt',
        type: 'string'
      }],
      Tx: [{
        name: 'account_number',
        type: 'string'
      }, {
        name: 'chain_id',
        type: 'string'
      }, {
        name: 'fee',
        type: 'Fee'
      }, {
        name: 'memo',
        type: 'string'
      }, {
        name: 'msgs',
        type: 'Msg[]'
      }, {
        name: 'sequence',
        type: 'string'
      }],
      Fee: [{
        name: 'feePayer',
        type: 'string'
      }, {
        name: 'amount',
        type: 'Coin[]'
      }, {
        name: 'gas',
        type: 'string'
      }],
      Coin: [{
        name: 'denom',
        type: 'string'
      }, {
        name: 'amount',
        type: 'string'
      }],
      Msg: [{
        name: 'type',
        type: 'string'
      }, {
        name: 'value',
        type: 'MsgValue'
      }]
    }
  };
};
var getEip712Fee = function getEip712Fee(params) {
  if (!params) {
    return {
      fee: DEFAULT_STD_FEE
    };
  }
  var _amount$gas$feePayer = {
      amount: params.amount || DEFAULT_STD_FEE.amount,
      gas: params.gas || DEFAULT_GAS_LIMIT.toFixed(),
      feePayer: params.feePayer
    },
    amount = _amount$gas$feePayer.amount,
    gas = _amount$gas$feePayer.gas,
    feePayer = _amount$gas$feePayer.feePayer;
  return {
    fee: {
      gas: gas,
      amount: amount,
      feePayer: feePayer
    }
  };
};
var getTypesIncludingFeePayer = function getTypesIncludingFeePayer(_ref) {
  var fee = _ref.fee,
    types = _ref.types;
  if (!fee) {
    return types;
  }
  return types;
};
var getEipTxDetails = function getEipTxDetails(_ref2) {
  var accountNumber = _ref2.accountNumber,
    sequence = _ref2.sequence,
    chainId = _ref2.chainId,
    memo = _ref2.memo;
  return {
    account_number: accountNumber,
    chain_id: chainId,
    memo: memo || '',
    sequence: sequence
  };
};

var getEip712TypedData = function getEip712TypedData(_ref) {
  var msgs = _ref.msgs,
    tx = _ref.tx,
    fee = _ref.fee,
    ethereumChainId = _ref.ethereumChainId;
  var messages = Array.isArray(msgs) ? msgs : [msgs];
  var eip712Msgs = messages.map(function (m) {
    return m.toEip712();
  });
  var eip712MessageTypes = messages[0].toEip712Types();
  var types = getDefaultEip712Types();
  var typesWithMessageTypes = {
    types: _extends({}, types.types, Object.fromEntries(eip712MessageTypes))
  };
  var typesWithFeePayer = getTypesIncludingFeePayer({
    fee: fee,
    types: typesWithMessageTypes
  });
  //    types: {
  //      EIP712Domain: [
  //        {
  //          name: 'name',
  //          type: 'string',
  //        },
  //        {
  //          name: 'version',
  //          type: 'string',
  //        },
  //        {
  //          name: 'chainId',
  //          type: 'uint256',
  //        },
  //        {
  //          name: 'verifyingContract',
  //          type: 'string',
  //        },
  //        {
  //          name: 'salt',
  //          type: 'string',
  //        },
  //      ],
  //      Tx: [
  //        {
  //          name: 'account_number',
  //          type: 'string',
  //        },
  //        {
  //          name: 'chain_id',
  //          type: 'string',
  //        },
  //        {
  //          name: 'fee',
  //          type: 'Fee',
  //        },
  //        {
  //          name: 'memo',
  //          type: 'string',
  //        },
  //        {
  //          name: 'msgs',
  //          type: 'Msg[]',
  //        },
  //        {
  //          name: 'sequence',
  //          type: 'string',
  //        },
  //      ],
  //      Fee: [
  //        {
  //          name: 'feePayer',
  //          type: 'string',
  //        },
  //        {
  //          name: 'amount',
  //          type: 'Coin[]',
  //        },
  //        {
  //          name: 'gas',
  //          type: 'string',
  //        },
  //      ],
  //      Coin: [
  //        {
  //          name: 'denom',
  //          type: 'string',
  //        },
  //        {
  //          name: 'amount',
  //          type: 'string',
  //        },
  //      ],
  //      Msg: [
  //        {
  //          name: 'type',
  //          type: 'string',
  //        },
  //        {
  //          name: 'value',
  //          type: 'MsgValue',
  //        },
  //      ],
  //      MsgValue: [
  //        {
  //          name: 'fee_payer',
  //          type: 'string',
  //        },
  //        //  {
  //        //    name: 'chain_type',
  //        //    type: 'uint64',
  //        //  },
  //        //  {
  //        //    name: 'chain_id',
  //        //    type: 'string',
  //        //  },
  //        { name: 'dapp_address', type: 'string' },
  //      ],
  //    },
  //  };
  return _extends({
    primaryType: 'Tx'
  }, typesWithFeePayer, getEip712Domain(ethereumChainId), {
    message: _extends({}, getEipTxDetails(tx), getEip712Fee(fee), {
      msgs: eip712Msgs
    })
  });
};

function prepareSignBytes(obj) {
  if (Array.isArray(obj)) {
    return obj.map(prepareSignBytes);
  }
  // string, number, or null
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  var sorted = {};
  Object.keys(obj).sort().forEach(function (key) {
    if (obj[key] === undefined || obj[key] === null) return;
    sorted[key] = prepareSignBytes(obj[key]);
  });
  return sorted;
}

var _excluded = ["type"];
/**
 * @group Message
 */
var MsgBase = /*#__PURE__*/function () {
  function MsgBase(params) {
    this.params = params;
  }
  var _proto = MsgBase.prototype;
  _proto.toJSON = function toJSON() {
    return JSON.stringify(prepareSignBytes(this.toData()));
  };
  _proto.toEip712Types = function toEip712Types() {
    return objectKeysToEip712Types(this.toAmino());
  };
  _proto.toEip712 = function toEip712() {
    var amino = this.toAmino();
    // @ts-ignore
    var type = amino.type,
      value = _objectWithoutPropertiesLoose(amino, _excluded);
    return {
      type: type,
      value: snakeCaseKeys(value)
    };
  };
  _proto.toDirectSignJSON = function toDirectSignJSON() {
    return JSON.stringify(prepareSignBytes(this.toDirectSign()));
  };
  return MsgBase;
}();

var _excluded$1 = ["type"];
/**
 * @group Message
 */
var MsgGrant = /*#__PURE__*/function (_MsgBase) {
  _inheritsLoose(MsgGrant, _MsgBase);
  function MsgGrant() {
    return _MsgBase.apply(this, arguments) || this;
  }
  MsgGrant.fromJSON = function fromJSON(params) {
    return new MsgGrant(params);
  };
  var _proto = MsgGrant.prototype;
  _proto.toProto = function toProto() {
    var params = this.params;
    var timestamp = this.getTimestamp();
    var genericAuthorization = new GenericAuthorization();
    genericAuthorization.setMsg(params.messageType);
    var genericAuthorizationType = '/cosmos.authz.v1beta1.GenericAuthorization';
    var authorization = new Any();
    authorization.setTypeUrl(genericAuthorizationType);
    authorization.setValue(genericAuthorization.getMsg());
    var grant = new Grant();
    grant.setExpiration(timestamp);
    grant.setAuthorization(authorization);
    var message = new MsgGrant$2();
    message.setGrantee(params.grantee);
    message.setGranter(params.granter);
    message.setGrant(grant);
    return message;
  };
  _proto.toData = function toData() {
    var proto = this.toProto();
    return _extends({
      '@type': '/cosmos.authz.v1beta1.MsgGrant'
    }, proto.toObject());
  };
  _proto.toAmino = function toAmino() {
    var _message$grant, _message$grant$author;
    var proto = this.toProto();
    var timestamp = this.getTimestamp();
    var message = proto.toObject();
    var genericAuthorizationType = '/cosmos.authz.v1beta1.GenericAuthorization';
    var messageWithAuthorizationType = _extends({}, message, {
      grant: _extends({}, message.grant, {
        authorization: {
          msg: (_message$grant = message.grant) == null ? void 0 : (_message$grant$author = _message$grant.authorization) == null ? void 0 : _message$grant$author.value,
          '@type': genericAuthorizationType
        },
        expiration: timestamp.toDate()
      })
    });
    return _extends({
      type: 'cosmos-sdk/MsgGrant'
    }, messageWithAuthorizationType);
  };
  _proto.toDirectSign = function toDirectSign() {
    var proto = this.toProto();
    return {
      type: '/cosmos.authz.v1beta1.MsgGrant',
      message: proto
    };
  };
  _proto.toWeb3 = function toWeb3() {
    var amino = this.toAmino();
    var rest = _objectWithoutPropertiesLoose(amino, _excluded$1);
    return _extends({
      '@type': '/cosmos.authz.v1beta1.MsgGrant'
    }, rest);
  };
  _proto.getTimestamp = function getTimestamp() {
    var params = this.params;
    var defaultExpiryYears = params.expiryInSeconds ? 0 : 5;
    var dateNow = new Date();
    var expiration = new Date(dateNow.getFullYear() + (params.expiryInYears || defaultExpiryYears), dateNow.getMonth(), dateNow.getDate());
    var timestamp = new Timestamp();
    timestamp.setSeconds(expiration.getTime() / 1000 + (params.expiryInSeconds || 0));
    return timestamp;
  };
  return MsgGrant;
}(MsgBase);

var _excluded$2 = ["type"];
/**
 * @group Message
 */
var MsgRevoke = /*#__PURE__*/function (_MsgBase) {
  _inheritsLoose(MsgRevoke, _MsgBase);
  function MsgRevoke() {
    return _MsgBase.apply(this, arguments) || this;
  }
  MsgRevoke.fromJSON = function fromJSON(params) {
    return new MsgRevoke(params);
  };
  var _proto = MsgRevoke.prototype;
  _proto.toProto = function toProto() {
    var params = this.params;
    var message = new MsgRevoke$2();
    message.setGrantee(params.grantee);
    message.setGranter(params.granter);
    message.setMsgTypeUrl(params.messageType);
    return message;
  };
  _proto.toData = function toData() {
    var proto = this.toProto();
    return _extends({
      '@type': '/cosmos.authz.v1beta1.MsgRevoke'
    }, proto.toObject());
  };
  _proto.toAmino = function toAmino() {
    var proto = this.toProto();
    return _extends({
      type: 'cosmos-sdk/MsgRevoke'
    }, proto.toObject());
  };
  _proto.toWeb3 = function toWeb3() {
    var amino = this.toAmino();
    var rest = _objectWithoutPropertiesLoose(amino, _excluded$2);
    return _extends({
      '@type': '/cosmos.authz.v1beta1.MsgRevoke'
    }, rest);
  };
  _proto.toDirectSign = function toDirectSign() {
    var proto = this.toProto();
    return {
      type: '/cosmos.authz.v1beta1.MsgRevoke',
      message: proto
    };
  };
  return MsgRevoke;
}(MsgBase);

var _excluded$3 = ["type"];
/**
 * @group Message
 */
var MsgExec = /*#__PURE__*/function (_MsgBase) {
  _inheritsLoose(MsgExec, _MsgBase);
  function MsgExec() {
    return _MsgBase.apply(this, arguments) || this;
  }
  MsgExec.fromJSON = function fromJSON(params) {
    return new MsgExec(params);
  };
  var _proto = MsgExec.prototype;
  _proto.toProto = function toProto() {
    var params = this.params;
    var message = new MsgExec$2();
    message.setGrantee(params.grantee);
    var msgs = Array.isArray(params.msgs) ? params.msgs : [params.msgs];
    var actualMsgs = msgs.map(function (msg) {
      var msgValue = new Any();
      msgValue.setTypeUrl(msg.toData()['@type']);
      msgValue.setValue(msg.toProto().serializeBinary());
      return msgValue;
    });
    message.setMsgsList(actualMsgs);
    return message;
  };
  _proto.toData = function toData() {
    var proto = this.toProto();
    return _extends({
      '@type': '/cosmos.authz.v1beta1.MsgExec'
    }, proto.toObject());
  };
  _proto.toAmino = function toAmino() {
    var proto = this.toProto();
    return _extends({
      type: 'cosmos-sdk/MsgExec'
    }, proto.toObject());
  };
  _proto.toWeb3 = function toWeb3() {
    var amino = this.toAmino();
    var rest = _objectWithoutPropertiesLoose(amino, _excluded$3);
    return _extends({
      '@type': '/cosmos.authz.v1beta1.MsgExec'
    }, rest);
  };
  _proto.toDirectSign = function toDirectSign() {
    var proto = this.toProto();
    return {
      type: '/cosmos.authz.v1beta1.MsgExec',
      message: proto
    };
  };
  return MsgExec;
}(MsgBase);

var _excluded$4 = ["type"];
/**
 * @group Message
 */
var MsgSend = /*#__PURE__*/function (_MsgBase) {
  _inheritsLoose(MsgSend, _MsgBase);
  function MsgSend() {
    return _MsgBase.apply(this, arguments) || this;
  }
  MsgSend.fromJSON = function fromJSON(params) {
    return new MsgSend(params);
  };
  var _proto = MsgSend.prototype;
  _proto.toProto = function toProto() {
    var params = this.params;
    var amountToSend = new Coin$1();
    amountToSend.setAmount(params.amount.amount);
    amountToSend.setDenom(params.amount.denom);
    var message = new MsgSend$2();
    message.setFromAddress(params.srcRouterAddress);
    message.setToAddress(params.dstRouterAddress);
    message.setAmountList([amountToSend]);
    return message;
  };
  _proto.toData = function toData() {
    var proto = this.toProto();
    return _extends({
      '@type': '/cosmos.bank.v1beta1.MsgSend'
    }, proto.toObject());
  };
  _proto.toAmino = function toAmino() {
    var proto = this.toProto();
    var message = _extends({}, snakeCaseKeys(proto.toObject()), {
      amount: proto.getAmountList().map(function (amount) {
        return snakeCaseKeys(amount.toObject());
      })
    });
    // @ts-ignore
    delete message.amount_list;
    return _extends({
      type: 'cosmos-sdk/MsgSend'
    }, message);
  };
  _proto.toWeb3 = function toWeb3() {
    var amino = this.toAmino();
    var rest = _objectWithoutPropertiesLoose(amino, _excluded$4);
    return _extends({
      '@type': '/cosmos.bank.v1beta1.MsgSend'
    }, rest);
  };
  _proto.toDirectSign = function toDirectSign() {
    var proto = this.toProto();
    return {
      type: '/cosmos.bank.v1beta1.MsgSend',
      message: proto
    };
  };
  return MsgSend;
}(MsgBase);

var _excluded$5 = ["type"];
/**
 * @group Message
 */
var MsgWithdrawDelegatorReward = /*#__PURE__*/function (_MsgBase) {
  _inheritsLoose(MsgWithdrawDelegatorReward, _MsgBase);
  function MsgWithdrawDelegatorReward() {
    return _MsgBase.apply(this, arguments) || this;
  }
  MsgWithdrawDelegatorReward.fromJSON = function fromJSON(params) {
    return new MsgWithdrawDelegatorReward(params);
  };
  var _proto = MsgWithdrawDelegatorReward.prototype;
  _proto.toProto = function toProto() {
    var params = this.params;
    var message = new MsgWithdrawDelegatorReward$2();
    message.setDelegatorAddress(params.delegatorAddress);
    message.setValidatorAddress(params.validatorAddress);
    return message;
  };
  _proto.toData = function toData() {
    var proto = this.toProto();
    return _extends({
      '@type': '/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward'
    }, proto.toObject());
  };
  _proto.toAmino = function toAmino() {
    var proto = this.toProto();
    return _extends({
      type: 'cosmos-sdk/MsgWithdrawDelegationReward'
    }, proto.toObject());
  };
  _proto.toWeb3 = function toWeb3() {
    var amino = this.toAmino();
    var rest = _objectWithoutPropertiesLoose(amino, _excluded$5);
    return _extends({
      '@type': '/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward'
    }, rest);
  };
  _proto.toDirectSign = function toDirectSign() {
    var proto = this.toProto();
    return {
      type: '/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward',
      message: proto
    };
  };
  return MsgWithdrawDelegatorReward;
}(MsgBase);

var _excluded$6 = ["type"];
/**
 * @group Message
 */
var MsgVote = /*#__PURE__*/function (_MsgBase) {
  _inheritsLoose(MsgVote, _MsgBase);
  function MsgVote() {
    return _MsgBase.apply(this, arguments) || this;
  }
  MsgVote.fromJSON = function fromJSON(params) {
    return new MsgVote(params);
  };
  var _proto = MsgVote.prototype;
  _proto.toProto = function toProto() {
    var params = this.params;
    var message = new MsgVote$2();
    message.setOption(params.vote);
    message.setProposalId(params.proposalId);
    message.setVoter(params.voter);
    return message;
  };
  _proto.toData = function toData() {
    var proto = this.toProto();
    return _extends({
      '@type': '/cosmos.gov.v1beta1.MsgVote'
    }, proto.toObject());
  };
  _proto.toAmino = function toAmino() {
    var proto = this.toProto();
    return _extends({
      type: 'cosmos-sdk/MsgVote'
    }, proto.toObject());
  };
  _proto.toWeb3 = function toWeb3() {
    var amino = this.toAmino();
    var rest = _objectWithoutPropertiesLoose(amino, _excluded$6);
    return _extends({
      '@type': '/cosmos.gov.v1beta1.MsgVote'
    }, rest);
  };
  _proto.toDirectSign = function toDirectSign() {
    var proto = this.toProto();
    return {
      type: '/cosmos.gov.v1beta1.MsgVote',
      message: proto
    };
  };
  return MsgVote;
}(MsgBase);

var _excluded$7 = ["type"];
/**
 * @group Message
 */
var MsgDeposit = /*#__PURE__*/function (_MsgBase) {
  _inheritsLoose(MsgDeposit, _MsgBase);
  function MsgDeposit() {
    return _MsgBase.apply(this, arguments) || this;
  }
  MsgDeposit.fromJSON = function fromJSON(params) {
    return new MsgDeposit(params);
  };
  var _proto = MsgDeposit.prototype;
  _proto.toProto = function toProto() {
    var params = this.params;
    var deposit = new Coin$1();
    deposit.setAmount(params.amount.amount);
    deposit.setDenom(params.amount.denom);
    var message = new MsgDeposit$2();
    message.setDepositor(params.depositor);
    message.setProposalId(params.proposalId);
    message.setAmountList([deposit]);
    return message;
  };
  _proto.toData = function toData() {
    var proto = this.toProto();
    return _extends({
      '@type': '/cosmos.gov.v1beta1.MsgDeposit'
    }, proto.toObject());
  };
  _proto.toAmino = function toAmino() {
    var proto = this.toProto();
    var message = _extends({}, snakeCaseKeys(proto.toObject()), {
      amount: proto.getAmountList().map(function (amount) {
        return snakeCaseKeys(amount.toObject());
      })
    });
    // @ts-ignore
    delete message.amount_list;
    return _extends({
      type: 'cosmos-sdk/MsgDeposit'
    }, message);
  };
  _proto.toWeb3 = function toWeb3() {
    var amino = this.toAmino();
    var rest = _objectWithoutPropertiesLoose(amino, _excluded$7);
    return _extends({
      '@type': '/cosmos.gov.v1beta1.MsgDeposit'
    }, rest);
  };
  _proto.toDirectSign = function toDirectSign() {
    var proto = this.toProto();
    return {
      type: '/cosmos.gov.v1beta1.MsgDeposit',
      message: proto
    };
  };
  return MsgDeposit;
}(MsgBase);

var _excluded$8 = ["type"];
/**
 * @group Message
 */
var MsgSubmitTextProposal = /*#__PURE__*/function (_MsgBase) {
  _inheritsLoose(MsgSubmitTextProposal, _MsgBase);
  function MsgSubmitTextProposal() {
    return _MsgBase.apply(this, arguments) || this;
  }
  MsgSubmitTextProposal.fromJSON = function fromJSON(params) {
    return new MsgSubmitTextProposal(params);
  };
  var _proto = MsgSubmitTextProposal.prototype;
  _proto.toProto = function toProto() {
    var params = this.params;
    var depositParams = new Coin$1();
    depositParams.setDenom(params.deposit.denom);
    depositParams.setAmount(params.deposit.amount);
    var content = this.getContent();
    var proposalType = '/cosmos.gov.v1beta1.TextProposal';
    var contentAny = new Any();
    contentAny.setValue(content.serializeBinary());
    contentAny.setTypeUrl(proposalType);
    var message = new MsgSubmitProposal$1();
    message.setContent(contentAny);
    message.setProposer(params.proposer);
    message.setInitialDepositList([depositParams]);
    return message;
  };
  _proto.toData = function toData() {
    var proto = this.toProto();
    return _extends({
      '@type': '/cosmos.gov.v1beta1.MsgSubmitProposal'
    }, proto.toObject());
  };
  _proto.toAmino = function toAmino() {
    var params = this.params;
    var proto = this.toProto();
    var content = this.getContent();
    var proposalType = '/cosmos.gov.v1beta1.TextProposal';
    var message = {
      proposer: params.proposer,
      content: _extends({}, content.toObject()),
      initial_deposit: proto.getInitialDepositList().map(function (amount) {
        return snakeCaseKeys(amount.toObject());
      })
    };
    var messageWithProposalType = _extends({}, message, {
      content: _extends({}, message.content, {
        '@type': proposalType
      })
    });
    return _extends({
      type: 'cosmos-sdk/MsgSubmitProposal'
    }, messageWithProposalType);
  };
  _proto.toWeb3 = function toWeb3() {
    var amino = this.toAmino();
    var rest = _objectWithoutPropertiesLoose(amino, _excluded$8);
    return _extends({
      '@type': '/cosmos.gov.v1beta1.MsgSubmitProposal'
    }, rest);
  };
  _proto.toDirectSign = function toDirectSign() {
    var proto = this.toProto();
    return {
      type: '/cosmos.gov.v1beta1.MsgSubmitProposal',
      message: proto
    };
  };
  _proto.getContent = function getContent() {
    var params = this.params;
    var content = new TextProposal();
    content.setTitle(params.title);
    content.setDescription(params.description);
    return content;
  };
  return MsgSubmitTextProposal;
}(MsgBase);

var ProposalDecomposer = /*#__PURE__*/function () {
  function ProposalDecomposer() {}
  ProposalDecomposer.textProposal = function textProposal(content) {
    return TextProposal.deserializeBinary(content);
  };
  ProposalDecomposer.SoftwareUpgrade = function SoftwareUpgrade(content) {
    return SoftwareUpgradeProposal.deserializeBinary(content);
  };
  ProposalDecomposer.parametersChange = function parametersChange(content) {
    return ParameterChangeProposal.deserializeBinary(content);
  };
  return ProposalDecomposer;
}();

var _excluded$9 = ["type"];
/**
 * @group Message
 */
var MsgTransfer = /*#__PURE__*/function (_MsgBase) {
  _inheritsLoose(MsgTransfer, _MsgBase);
  function MsgTransfer() {
    return _MsgBase.apply(this, arguments) || this;
  }
  MsgTransfer.fromJSON = function fromJSON(params) {
    return new MsgTransfer(params);
  };
  var _proto = MsgTransfer.prototype;
  _proto.toProto = function toProto() {
    var params = this.params;
    var token = new Coin$1();
    token.setDenom(params.amount.denom);
    token.setAmount(params.amount.amount);
    var message = new MsgTransfer$1();
    message.setReceiver(params.receiver);
    message.setSender(params.sender);
    message.setSourceChannel(params.channelId);
    message.setSourcePort(params.port);
    message.setToken(token);
    if (params.height) {
      var timeoutHeight = new Height();
      timeoutHeight.setRevisionHeight(params.height.revisionHeight);
      timeoutHeight.setRevisionNumber(params.height.revisionNumber);
      message.setTimeoutHeight(timeoutHeight);
    }
    if (params.timeout) {
      message.setTimeoutTimestamp(params.timeout);
    }
    return message;
  };
  _proto.toData = function toData() {
    var proto = this.toProto();
    return _extends({
      '@type': '/ibc.applications.transfer.v1.MsgTransfer'
    }, proto.toObject());
  };
  _proto.toAmino = function toAmino() {
    var proto = this.toProto();
    return _extends({
      type: 'cosmos-sdk/MsgTransfer'
    }, proto.toObject());
  };
  _proto.toWeb3 = function toWeb3() {
    var amino = this.toAmino();
    var rest = _objectWithoutPropertiesLoose(amino, _excluded$9);
    return _extends({
      '@type': '/ibc.applications.transfer.v1.MsgTransfer'
    }, rest);
  };
  _proto.toDirectSign = function toDirectSign() {
    var proto = this.toProto();
    return {
      type: '/ibc.applications.transfer.v1.MsgTransfer',
      message: proto
    };
  };
  return MsgTransfer;
}(MsgBase);

var _excluded$a = ["type"];
/**
 * @group Message
 */
var MsgBeginRedelegate = /*#__PURE__*/function (_MsgBase) {
  _inheritsLoose(MsgBeginRedelegate, _MsgBase);
  function MsgBeginRedelegate() {
    return _MsgBase.apply(this, arguments) || this;
  }
  MsgBeginRedelegate.fromJSON = function fromJSON(params) {
    return new MsgBeginRedelegate(params);
  };
  var _proto = MsgBeginRedelegate.prototype;
  _proto.toProto = function toProto() {
    var params = this.params;
    var coinAmount = new Coin$1();
    coinAmount.setDenom(params.amount.denom);
    coinAmount.setAmount(params.amount.amount);
    var message = new MsgBeginRedelegate$1();
    message.setAmount(coinAmount);
    message.setDelegatorAddress(params.routerAddress);
    message.setValidatorSrcAddress(params.srcValidatorAddress);
    message.setValidatorDstAddress(params.dstValidatorAddress);
    return message;
  };
  _proto.toData = function toData() {
    var proto = this.toProto();
    return _extends({
      '@type': '/cosmos.staking.v1beta1.MsgBeginRedelegate'
    }, proto.toObject());
  };
  _proto.toAmino = function toAmino() {
    var proto = this.toProto();
    return _extends({
      type: 'cosmos-sdk/MsgBeginRedelegate'
    }, proto.toObject());
  };
  _proto.toWeb3 = function toWeb3() {
    var amino = this.toAmino();
    var rest = _objectWithoutPropertiesLoose(amino, _excluded$a);
    return _extends({
      '@type': '/cosmos.staking.v1beta1.MsgBeginRedelegate'
    }, rest);
  };
  _proto.toDirectSign = function toDirectSign() {
    var proto = this.toProto();
    return {
      type: '/cosmos.staking.v1beta1.MsgBeginRedelegate',
      message: proto
    };
  };
  return MsgBeginRedelegate;
}(MsgBase);

var _excluded$b = ["type"];
/**
 * @group Message
 */
var MsgDelegate = /*#__PURE__*/function (_MsgBase) {
  _inheritsLoose(MsgDelegate, _MsgBase);
  function MsgDelegate() {
    return _MsgBase.apply(this, arguments) || this;
  }
  MsgDelegate.fromJSON = function fromJSON(params) {
    return new MsgDelegate(params);
  };
  var _proto = MsgDelegate.prototype;
  _proto.toProto = function toProto() {
    var params = this.params;
    var coinAmount = new Coin$1();
    coinAmount.setDenom(params.amount.denom);
    coinAmount.setAmount(params.amount.amount);
    var message = new MsgDelegate$2();
    message.setAmount(coinAmount);
    message.setDelegatorAddress(params.routerAddress);
    message.setValidatorAddress(params.validatorAddress);
    return message;
  };
  _proto.toData = function toData() {
    var proto = this.toProto();
    return _extends({
      '@type': '/cosmos.staking.v1beta1.MsgDelegate'
    }, proto.toObject());
  };
  _proto.toAmino = function toAmino() {
    var proto = this.toProto();
    return _extends({
      type: 'cosmos-sdk/MsgDelegate'
    }, proto.toObject());
  };
  _proto.toWeb3 = function toWeb3() {
    var amino = this.toAmino();
    var rest = _objectWithoutPropertiesLoose(amino, _excluded$b);
    return _extends({
      '@type': '/cosmos.staking.v1beta1.MsgDelegate'
    }, rest);
  };
  _proto.toDirectSign = function toDirectSign() {
    var proto = this.toProto();
    return {
      type: '/cosmos.staking.v1beta1.MsgDelegate',
      message: proto
    };
  };
  return MsgDelegate;
}(MsgBase);

var _excluded$c = ["type"];
/**
 * @group Message
 */
var MsgUndelegate = /*#__PURE__*/function (_MsgBase) {
  _inheritsLoose(MsgUndelegate, _MsgBase);
  function MsgUndelegate() {
    return _MsgBase.apply(this, arguments) || this;
  }
  MsgUndelegate.fromJSON = function fromJSON(params) {
    return new MsgUndelegate(params);
  };
  var _proto = MsgUndelegate.prototype;
  _proto.toProto = function toProto() {
    var params = this.params;
    var coinAmount = new Coin$1();
    coinAmount.setDenom(params.amount.denom);
    coinAmount.setAmount(params.amount.amount);
    var message = new MsgUndelegate$2();
    message.setAmount(coinAmount);
    message.setDelegatorAddress(params.routerAddress);
    message.setValidatorAddress(params.validatorAddress);
    return message;
  };
  _proto.toData = function toData() {
    var proto = this.toProto();
    return _extends({
      '@type': '/cosmos.staking.v1beta1.MsgUndelegate'
    }, proto.toObject());
  };
  _proto.toAmino = function toAmino() {
    var proto = this.toProto();
    return _extends({
      type: 'cosmos-sdk/MsgUndelegate'
    }, proto.toObject());
  };
  _proto.toWeb3 = function toWeb3() {
    var amino = this.toAmino();
    var rest = _objectWithoutPropertiesLoose(amino, _excluded$c);
    return _extends({
      '@type': '/cosmos.staking.v1beta1.MsgUndelegate'
    }, rest);
  };
  _proto.toDirectSign = function toDirectSign() {
    var proto = this.toProto();
    return {
      type: '/cosmos.staking.v1beta1.MsgUndelegate',
      message: proto
    };
  };
  return MsgUndelegate;
}(MsgBase);

var _excluded$d = ["type"];
/**
 * @group Message
 */
var MsgExecuteContract = /*#__PURE__*/function (_MsgBase) {
  _inheritsLoose(MsgExecuteContract, _MsgBase);
  function MsgExecuteContract() {
    return _MsgBase.apply(this, arguments) || this;
  }
  MsgExecuteContract.fromJSON = function fromJSON(params) {
    return new MsgExecuteContract(params);
  };
  var _proto = MsgExecuteContract.prototype;
  _proto.toProto = function toProto() {
    var _msg;
    var params = this.params;
    var message = new MsgExecuteContract$2();
    var msg = (_msg = {}, _msg[params.action] = params.msg, _msg);
    message.setMsg(toUtf8(JSON.stringify(msg)));
    message.setSender(params.sender);
    message.setContract(params.contractAddress);
    if (params.funds) {
      var funds = new Coin$1();
      funds.setAmount(params.funds.amount);
      funds.setDenom(params.funds.denom);
      message.setFundsList([funds]);
    }
    return message;
  };
  _proto.toData = function toData() {
    var proto = this.toProto();
    return _extends({
      '@type': '/cosmwasm.wasm.v1.MsgExecuteContract'
    }, proto.toObject());
  };
  _proto.toAmino = function toAmino() {
    var params = this.params;
    var proto = this.toProto();
    var message = _extends({}, snakeCaseKeys(proto.toObject()), params.funds && {
      funds: proto.getFundsList().map(function (amount) {
        return snakeCaseKeys(amount.toObject());
      })
    });
    // @ts-ignore
    delete message.funds_list;
    return _extends({
      type: 'wasm/MsgExecuteContract'
    }, message);
  };
  _proto.toWeb3 = function toWeb3() {
    var amino = this.toAmino();
    var rest = _objectWithoutPropertiesLoose(amino, _excluded$d);
    return _extends({
      '@type': '/cosmwasm.wasm.v1.MsgExecuteContract'
    }, rest);
  };
  _proto.toDirectSign = function toDirectSign() {
    var proto = this.toProto();
    return {
      type: '/cosmwasm.wasm.v1.MsgExecuteContract',
      message: proto
    };
  };
  return MsgExecuteContract;
}(MsgBase);

var _excluded$e = ["type"];
/**
 * @group Message
 */
var MsgInstantiateContract = /*#__PURE__*/function (_MsgBase) {
  _inheritsLoose(MsgInstantiateContract, _MsgBase);
  function MsgInstantiateContract() {
    return _MsgBase.apply(this, arguments) || this;
  }
  MsgInstantiateContract.fromJSON = function fromJSON(params) {
    return new MsgInstantiateContract(params);
  };
  var _proto = MsgInstantiateContract.prototype;
  _proto.toProto = function toProto() {
    var params = this.params;
    var message = new MsgInstantiateContract$1();
    message.setMsg(toUtf8(JSON.stringify(params.msg)));
    message.setSender(params.sender);
    message.setAdmin(params.admin);
    message.setCodeId(params.codeId);
    message.setLabel(params.label);
    if (params.amount) {
      var funds = new Coin$1();
      funds.setAmount(params.amount.amount);
      funds.setDenom(params.amount.denom);
      message.setFundsList([funds]);
    }
    return message;
  };
  _proto.toData = function toData() {
    var proto = this.toProto();
    return _extends({
      '@type': '/cosmwasm.wasm.v1.MsgInstantiateContract'
    }, proto.toObject());
  };
  _proto.toAmino = function toAmino() {
    var proto = this.toProto();
    var message = _extends({}, snakeCaseKeys(proto.toObject()));
    // @ts-ignore
    delete message.funds_list;
    var messageWithProperKeys = snakeCaseKeys(message);
    return _extends({
      type: 'wasm/MsgInstantiateContract'
    }, messageWithProperKeys);
  };
  _proto.toWeb3 = function toWeb3() {
    var amino = this.toAmino();
    var rest = _objectWithoutPropertiesLoose(amino, _excluded$e);
    return _extends({
      '@type': '/cosmwasm.wasm.v1.MsgInstantiateContract'
    }, rest);
  };
  _proto.toDirectSign = function toDirectSign() {
    var proto = this.toProto();
    return {
      type: '/cosmwasm.wasm.v1.MsgInstantiateContract',
      message: proto
    };
  };
  return MsgInstantiateContract;
}(MsgBase);

var _excluded$f = ["type"];
/**
 * @group Message
 */
var MsgStoreCode = /*#__PURE__*/function (_MsgBase) {
  _inheritsLoose(MsgStoreCode, _MsgBase);
  function MsgStoreCode() {
    return _MsgBase.apply(this, arguments) || this;
  }
  /**
   *
   * @param params
   * @returns
   */
  MsgStoreCode.fromJSON = function fromJSON(params) {
    return new MsgStoreCode(params);
  }
  /**
   *
   * @returns
   */;
  var _proto = MsgStoreCode.prototype;
  _proto.toProto = function toProto() {
    var params = this.params;
    var message = new MsgStoreCode$2();
    //message.setExtension()
    message.setInstantiatePermission();
    message.setWasmByteCode(params.wasm);
    message.setSender(params.sender);
    if (params.amount) {
      var funds = new Coin$1();
      funds.setAmount(params.amount.amount);
      funds.setDenom(params.amount.denom);
      //message.setFundsList([funds]);
    }

    return message;
  }
  /**
   *
   * @returns
   */;
  _proto.toData = function toData() {
    var proto = this.toProto();
    return _extends({
      '@type': '/cosmwasm.wasm.v1.MsgStoreCode'
    }, proto.toObject());
  }
  /**
   *
   * @returns
   */;
  _proto.toAmino = function toAmino() {
    var proto = this.toProto();
    var message = _extends({}, snakeCaseKeys(proto.toObject()));
    var messageWithProperKeys = snakeCaseKeys(message);
    return _extends({
      type: 'wasm/MsgStoreCode'
    }, messageWithProperKeys);
  }
  /**
   *
   * @returns
   */;
  _proto.toWeb3 = function toWeb3() {
    var amino = this.toAmino();
    var rest = _objectWithoutPropertiesLoose(amino, _excluded$f);
    return _extends({
      '@type': '/cosmwasm.wasm.v1.MsgStoreCode'
    }, rest);
  }
  /**
   *
   * @returns
   */;
  _proto.toDirectSign = function toDirectSign() {
    var proto = this.toProto();
    return {
      type: '/cosmwasm.wasm.v1.MsgStoreCode',
      message: proto
    };
  };
  return MsgStoreCode;
}(MsgBase);

var _excluded$g = ["type"];
/**
 * @group Message
 */
var MsgUpdateAdmin = /*#__PURE__*/function (_MsgBase) {
  _inheritsLoose(MsgUpdateAdmin, _MsgBase);
  function MsgUpdateAdmin() {
    return _MsgBase.apply(this, arguments) || this;
  }
  MsgUpdateAdmin.fromJSON = function fromJSON(params) {
    return new MsgUpdateAdmin(params);
  };
  var _proto = MsgUpdateAdmin.prototype;
  _proto.toProto = function toProto() {
    var params = this.params;
    var message = new MsgUpdateAdmin$2();
    message.setSender(params.senderAddress);
    message.setNewAdmin(params.newAdminAddress);
    message.setContract(params.contractAddress);
    return message;
  };
  _proto.toData = function toData() {
    var proto = this.toProto();
    return _extends({
      '@type': '/cosmwasm.wasm.v1.MsgUpdateAdmin'
    }, proto.toObject());
  };
  _proto.toAmino = function toAmino() {
    var proto = this.toProto();
    var message = _extends({}, snakeCaseKeys(proto.toObject()));
    var messageWithProperKeys = snakeCaseKeys(message);
    return _extends({
      type: 'wasm/MsgUpdateAdmin'
    }, messageWithProperKeys);
  };
  _proto.toWeb3 = function toWeb3() {
    var amino = this.toAmino();
    var rest = _objectWithoutPropertiesLoose(amino, _excluded$g);
    return _extends({
      '@type': '/cosmwasm.wasm.v1.MsgUpdateAdmin'
    }, rest);
  };
  _proto.toDirectSign = function toDirectSign() {
    var proto = this.toProto();
    return {
      type: '/cosmwasm.wasm.v1.MsgUpdateAdmin',
      message: proto
    };
  };
  return MsgUpdateAdmin;
}(MsgBase);

var _excluded$h = ["type"];
/**
 * @group Message
 */
var MsgMigrateContract = /*#__PURE__*/function (_MsgBase) {
  _inheritsLoose(MsgMigrateContract, _MsgBase);
  function MsgMigrateContract() {
    return _MsgBase.apply(this, arguments) || this;
  }
  MsgMigrateContract.fromJSON = function fromJSON(params) {
    return new MsgMigrateContract(params);
  };
  var _proto = MsgMigrateContract.prototype;
  _proto.toProto = function toProto() {
    var params = this.params;
    var message = new MsgMigrateContract$2();
    message.setSender(params.senderAddress);
    message.setCodeId(params.codeId);
    message.setContract(params.contractAddress);
    message.setMsg(toUtf8(JSON.stringify(params.msg)));
    return message;
  };
  _proto.toData = function toData() {
    var proto = this.toProto();
    return _extends({
      '@type': '/cosmwasm.wasm.v1.MsgMigrateContract'
    }, proto.toObject());
  };
  _proto.toAmino = function toAmino() {
    var proto = this.toProto();
    var message = _extends({}, snakeCaseKeys(proto.toObject()));
    var messageWithProperKeys = snakeCaseKeys(message);
    return _extends({
      type: 'wasm/MsgMigrateContract'
    }, messageWithProperKeys);
  };
  _proto.toWeb3 = function toWeb3() {
    var amino = this.toAmino();
    var rest = _objectWithoutPropertiesLoose(amino, _excluded$h);
    return _extends({
      '@type': '/cosmwasm.wasm.v1.MsgMigrateContract'
    }, rest);
  };
  _proto.toDirectSign = function toDirectSign() {
    var proto = this.toProto();
    return {
      type: '/cosmwasm.wasm.v1.MsgMigrateContract',
      message: proto
    };
  };
  return MsgMigrateContract;
}(MsgBase);

var _excluded$i = ["type"];
/**
 * @group Message
 */
var MsgApproveFeepayerRequest = /*#__PURE__*/function (_MsgBase) {
  _inheritsLoose(MsgApproveFeepayerRequest, _MsgBase);
  function MsgApproveFeepayerRequest() {
    return _MsgBase.apply(this, arguments) || this;
  }
  MsgApproveFeepayerRequest.fromJSON = function fromJSON(params) {
    return new MsgApproveFeepayerRequest(params);
  };
  var _proto = MsgApproveFeepayerRequest.prototype;
  _proto.toProto = function toProto() {
    var params = this.params;
    var message = new MsgApproveFeepayerRequest$2();
    message.setFeePayer(params.feepayer);
    message.setChainId(params.chainid);
    message.setDappAddress(params.dappaddresses);
    return message;
  };
  _proto.toData = function toData() {
    var proto = this.toProto();
    return _extends({
      '@type': '/routerprotocol.routerchain.metastore.MsgApproveFeepayerRequest'
    }, proto.toObject());
  };
  _proto.toAmino = function toAmino() {
    var proto = this.toProto();
    var message = _extends({}, snakeCaseKeys(proto.toObject()));
    return _extends({
      type: 'metastore/ApproveFeepayerRequest'
    }, message);
  };
  _proto.toWeb3 = function toWeb3() {
    var amino = this.toAmino();
    var rest = _objectWithoutPropertiesLoose(amino, _excluded$i);
    return _extends({
      '@type': '/routerprotocol.routerchain.metastore.MsgApproveFeepayerRequest'
    }, rest);
  };
  _proto.toDirectSign = function toDirectSign() {
    var proto = this.toProto();
    return {
      type: '/routerprotocol.routerchain.metastore.MsgApproveFeepayerRequest',
      message: proto
    };
  };
  return MsgApproveFeepayerRequest;
}(MsgBase);

var _excluded$j = ["type"];
/**
 * @group Message
 */
var MsgExecuteCwContract = /*#__PURE__*/function (_MsgBase) {
  _inheritsLoose(MsgExecuteCwContract, _MsgBase);
  function MsgExecuteCwContract() {
    return _MsgBase.apply(this, arguments) || this;
  }
  MsgExecuteCwContract.fromJSON = function fromJSON(params) {
    return new MsgExecuteCwContract(params);
  };
  var _proto = MsgExecuteCwContract.prototype;
  _proto.toProto = function toProto() {
    var params = this.params;
    var message = new MsgExecuteCwContract$2();
    message.setMsg(JSON.stringify(params.msg));
    message.setSender(params.sender);
    message.setContract(params.contractAddress);
    if (params.funds) {
      var fundsToArray = Array.isArray(params.funds) ? params.funds : [params.funds];
      var funds = fundsToArray.map(function (coin) {
        return "" + coin.amount + coin.denom;
      });
      message.setFunds(funds.join(','));
    } else {
      message.setFunds('0');
    }
    return message;
  };
  _proto.toData = function toData() {
    var proto = this.toProto();
    return _extends({
      '@type': '/routerprotocol.routerchain.rwasm.MsgExecuteCwContract'
    }, proto.toObject());
  };
  _proto.toAmino = function toAmino() {
    var proto = this.toProto();
    var message = _extends({}, snakeCaseKeys(proto.toObject()));
    // @ts-ignore
    delete message.funds_list;
    return _extends({
      type: 'rwasm/ExecuteCwContract'
    }, message);
  };
  _proto.toWeb3 = function toWeb3() {
    var amino = this.toAmino();
    var rest = _objectWithoutPropertiesLoose(amino, _excluded$j);
    return _extends({
      '@type': '/routerprotocol.routerchain.rwasm.MsgExecuteCwContract'
    }, rest);
  };
  _proto.toDirectSign = function toDirectSign() {
    var proto = this.toProto();
    return {
      type: '/routerprotocol.routerchain.rwasm.MsgExecuteCwContract',
      message: proto
    };
  };
  return MsgExecuteCwContract;
}(MsgBase);

var _excluded$k = ["type"];
/**
 * @group Message
 */
var MsgInstantiateCwContract = /*#__PURE__*/function (_MsgBase) {
  _inheritsLoose(MsgInstantiateCwContract, _MsgBase);
  function MsgInstantiateCwContract() {
    return _MsgBase.apply(this, arguments) || this;
  }
  MsgInstantiateCwContract.fromJSON = function fromJSON(params) {
    return new MsgInstantiateCwContract(params);
  };
  var _proto = MsgInstantiateCwContract.prototype;
  _proto.toProto = function toProto() {
    var params = this.params;
    var message = new MsgInstantiateCwContract$2();
    message.setMsg(JSON.stringify(params.msg));
    message.setSender(params.sender);
    message.setAdmin(params.admin === '' ? 'null' : params.admin);
    message.setCodeId(params.codeId);
    message.setLabel(params.label);
    if (params.amount) {
      var fundsToArray = Array.isArray(params.amount) ? params.amount : [params.amount];
      var funds = fundsToArray.map(function (coin) {
        return "" + coin.amount + coin.denom;
      });
      message.setFunds(funds.join(','));
    } else {
      message.setFunds('0');
    }
    return message;
  };
  _proto.toData = function toData() {
    var proto = this.toProto();
    return _extends({
      '@type': '/routerprotocol.routerchain.rwasm.MsgInstantiateCwContract'
    }, proto.toObject());
  };
  _proto.toAmino = function toAmino() {
    var proto = this.toProto();
    var message = _extends({}, snakeCaseKeys(proto.toObject()));
    // @ts-ignore
    delete message.funds_list;
    var messageWithProperKeys = snakeCaseKeys(message);
    return _extends({
      type: 'rwasm/InstantiateCwContract'
    }, messageWithProperKeys);
  };
  _proto.toWeb3 = function toWeb3() {
    var amino = this.toAmino();
    var rest = _objectWithoutPropertiesLoose(amino, _excluded$k);
    return _extends({
      '@type': '/routerprotocol.routerchain.rwasm.MsgInstantiateCwContract'
    }, rest);
  };
  _proto.toDirectSign = function toDirectSign() {
    var proto = this.toProto();
    return {
      type: '/routerprotocol.routerchain.rwasm.MsgInstantiateCwContract',
      message: proto
    };
  };
  return MsgInstantiateCwContract;
}(MsgBase);

var _excluded$l = ["type"];
/**
 * @group Message
 */
var MsgCwStoreCode = /*#__PURE__*/function (_MsgBase) {
  _inheritsLoose(MsgCwStoreCode, _MsgBase);
  function MsgCwStoreCode() {
    return _MsgBase.apply(this, arguments) || this;
  }
  /**
   *
   * @param params
   * @returns
   */
  MsgCwStoreCode.fromJSON = function fromJSON(params) {
    return new MsgCwStoreCode(params);
  }
  /**
   *
   * @returns
   */;
  var _proto = MsgCwStoreCode.prototype;
  _proto.toProto = function toProto() {
    var params = this.params;
    var message = new MsgCwStoreCode$2();
    //message.setExtension()
    //message.setInstantiatePermission();
    message.setWasmByteCode(params.wasm.toString('base64'));
    message.setSender(params.sender);
    // if (params.amount) {
    //   const funds = new Coin();
    //   funds.setAmount(params.amount.amount);
    //   funds.setDenom(params.amount.denom);
    //   //message.setFundsList([funds]);
    // }
    return message;
  }
  /**
   *
   * @returns
   */;
  _proto.toData = function toData() {
    var proto = this.toProto();
    return _extends({
      '@type': '/routerprotocol.routerchain.rwasm.MsgCwStoreCode'
    }, proto.toObject());
  }
  /**
   *
   * @returns
   */;
  _proto.toAmino = function toAmino() {
    var proto = this.toProto();
    var message = _extends({}, snakeCaseKeys(proto.toObject()));
    var messageWithProperKeys = snakeCaseKeys(message);
    return _extends({
      type: 'rwasm/CwStoreCode'
    }, messageWithProperKeys);
  }
  /**
   *
   * @returns
   */;
  _proto.toWeb3 = function toWeb3() {
    var amino = this.toAmino();
    var rest = _objectWithoutPropertiesLoose(amino, _excluded$l);
    return _extends({
      '@type': '/routerprotocol.routerchain.rwasm.MsgCwStoreCode'
    }, rest);
  }
  /**
   *
   * @returns
   */;
  _proto.toDirectSign = function toDirectSign() {
    var proto = this.toProto();
    return {
      type: '/routerprotocol.routerchain.rwasm.MsgCwStoreCode',
      message: proto
    };
  };
  return MsgCwStoreCode;
}(MsgBase);

var _excluded$m = ["type"];
/**
 * @group Message
 */
var MsgMigrateCwContract = /*#__PURE__*/function (_MsgBase) {
  _inheritsLoose(MsgMigrateCwContract, _MsgBase);
  function MsgMigrateCwContract() {
    return _MsgBase.apply(this, arguments) || this;
  }
  MsgMigrateCwContract.fromJSON = function fromJSON(params) {
    return new MsgMigrateCwContract(params);
  };
  var _proto = MsgMigrateCwContract.prototype;
  _proto.toProto = function toProto() {
    var params = this.params;
    var message = new MsgMigrateCwContract$2();
    message.setSender(params.senderAddress);
    message.setCodeId(params.codeId);
    message.setContract(params.contractAddress);
    message.setMsg(JSON.stringify(params.msg));
    return message;
  };
  _proto.toData = function toData() {
    var proto = this.toProto();
    return _extends({
      '@type': '/routerprotocol.routerchain.rwasm.MsgMigrateCwContract'
    }, proto.toObject());
  };
  _proto.toAmino = function toAmino() {
    var proto = this.toProto();
    var message = _extends({}, snakeCaseKeys(proto.toObject()));
    var messageWithProperKeys = snakeCaseKeys(message);
    return _extends({
      type: 'rwasm/MigrateCwContract'
    }, messageWithProperKeys);
  };
  _proto.toWeb3 = function toWeb3() {
    var amino = this.toAmino();
    var rest = _objectWithoutPropertiesLoose(amino, _excluded$m);
    return _extends({
      '@type': '/routerprotocol.routerchain.rwasm.MsgMigrateCwContract'
    }, rest);
  };
  _proto.toDirectSign = function toDirectSign() {
    var proto = this.toProto();
    return {
      type: '/routerprotocol.routerchain.rwasm.MsgMigrateCwContract',
      message: proto
    };
  };
  return MsgMigrateCwContract;
}(MsgBase);

// @generated by protoc-gen-es v1.0.0 with parameter "rewrite_imports=./google/api/**/*_pb.js:@buf/googleapis_googleapis.bufbuild_es,rewrite_imports=./gogoproto/**/*_pb.js:@buf/cosmos_gogo-proto.bufbuild_es,rewrite_imports=./cosmos_proto/**/*_pb.js:@buf/cosmos_cosmos-proto.bufbuild_es"

/**
 * CompactBitArray is an implementation of a space efficient bit array.
 * This is used to ensure that the encoded data takes up a minimal amount of
 * space after proto encoding.
 * This is not thread safe, and is not intended for concurrent usage.
 *
 * @generated from message cosmos.crypto.multisig.v1beta1.CompactBitArray
 */
var CompactBitArray = /*#__PURE__*/proto3.makeMessageType("cosmos.crypto.multisig.v1beta1.CompactBitArray", function () {
  return [{
    no: 1,
    name: "extra_bits_stored",
    kind: "scalar",
    T: 13 /* ScalarType.UINT32 */
  }, {
    no: 2,
    name: "elems",
    kind: "scalar",
    T: 12 /* ScalarType.BYTES */
  }];
});

// @generated by protoc-gen-es v1.0.0 with parameter "rewrite_imports=./google/api/**/*_pb.js:@buf/googleapis_googleapis.bufbuild_es,rewrite_imports=./gogoproto/**/*_pb.js:@buf/cosmos_gogo-proto.bufbuild_es,rewrite_imports=./cosmos_proto/**/*_pb.js:@buf/cosmos_cosmos-proto.bufbuild_es"

/**
 * SignMode represents a signing mode with its own security guarantees.
 *
 * This enum should be considered a registry of all known sign modes
 * in the Cosmos ecosystem. Apps are not expected to support all known
 * sign modes. Apps that would like to support custom  sign modes are
 * encouraged to open a small PR against this file to add a new case
 * to this SignMode enum describing their sign mode so that different
 * apps have a consistent version of this enum.
 *
 * @generated from enum cosmos.tx.signing.v1beta1.SignMode
 */
var SignMode = /*#__PURE__*/proto3.makeEnum("cosmos.tx.signing.v1beta1.SignMode", [{
  no: 0,
  name: "SIGN_MODE_UNSPECIFIED",
  localName: "UNSPECIFIED"
}, {
  no: 1,
  name: "SIGN_MODE_DIRECT",
  localName: "DIRECT"
}, {
  no: 2,
  name: "SIGN_MODE_TEXTUAL",
  localName: "TEXTUAL"
}, {
  no: 3,
  name: "SIGN_MODE_DIRECT_AUX",
  localName: "DIRECT_AUX"
}, {
  no: 127,
  name: "SIGN_MODE_LEGACY_AMINO_JSON",
  localName: "LEGACY_AMINO_JSON"
}, {
  no: 191,
  name: "SIGN_MODE_EIP_191",
  localName: "EIP_191"
}]);

// @generated by protoc-gen-es v1.0.0 with parameter "rewrite_imports=./google/api/**/*_pb.js:@buf/googleapis_googleapis.bufbuild_es,rewrite_imports=./gogoproto/**/*_pb.js:@buf/cosmos_gogo-proto.bufbuild_es,rewrite_imports=./cosmos_proto/**/*_pb.js:@buf/cosmos_cosmos-proto.bufbuild_es"

/**
 * Coin defines a token with a denomination and an amount.
 *
 * NOTE: The amount field is an Int which implements the custom method
 * signatures required by gogoproto.
 *
 * @generated from message cosmos.base.v1beta1.Coin
 */
var Coin = /*#__PURE__*/proto3.makeMessageType("cosmos.base.v1beta1.Coin", function () {
  return [{
    no: 1,
    name: "denom",
    kind: "scalar",
    T: 9 /* ScalarType.STRING */
  }, {
    no: 2,
    name: "amount",
    kind: "scalar",
    T: 9 /* ScalarType.STRING */
  }];
});

// @generated by protoc-gen-es v1.0.0 with parameter "rewrite_imports=./google/api/**/*_pb.js:@buf/googleapis_googleapis.bufbuild_es,rewrite_imports=./gogoproto/**/*_pb.js:@buf/cosmos_gogo-proto.bufbuild_es,rewrite_imports=./cosmos_proto/**/*_pb.js:@buf/cosmos_cosmos-proto.bufbuild_es"

/**
 * TxRaw is a variant of Tx that pins the signer's exact binary representation
 * of body and auth_info. This is used for signing, broadcasting and
 * verification. The binary `serialize(tx: TxRaw)` is stored in Tendermint and
 * the hash `sha256(serialize(tx: TxRaw))` becomes the "txhash", commonly used
 * as the transaction ID.
 *
 * @generated from message cosmos.tx.v1beta1.TxRaw
 */
var TxRaw = /*#__PURE__*/proto3.makeMessageType("cosmos.tx.v1beta1.TxRaw", function () {
  return [{
    no: 1,
    name: "body_bytes",
    kind: "scalar",
    T: 12 /* ScalarType.BYTES */
  }, {
    no: 2,
    name: "auth_info_bytes",
    kind: "scalar",
    T: 12 /* ScalarType.BYTES */
  }, {
    no: 3,
    name: "signatures",
    kind: "scalar",
    T: 12 /* ScalarType.BYTES */,
    repeated: true
  }];
});

/**
 * SignDoc is the type used for generating sign bytes for SIGN_MODE_DIRECT.
 *
 * @generated from message cosmos.tx.v1beta1.SignDoc
 */
var SignDoc = /*#__PURE__*/proto3.makeMessageType("cosmos.tx.v1beta1.SignDoc", function () {
  return [{
    no: 1,
    name: "body_bytes",
    kind: "scalar",
    T: 12 /* ScalarType.BYTES */
  }, {
    no: 2,
    name: "auth_info_bytes",
    kind: "scalar",
    T: 12 /* ScalarType.BYTES */
  }, {
    no: 3,
    name: "chain_id",
    kind: "scalar",
    T: 9 /* ScalarType.STRING */
  }, {
    no: 4,
    name: "account_number",
    kind: "scalar",
    T: 4 /* ScalarType.UINT64 */
  }];
});

/**
 * TxBody is the body of a transaction that all signers sign over.
 *
 * @generated from message cosmos.tx.v1beta1.TxBody
 */
var TxBody = /*#__PURE__*/proto3.makeMessageType("cosmos.tx.v1beta1.TxBody", function () {
  return [{
    no: 1,
    name: "messages",
    kind: "message",
    T: Any$1,
    repeated: true
  }, {
    no: 2,
    name: "memo",
    kind: "scalar",
    T: 9 /* ScalarType.STRING */
  }, {
    no: 3,
    name: "timeout_height",
    kind: "scalar",
    T: 4 /* ScalarType.UINT64 */
  }, {
    no: 1023,
    name: "extension_options",
    kind: "message",
    T: Any$1,
    repeated: true
  }, {
    no: 2047,
    name: "non_critical_extension_options",
    kind: "message",
    T: Any$1,
    repeated: true
  }];
});

/**
 * AuthInfo describes the fee and signer modes that are used to sign a
 * transaction.
 *
 * @generated from message cosmos.tx.v1beta1.AuthInfo
 */
var AuthInfo = /*#__PURE__*/proto3.makeMessageType("cosmos.tx.v1beta1.AuthInfo", function () {
  return [{
    no: 1,
    name: "signer_infos",
    kind: "message",
    T: SignerInfo,
    repeated: true
  }, {
    no: 2,
    name: "fee",
    kind: "message",
    T: Fee
  }, {
    no: 3,
    name: "tip",
    kind: "message",
    T: Tip
  }];
});

/**
 * SignerInfo describes the public key and signing mode of a single top-level
 * signer.
 *
 * @generated from message cosmos.tx.v1beta1.SignerInfo
 */
var SignerInfo = /*#__PURE__*/proto3.makeMessageType("cosmos.tx.v1beta1.SignerInfo", function () {
  return [{
    no: 1,
    name: "public_key",
    kind: "message",
    T: Any$1
  }, {
    no: 2,
    name: "mode_info",
    kind: "message",
    T: ModeInfo
  }, {
    no: 3,
    name: "sequence",
    kind: "scalar",
    T: 4 /* ScalarType.UINT64 */
  }];
});

/**
 * ModeInfo describes the signing mode of a single or nested multisig signer.
 *
 * @generated from message cosmos.tx.v1beta1.ModeInfo
 */
var ModeInfo = /*#__PURE__*/proto3.makeMessageType("cosmos.tx.v1beta1.ModeInfo", function () {
  return [{
    no: 1,
    name: "single",
    kind: "message",
    T: ModeInfo_Single,
    oneof: "sum"
  }, {
    no: 2,
    name: "multi",
    kind: "message",
    T: ModeInfo_Multi,
    oneof: "sum"
  }];
});

/**
 * Single is the mode info for a single signer. It is structured as a message
 * to allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the
 * future
 *
 * @generated from message cosmos.tx.v1beta1.ModeInfo.Single
 */
var ModeInfo_Single = /*#__PURE__*/proto3.makeMessageType("cosmos.tx.v1beta1.ModeInfo.Single", function () {
  return [{
    no: 1,
    name: "mode",
    kind: "enum",
    T: proto3.getEnumType(SignMode)
  }];
}, {
  localName: "ModeInfo_Single"
});

/**
 * Multi is the mode info for a multisig public key
 *
 * @generated from message cosmos.tx.v1beta1.ModeInfo.Multi
 */
var ModeInfo_Multi = /*#__PURE__*/proto3.makeMessageType("cosmos.tx.v1beta1.ModeInfo.Multi", function () {
  return [{
    no: 1,
    name: "bitarray",
    kind: "message",
    T: CompactBitArray
  }, {
    no: 2,
    name: "mode_infos",
    kind: "message",
    T: ModeInfo,
    repeated: true
  }];
}, {
  localName: "ModeInfo_Multi"
});

/**
 * Fee includes the amount of coins paid in fees and the maximum
 * gas to be used by the transaction. The ratio yields an effective "gasprice",
 * which must be above some miminum to be accepted into the mempool.
 *
 * @generated from message cosmos.tx.v1beta1.Fee
 */
var Fee = /*#__PURE__*/proto3.makeMessageType("cosmos.tx.v1beta1.Fee", function () {
  return [{
    no: 1,
    name: "amount",
    kind: "message",
    T: Coin,
    repeated: true
  }, {
    no: 2,
    name: "gas_limit",
    kind: "scalar",
    T: 4 /* ScalarType.UINT64 */
  }, {
    no: 3,
    name: "payer",
    kind: "scalar",
    T: 9 /* ScalarType.STRING */
  }, {
    no: 4,
    name: "granter",
    kind: "scalar",
    T: 9 /* ScalarType.STRING */
  }];
});

/**
 * Tip is the tip used for meta-transactions.
 *
 * Since: cosmos-sdk 0.46
 *
 * @generated from message cosmos.tx.v1beta1.Tip
 */
var Tip = /*#__PURE__*/proto3.makeMessageType("cosmos.tx.v1beta1.Tip", function () {
  return [{
    no: 1,
    name: "amount",
    kind: "message",
    T: Coin,
    repeated: true
  }, {
    no: 2,
    name: "tipper",
    kind: "scalar",
    T: 9 /* ScalarType.STRING */
  }];
});

// @generated by protoc-gen-es v1.0.0 with parameter "rewrite_imports=./google/api/**/*_pb.js:@buf/googleapis_googleapis.bufbuild_es,rewrite_imports=./gogoproto/**/*_pb.js:@buf/cosmos_gogo-proto.bufbuild_es,rewrite_imports=./cosmos_proto/**/*_pb.js:@buf/cosmos_cosmos-proto.bufbuild_es"

/**
 * PubKey defines a secp256k1 public key
 * Key is the compressed form of the pubkey. The first byte depends is a 0x02 byte
 * if the y-coordinate is the lexicographically largest of the two associated with
 * the x-coordinate. Otherwise the first byte is a 0x03.
 * This prefix is followed with the x-coordinate.
 *
 * @generated from message cosmos.crypto.secp256k1.PubKey
 */
var PubKey = /*#__PURE__*/proto3.makeMessageType("cosmos.crypto.secp256k1.PubKey", function () {
  return [{
    no: 1,
    name: "key",
    kind: "scalar",
    T: 12 /* ScalarType.BYTES */
  }];
});

// @generated by protoc-gen-es v1.0.0 with parameter "rewrite_imports=./google/api/**/*_pb.js:@buf/googleapis_googleapis.bufbuild_es,rewrite_imports=./gogoproto/**/*_pb.js:@buf/cosmos_gogo-proto.bufbuild_es,rewrite_imports=./cosmos_proto/**/*_pb.js:@buf/cosmos_cosmos-proto.bufbuild_es,rewrite_imports=./cosmos/msg/v1/**/*_pb.js:@buf/cosmos_cosmos-sdk.bufbuild_es,rewrite_imports=./cosmos/base/query/v1beta1/**/*_pb.js:@buf/cosmos_cosmos-sdk.bufbuild_es,rewrite_imports=./cosmos/auth/v1beta1/**/*_pb.js:@buf/cosmos_cosmos-sdk.bufbuild_es,rewrite_imports=./amino/**/*_pb.js:@buf/cosmos_cosmos-sdk.bufbuild_es"

/**
 * PubKey defines a type alias for an ecdsa.PublicKey that implements
 * Tendermint's PubKey interface. It represents the 33-byte compressed public
 * key format.
 *
 * @generated from message ethermint.crypto.v1.ethsecp256k1.PubKey
 */
var PubKey$1 = /*#__PURE__*/proto3.makeMessageType("ethermint.crypto.v1.ethsecp256k1.PubKey", function () {
  return [{
    no: 1,
    name: "key",
    kind: "scalar",
    T: 12 /* ScalarType.BYTES */
  }];
});

var BroadcastMode;
(function (BroadcastMode) {
  BroadcastMode["Unspecified"] = "BROADCAST_MODE_UNSPECIFIED";
  BroadcastMode["Block"] = "BROADCAST_MODE_BLOCK";
  BroadcastMode["Sync"] = "BROADCAST_MODE_SYNC";
  BroadcastMode["Async"] = "BROADCAST_MODE_ASYNC";
})(BroadcastMode || (BroadcastMode = {}));

var wrapTypeToArray = function wrapTypeToArray(obj) {
  return Array.isArray(obj) ? obj : [obj];
};
function createAnyMessage$1(msg) {
  var binaryValue;
  try {
    binaryValue = msg.message.serializeBinary();
  } catch (e) {
    binaryValue = msg.message.toBinary();
  }
  //@ts-ignore
  return new Any$1({
    typeUrl: "" + (msg.path.startsWith('/') ? msg.path : '/' + msg.path),
    value: binaryValue
  });
}
function createBodyWithMultipleMessages(messages, memo) {
  var content = [];
  messages.forEach(function (message) {
    content.push(createAnyMessage$1({
      message: message.message,
      path: message.type
    }));
  });
  //@ts-ignore
  return new TxBody({
    messages: content,
    memo: memo
  });
}
function createSignerInfo$1(algo, publicKey, sequence, mode) {
  var pubkey;
  // NOTE: secp256k1 is going to be removed from evmos
  if (algo === 'secp256k1') {
    pubkey = {
      //@ts-ignore
      message: new PubKey({
        key: publicKey
      }),
      path: 'cosmos.crypto.secp256k1.PubKey'
    };
  } else {
    // NOTE: assume ethsecp256k1 by default because after mainnet is the only one that is going to be supported
    pubkey = {
      //@ts-ignore
      message: new PubKey$1({
        key: publicKey
      }),
      path: 'ethermint.crypto.v1.ethsecp256k1.PubKey'
    };
  }
  //@ts-ignore
  var signerInfo = new SignerInfo({
    publicKey: createAnyMessage$1(pubkey),
    //@ts-ignore
    modeInfo: new ModeInfo({
      sum: {
        //@ts-ignore
        value: new ModeInfo_Single({
          mode: mode
        }),
        "case": 'single'
      }
    }),
    sequence: BigInt(sequence)
  });
  return signerInfo;
}
function createAuthInfo$1(signerInfo, fee) {
  //@ts-ignore
  return new AuthInfo({
    signerInfos: [signerInfo],
    fee: fee
  });
}
function createSigDoc$1(bodyBytes, authInfoBytes, chainId, accountNumber) {
  //@ts-ignore
  return new SignDoc({
    bodyBytes: bodyBytes,
    authInfoBytes: authInfoBytes,
    chainId: chainId,
    accountNumber: BigInt(accountNumber)
  });
}
function createFee$1(fee, denom, gasLimit) {
  //@ts-ignore
  return new Fee({
    amount: [
    //@ts-ignore
    new Coin({
      denom: denom,
      amount: fee
    })],
    gasLimit: BigInt(gasLimit)
  });
}
function createTransactionWithMultipleMessages(messages, memo, fee, gasLimit, algo, pubKey, sequence, accountNumber, chainId) {
  var body = createBodyWithMultipleMessages(messages, memo);
  var feeMessage = createFee$1(fee.amount, fee.denom, gasLimit);
  var pubKeyDecoded = Buffer.from(pubKey, 'base64');
  // AMINO
  var signInfoAmino = createSignerInfo$1(algo, new Uint8Array(pubKeyDecoded), sequence, SignMode.LEGACY_AMINO_JSON);
  var authInfoAmino = createAuthInfo$1(signInfoAmino, feeMessage);
  var signDocAmino = createSigDoc$1(body.toBinary(), authInfoAmino.toBinary(), chainId, accountNumber);
  var hashAmino = new Keccak(256);
  hashAmino.update(Buffer.from(signDocAmino.toBinary()));
  var toSignAmino = hashAmino.digest('binary');
  // SignDirect
  var signInfoDirect = createSignerInfo$1(algo, new Uint8Array(pubKeyDecoded), sequence, SignMode.DIRECT);
  var authInfoDirect = createAuthInfo$1(signInfoDirect, feeMessage);
  var signDocDirect = createSigDoc$1(body.toBinary(), authInfoDirect.toBinary(), chainId, accountNumber);
  var hashDirect = new Keccak(256);
  hashDirect.update(Buffer.from(signDocDirect.toBinary()));
  var toSignDirect = hashDirect.digest('binary');
  return {
    legacyAmino: {
      body: body,
      authInfo: authInfoAmino,
      signBytes: toSignAmino.toString('base64')
    },
    signDirect: {
      body: body,
      authInfo: authInfoDirect,
      signBytes: toSignDirect.toString('base64')
    }
  };
}
var createCosmosPayload = function createCosmosPayload(context, cosmosPayload, fee) {
  var _fee$gas;
  var sender = context.sender,
    chain = context.chain,
    memo = context.memo;
  var messages = wrapTypeToArray(cosmosPayload);
  return createTransactionWithMultipleMessages(messages, memo, {
    amount: fee.amount ? fee.amount[0].amount : DEFAULT_STD_FEE.amount[0].amount,
    denom: ROUTER_DENOM,
    gas: fee.gas ? fee.gas : DEFAULT_STD_FEE.gas
  }, parseInt((_fee$gas = fee.gas) != null ? _fee$gas : DEFAULT_GAS_LIMIT.toString(), 10), 'ethsecp256', sender.pubkey, sender.sequence, sender.accountNumber, chain.cosmosChainId);
};
function generatePostBodyBroadcast(txRaw, broadcastMode) {
  if (broadcastMode === void 0) {
    broadcastMode = BroadcastMode.Sync;
  }
  var txBase64 = Buffer.from(txRaw.message.toBinary()).toString('base64');
  return "{ \"tx_bytes\": \"" + txBase64 + "\", \"mode\": \"" + broadcastMode + "\" }";
}
var getPostOptions = function getPostOptions(signedTx) {
  var postOptions = {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: generatePostBodyBroadcast(signedTx)
  };
  return postOptions;
};

var getEtherMintTxPayload = function getEtherMintTxPayload(context, eipData) {
  var _eipData$fee;
  var eip712Payload = getEip712TypedData(eipData);
  var cosmosMsg = Array.isArray(eipData.msgs) ? eipData.msgs.map(function (msg) {
    return msg.toDirectSign();
  }) : eipData.msgs.toDirectSign();
  var cosmosPayload = createCosmosPayload(context, cosmosMsg, (_eipData$fee = eipData.fee) != null ? _eipData$fee : DEFAULT_STD_FEE);
  return {
    signDirect: cosmosPayload.signDirect,
    legacyAmino: cosmosPayload.legacyAmino,
    eipToSign: eip712Payload
  };
};
function createTxRawForBroadcast(bodyBytes, authInfoBytes, signatures) {
  //@ts-ignore
  var message = new TxRaw({
    bodyBytes: bodyBytes,
    authInfoBytes: authInfoBytes,
    signatures: signatures
  });
  return {
    message: message,
    path: TxRaw.typeName
  };
}
var simulateRawTx = /*#__PURE__*/function () {
  var _ref = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(signedTx, nodeUrl) {
    var postOptions, broadcastEndpoint, broadcastPost, response;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          postOptions = getPostOptions(signedTx);
          broadcastEndpoint = nodeUrl + '/cosmos/tx/v1beta1/simulate';
          _context.next = 4;
          return fetch(broadcastEndpoint, postOptions);
        case 4:
          broadcastPost = _context.sent;
          _context.next = 7;
          return broadcastPost.json();
        case 7:
          response = _context.sent;
          return _context.abrupt("return", response);
        case 9:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function simulateRawTx(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
var broadcastRawTx = /*#__PURE__*/function () {
  var _ref2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(signedTx, nodeUrl) {
    var postOptions, broadcastEndpoint, broadcastPost, response;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          postOptions = getPostOptions(signedTx);
          broadcastEndpoint = nodeUrl + '/cosmos/tx/v1beta1/txs';
          _context2.next = 4;
          return fetch(broadcastEndpoint, postOptions);
        case 4:
          broadcastPost = _context2.sent;
          _context2.next = 7;
          return broadcastPost.json();
        case 7:
          response = _context2.sent;
          return _context2.abrupt("return", response);
        case 9:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function broadcastRawTx(_x3, _x4) {
    return _ref2.apply(this, arguments);
  };
}();

var _ActionTxType;
var MsgUnjail = '/cosmos.slashing.v1beta1.MsgUnjail';
var MsgExec$1 = '/cosmos.authz.v1beta1.MsgExec';
var MsgUpdateAdmin$1 = '/cosmwasm.wasm.v1.MsgUpdateAdmin';
var MsgStoreCode$1 = '/cosmwasm.wasm.v1.MsgStoreCode';
var MsgMigrateContract$1 = '/cosmwasm.wasm.v1.MsgMigrateContract';
var MsgExecuteContract$1 = '/cosmwasm.wasm.v1.MsgExecuteContract';
var MsgGrant$1 = '/cosmos.authz.v1beta1.MsgGrant';
var MsgRevoke$1 = '/cosmos.authz.v1beta1.MsgRevoke';
var MsgSend$1 = '/cosmos.authz.v1beta1.MsgSend';
var MsgWithdrawDelegatorReward$1 = '/cosmos.authz.v1beta1.MsgWithdrawDelegatorReward';
var MsgWithdrawValidatorCommission = '/cosmos.authz.v1beta1.MsgWithdrawValidatorCommission';
var MsgDeposit$1 = '/cosmos.authz.v1beta1.MsgDeposit';
var MsgSubmitProposal = '/cosmos.authz.v1beta1.MsgSubmitProposal';
var MsgVote$1 = '/cosmos.authz.v1beta1.MsgVote';
var MsgDelegate$1 = '/cosmos.authz.v1beta1.MsgDelegate';
var MsgEditValidator = '/cosmos.authz.v1beta1.MsgEditValidator';
var MsgUndelegate$1 = '/cosmos.authz.v1beta1.MsgUndelegate';
var MsgApproveFeepayerRequest$1 = '/routerprotocol.routerchain.metastore.MsgApproveFeepayerRequest';
var MsgCreateMetadataRequest = '/routerprotocol.routerchain.metastore.MsgCreateMetadataRequest';
var MsgCwStoreCode$1 = '/routerprotocol.routerchain.rwasm.MsgCwStoreCode';
var MsgExecuteCwContract$1 = '/routerprotocol.routerchain.rwasm.MsgExecuteCwContract';
var MsgInstantiateCwContract$1 = '/routerprotocol.routerchain.rwasm.MsgInstantiateCwContract';
var MsgMigrateCwContract$1 = '/routerprotocol.routerchain.rwasm.MsgMigrateCwContract';
var MsgSetOrchestratorAddress = '/routerprotocol.routerchain.attestation.MsgSetOrchestratorAddress';
var MsgValsetUpdatedClaim = '/routerprotocol.routerchain.attestation.MsgValsetUpdatedClaim';
var MsgValsetConfirm = '/routerprotocol.routerchain.attestation.MsgValsetConfirm';
var MsgConfirmCrosschainAckRequest = '/routerprotocol.routerchain.crosschain.MsgConfirmCrosschainAckRequest';
var MsgCrosschainAckRequest = '/routerprotocol.routerchain.crosschain.MsgCrosschainAckRequest';
var MsgCrosschainRequest = '/routerprotocol.routerchain.crosschain.MsgCrosschainRequest';
var MsgCrosschainAckReceipt = '/routerprotocol.routerchain.crosschain.MsgCrosschainAckReceipt';
var MsgConfirmCrosschainRequest = '/routerprotocol.routerchain.crosschain.MsgConfirmCrosschainRequest';
var MsgIncrementCrosstalkAckGas = '/routerprotocol.routerchain.crosstalk.MsgIncrementCrosstalkAckGas';
var MsgCrossTalkRequest = '/routerprotocol.routerchain.crosstalk.MsgCrossTalkRequest';
var MsgIncrementCrosstalkDestGas = '/routerprotocol.routerchain.crosstalk.MsgIncrementCrosstalkDestGas';
var MsgCrossTalkAckReceipt = '/routerprotocol.routerchain.crosstalk.MsgCrossTalkAckReceipt';
var MsgCrossTalkAckRequest = '/routerprotocol.routerchain.crosstalk.MsgCrossTalkAckRequest';
var MsgSetCrosstalkFeePayer = '/routerprotocol.routerchain.crosstalk.MsgSetCrosstalkFeePayer';
var MsgInboundRequest = '/routerprotocol.routerchain.inbound.MsgInboundRequest';
var MsgOutgoingBatchConfirm = '/routerprotocol.routerchain.outbound.MsgOutgoingBatchConfirm';
var MsgOutboundAckRequest = '/routerprotocol.routerchain.outbound.MsgOutboundAckRequest';
var MsgOutboundBatchRequest = '/routerprotocol.routerchain.outbound.MsgOutboundBatchRequest';
var MsgTokenPrices = '/routerprotocol.routerchain.pricefeed.MsgTokenPrices';
var MsgFundsPaid = '/routerprotocol.routerchain.voyager.MsgFundsPaid';
var MsgGasPrices = '/routerprotocol.routerchain.voyager.MsgFundsDeposited';
var ActionTxType = (_ActionTxType = {}, _ActionTxType[/*#__PURE__*/MsgGrant$1.toLowerCase()] = 'Grant', _ActionTxType[/*#__PURE__*/MsgUnjail.toLowerCase()] = 'Unjail', _ActionTxType[/*#__PURE__*/MsgExec$1.toLowerCase()] = 'Exec', _ActionTxType[/*#__PURE__*/MsgRevoke$1.toLowerCase()] = 'Revoke', _ActionTxType[/*#__PURE__*/MsgSend$1.toLowerCase()] = 'Send Coins', _ActionTxType[/*#__PURE__*/MsgWithdrawDelegatorReward$1.toLowerCase()] = 'Claim Reward', _ActionTxType[/*#__PURE__*/MsgWithdrawValidatorCommission.toLowerCase()] = 'Withdraw Commission', _ActionTxType[/*#__PURE__*/MsgDeposit$1.toLowerCase()] = 'Deposit', _ActionTxType[/*#__PURE__*/MsgSubmitProposal.toLowerCase()] = 'Submit Proposal', _ActionTxType[/*#__PURE__*/MsgVote$1.toLowerCase()] = 'Vote', _ActionTxType[/*#__PURE__*/MsgDelegate$1.toLowerCase()] = 'Delegate', _ActionTxType[/*#__PURE__*/MsgEditValidator.toLowerCase()] = 'Edit Validator', _ActionTxType[/*#__PURE__*/MsgUndelegate$1.toLowerCase()] = 'Undelegate', _ActionTxType[/*#__PURE__*/MsgApproveFeepayerRequest$1.toLowerCase()] = 'Approve Fee Payer', _ActionTxType[/*#__PURE__*/MsgCreateMetadataRequest.toLowerCase()] = 'Create Metadata Request', _ActionTxType[/*#__PURE__*/MsgCwStoreCode$1.toLowerCase()] = 'Store Code', _ActionTxType[/*#__PURE__*/MsgUpdateAdmin$1.toLowerCase()] = 'Update Admin', _ActionTxType[/*#__PURE__*/MsgStoreCode$1.toLowerCase()] = 'Store Code', _ActionTxType[/*#__PURE__*/MsgMigrateContract$1.toLowerCase()] = 'Migrate Contract', _ActionTxType[/*#__PURE__*/MsgExecuteContract$1.toLowerCase()] = 'Execute', _ActionTxType[/*#__PURE__*/MsgExecuteCwContract$1.toLowerCase()] = 'Execute', _ActionTxType[/*#__PURE__*/MsgInstantiateCwContract$1.toLowerCase()] = 'Instantiate', _ActionTxType[/*#__PURE__*/MsgMigrateCwContract$1.toLowerCase()] = 'Migrate', _ActionTxType[/*#__PURE__*/MsgSetOrchestratorAddress.toLowerCase()] = 'Set Orchestrator Address', _ActionTxType[/*#__PURE__*/MsgValsetUpdatedClaim.toLowerCase()] = 'Valset Updated Claim', _ActionTxType[/*#__PURE__*/MsgValsetConfirm.toLowerCase()] = 'Valset Confirm', _ActionTxType[/*#__PURE__*/MsgConfirmCrosschainAckRequest.toLowerCase()] = 'Confirm Crossschain Ack Request', _ActionTxType[/*#__PURE__*/MsgCrosschainAckRequest.toLowerCase()] = 'Crosschain Ack Request', _ActionTxType[/*#__PURE__*/MsgCrosschainRequest.toLowerCase()] = 'Crosschain Request', _ActionTxType[/*#__PURE__*/MsgCrosschainAckReceipt.toLowerCase()] = 'Crosschain Ack Receipt', _ActionTxType[/*#__PURE__*/MsgConfirmCrosschainRequest.toLowerCase()] = 'Confirm Crosschain Request', _ActionTxType[/*#__PURE__*/MsgIncrementCrosstalkAckGas.toLowerCase()] = 'Increment Crosstalk Ack Gas', _ActionTxType[/*#__PURE__*/MsgCrossTalkRequest.toLowerCase()] = 'CrossTalk Request', _ActionTxType[/*#__PURE__*/MsgIncrementCrosstalkDestGas.toLowerCase()] = 'Increment Crosstalk DestGas', _ActionTxType[/*#__PURE__*/MsgCrossTalkAckReceipt.toLowerCase()] = 'CrossTalk Ack Receipt', _ActionTxType[/*#__PURE__*/MsgCrossTalkAckRequest.toLowerCase()] = 'CrossTalk Ack Request', _ActionTxType[/*#__PURE__*/MsgSetCrosstalkFeePayer.toLowerCase()] = 'Set Crosstalk FeePayer', _ActionTxType[/*#__PURE__*/MsgInboundRequest.toLowerCase()] = 'Inbound Request', _ActionTxType[/*#__PURE__*/MsgOutgoingBatchConfirm.toLowerCase()] = 'Outgoing Batch Confirm', _ActionTxType[/*#__PURE__*/MsgOutboundAckRequest.toLowerCase()] = 'Outbound Ack Request', _ActionTxType[/*#__PURE__*/MsgOutboundBatchRequest.toLowerCase()] = 'Outbound Batch Request', _ActionTxType[/*#__PURE__*/MsgTokenPrices.toLowerCase()] = 'Token Prices', _ActionTxType[/*#__PURE__*/MsgFundsPaid.toLowerCase()] = 'Funds Paid', _ActionTxType[/*#__PURE__*/MsgGasPrices.toLowerCase()] = 'Gas Prices', _ActionTxType);
var getTransactionTypes = function getTransactionTypes(rawLog) {
  var txTypes = [];
  rawLog[0].events.forEach(function (eventLog) {
    if (eventLog.type === 'message') {
      eventLog.attributes.forEach(function (attribute) {
        if (attribute.key === 'action') {
          try {
            var txType = ActionTxType[attribute.value.toLowerCase()];
            if (txType) {
              txTypes.push(txType);
            }
          } catch (e) {
            console.log('getTransactionTypes error =>', e);
          }
        }
      });
    }
  });
  return txTypes;
};

var BaseWasmQuery = function BaseWasmQuery(params) {
  this.params = params;
};

var QueryContractAllowance = /*#__PURE__*/function (_BaseWasmQuery) {
  _inheritsLoose(QueryContractAllowance, _BaseWasmQuery);
  function QueryContractAllowance() {
    return _BaseWasmQuery.apply(this, arguments) || this;
  }
  var _proto = QueryContractAllowance.prototype;
  _proto.toPayload = function toPayload() {
    return toBase64({
      allowance: {
        owner: this.params.owner,
        spender: this.params.spender
      }
    });
  };
  return QueryContractAllowance;
}(BaseWasmQuery);

var QueryContractConfig = /*#__PURE__*/function (_BaseWasmQuery) {
  _inheritsLoose(QueryContractConfig, _BaseWasmQuery);
  function QueryContractConfig() {
    return _BaseWasmQuery.apply(this, arguments) || this;
  }
  var _proto = QueryContractConfig.prototype;
  _proto.toPayload = function toPayload() {
    return toBase64({
      config: {}
    });
  };
  return QueryContractConfig;
}(BaseWasmQuery);

var QueryVaultMarketId = /*#__PURE__*/function (_BaseWasmQuery) {
  _inheritsLoose(QueryVaultMarketId, _BaseWasmQuery);
  function QueryVaultMarketId() {
    return _BaseWasmQuery.apply(this, arguments) || this;
  }
  var _proto = QueryVaultMarketId.prototype;
  _proto.toPayload = function toPayload() {
    return toBase64({
      get_market_id: {
        subaccount_id: this.params.subaccountId
      }
    });
  };
  return QueryVaultMarketId;
}(BaseWasmQuery);

var QueryRegisteredVaults = /*#__PURE__*/function (_BaseWasmQuery) {
  _inheritsLoose(QueryRegisteredVaults, _BaseWasmQuery);
  function QueryRegisteredVaults() {
    return _BaseWasmQuery.apply(this, arguments) || this;
  }
  var _proto = QueryRegisteredVaults.prototype;
  _proto.toPayload = function toPayload() {
    return toBase64({
      get_registered_vaults: {}
    });
  };
  return QueryRegisteredVaults;
}(BaseWasmQuery);

var QueryVaultTotalLpSupply = /*#__PURE__*/function (_BaseWasmQuery) {
  _inheritsLoose(QueryVaultTotalLpSupply, _BaseWasmQuery);
  function QueryVaultTotalLpSupply() {
    return _BaseWasmQuery.apply(this, arguments) || this;
  }
  var _proto = QueryVaultTotalLpSupply.prototype;
  _proto.toPayload = function toPayload() {
    return toBase64({
      get_total_lp_supply: {
        subaccount_id: this.params.subaccountId
      }
    });
  };
  return QueryVaultTotalLpSupply;
}(BaseWasmQuery);

var QueryVaultUserLpBalance = /*#__PURE__*/function (_BaseWasmQuery) {
  _inheritsLoose(QueryVaultUserLpBalance, _BaseWasmQuery);
  function QueryVaultUserLpBalance() {
    return _BaseWasmQuery.apply(this, arguments) || this;
  }
  var _proto = QueryVaultUserLpBalance.prototype;
  _proto.toPayload = function toPayload() {
    return toBase64({
      get_user_lp_balance: {
        subaccount_id: this.params.subaccountId,
        user_address: this.params.userAddress
      }
    });
  };
  return QueryVaultUserLpBalance;
}(BaseWasmQuery);

/**
 * @hidden
 */
var SupernovaQueryTransformer = /*#__PURE__*/function () {
  function SupernovaQueryTransformer() {}
  SupernovaQueryTransformer.masterContractConfigResponseToMasterContractConfig = function masterContractConfigResponseToMasterContractConfig(response) {
    var data = fromBase64(response.data);
    return {
      distributionContract: data.distribution_contract,
      ninjaToken: data.ninja_token,
      owner: data.owner
    };
  };
  SupernovaQueryTransformer.vaultContractConfigResponseToDerivativeVaultConfig = function vaultContractConfigResponseToDerivativeVaultConfig(response) {
    var _fromBase = fromBase64(response.data),
      config = _fromBase.config;
    return {
      cw20CodeId: config.cw20_code_id || '',
      cw20Label: config.cw20_label || '',
      defaultMidPriceVolatilityRatio: config.default_mid_price_volatility_ratio || '',
      emergencyOracleVolatilitySampleSize: config.emergency_oracle_volatility_sample_size || '',
      headChangeToleranceRatio: config.head_change_tolerance_ratio || '',
      headToTailDeviationRatio: config.head_to_tail_deviation_ratio || '',
      lastValidMarkPrice: config.last_valid_mark_price || '',
      leverage: config.leverage || '',
      leveragedActiveCapitalToMaxPositionExposureRatio: config.leveraged_active_capital_to_max_position_exposure_ratio || '',
      lpName: config.lp_name || '',
      lpSymbol: config.lp_symbol || '',
      lpTokenAddress: config.lp_token_address || '',
      marketId: config.market_id || '',
      masterAddress: config.master_address || '',
      maxActiveCapitalUtilizationRatio: config.max_active_capital_utilization_ratio || '',
      minOracleVolatilitySampleSize: config.min_oracle_volatility_sample_size || '',
      minProximityToLiquidation: config.min_proximity_to_liquidation || '',
      minTradeVolatilitySampleSize: config.min_trade_volatility_sample_size || '',
      minVolatilityRatio: config.min_volatility_ratio || '',
      oracleVolatilityGroupSec: config.oracle_volatility_group_sec || '',
      orderDensity: config.order_density || '',
      postReductionPercOfMaxPosition: config.post_reduction_perc_of_max_position || '',
      reservationPriceSensitivityRatio: config.reservation_price_sensitivity_ratio || '',
      reservationSpreadSensitivityRatio: config.reservation_spread_sensitivity_ratio || '',
      tradeVolatilityGroupSec: config.trade_volatility_group_sec || '',
      cw20MarketingInfo: config.cw20_marketing_info || '',
      feeRecipient: config.fee_recipient || '',
      owner: config.owner || '',
      subaccountId: config.subaccount_id || ''
    };
  };
  SupernovaQueryTransformer.vaultContractConfigResponseToSpotVaultContractConfig = function vaultContractConfigResponseToSpotVaultContractConfig(response) {
    var _fromBase2 = fromBase64(response.data),
      config = _fromBase2.config;
    return {
      balanceReduceRatio: config.balance_reduce_ratio || '',
      cw20CodeId: config.cw20_code_id || '',
      cw20Label: config.cw20_label || '',
      defaultMidPriceVolatilityRatio: config.default_mid_price_volatility_ratio || '',
      firstThreshold: config.first_threshold || '',
      headChangeToleranceRatio: config.head_change_tolerance_ratio || '',
      lpName: config.lp_name || '',
      lpSymbol: config.lp_symbol || '',
      lpTokenAddress: config.lp_token_address || '',
      marketId: config.market_id || '',
      marketOrderLowerBoundRatio: config.market_order_lower_bound_ratio || '',
      marketOrderUpperBoundRatio: config.market_order_upper_bound_ratio || '',
      masterAddress: config.master_address || '',
      maxActiveCapitalUtilizationRatio: config.max_active_capital_utilization_ratio || '',
      maxAvgOrdersPriceDeviationRatio: config.max_avg_orders_price_deviation_ratio || '',
      midPriceTailDeviationRatio: config.mid_price_tail_deviation_ratio || '',
      minHeadToMidDeviationRatio: config.min_head_to_mid_deviation_ratio || '',
      minHeadToTailDeviationRatio: config.min_head_to_tail_deviation_ratio || '',
      minTradeVolatilitySampleSize: config.min_trade_volatility_sample_size || '',
      orderDensity: config.order_density || '',
      reduceProportion: config.reduce_proportion || '',
      reservationPriceSensitivityRatio: config.reservation_price_sensitivity_ratio || '',
      reservationSpreadSensitivityRatio: config.reservation_spread_sensitivity_ratio || '',
      secondThreshold: config.second_threshold || '',
      tradeVolatilityGroupCount: config.trade_volatility_group_count || '',
      tradeVolatilityGroupSec: config.trade_volatility_group_sec || '',
      cw20MarketingInfo: config.cw20_marketing_info,
      feeRecipient: config.fee_recipient || '',
      owner: config.owner || '',
      subaccountId: config.subaccount_id || ''
    };
  };
  SupernovaQueryTransformer.vaultUserLpAllowanceResponseToVaultUserLpAllowance = function vaultUserLpAllowanceResponseToVaultUserLpAllowance(response) {
    var data = fromBase64(response.data);
    return {
      allowance: data.allowance
    };
  };
  SupernovaQueryTransformer.vaultMarketIdResponseToVaultMarketId = function vaultMarketIdResponseToVaultMarketId(response) {
    var data = fromBase64(response.data);
    return {
      marketId: data.market_id
    };
  };
  SupernovaQueryTransformer.vaultTotalLpSupplyResponseToVaultTotalLpSupply = function vaultTotalLpSupplyResponseToVaultTotalLpSupply(response) {
    var data = fromBase64(response.data);
    return {
      totalSupply: data.total_supply
    };
  };
  SupernovaQueryTransformer.vaultUserLpBalanceResponseToVaultUserLpBalance = function vaultUserLpBalanceResponseToVaultUserLpBalance(response) {
    var data = fromBase64(response.data);
    return {
      balance: data.balance
    };
  };
  SupernovaQueryTransformer.registeredVaultsResponseToRegisteredVaults = function registeredVaultsResponseToRegisteredVaults(response) {
    var data = fromBase64(response.data);
    return data.registered_vaults.map(function (payload) {
      return {
        masterSubaccountId: payload.master_subaccount_id,
        vaultAddress: payload.vault_address
      };
    });
  };
  return SupernovaQueryTransformer;
}();

var TxGrpcClient = /*#__PURE__*/function () {
  function TxGrpcClient(endpoint) {
    this.endpoint = endpoint;
    this.txService = new ServiceClient(endpoint, {
      transport: isServerSide() ? NodeHttpTransport() : undefined
    });
  }
  var _proto = TxGrpcClient.prototype;
  _proto.fetchTx = /*#__PURE__*/function () {
    var _fetchTx = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(hash) {
      var request, response, txResponse;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            request = new GetTxRequest();
            request.setHash(hash);
            _context.prev = 2;
            _context.next = 5;
            return this.request(request, Service.GetTx);
          case 5:
            response = _context.sent;
            txResponse = response.getTxResponse();
            if (txResponse) {
              _context.next = 9;
              break;
            }
            throw new GrpcUnaryRequestException(new Error("The transaction with " + hash + " is not found"), {
              context: 'TxGrpcApi',
              contextModule: 'fetch-tx'
            });
          case 9:
            if (!(txResponse.getCode() !== 0)) {
              _context.next = 11;
              break;
            }
            throw new TransactionException(new Error(txResponse.getRawLog()), {
              contextCode: txResponse.getCode(),
              contextModule: txResponse.getCodespace()
            });
          case 11:
            return _context.abrupt("return", _extends({}, txResponse.toObject(), {
              txHash: txResponse.getTxhash()
            }));
          case 14:
            _context.prev = 14;
            _context.t0 = _context["catch"](2);
            if (!(_context.t0 instanceof TransactionException)) {
              _context.next = 18;
              break;
            }
            throw _context.t0;
          case 18:
            if (!(_context.t0 instanceof GrpcUnaryRequestException)) {
              _context.next = 20;
              break;
            }
            throw _context.t0;
          case 20:
            throw new GrpcUnaryRequestException(new Error('There was an issue while fetching transaction details'), {
              context: 'TxGrpcApi',
              contextModule: 'fetch-tx'
            });
          case 21:
          case "end":
            return _context.stop();
        }
      }, _callee, this, [[2, 14]]);
    }));
    function fetchTx(_x) {
      return _fetchTx.apply(this, arguments);
    }
    return fetchTx;
  }();
  _proto.fetchTxPoll = /*#__PURE__*/function () {
    var _fetchTxPoll = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(txHash, timeout) {
      var POLL_INTERVAL, i, txResponse;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            if (timeout === void 0) {
              timeout = DEFAULT_TX_BLOCK_INCLUSION_TIMEOUT_IN_MS ;
            }
            POLL_INTERVAL = DEFAULT_BLOCK_TIME_IN_SECONDS * 1000;
            i = 0;
          case 3:
            if (!(i <= timeout / POLL_INTERVAL)) {
              _context2.next = 21;
              break;
            }
            _context2.prev = 4;
            _context2.next = 7;
            return this.fetchTx(txHash);
          case 7:
            txResponse = _context2.sent;
            if (!txResponse) {
              _context2.next = 10;
              break;
            }
            return _context2.abrupt("return", txResponse);
          case 10:
            _context2.next = 16;
            break;
          case 12:
            _context2.prev = 12;
            _context2.t0 = _context2["catch"](4);
            if (!(_context2.t0 instanceof TransactionException)) {
              _context2.next = 16;
              break;
            }
            throw _context2.t0;
          case 16:
            _context2.next = 18;
            return new Promise(function (resolve) {
              return setTimeout(resolve, POLL_INTERVAL);
            });
          case 18:
            i += 1;
            _context2.next = 3;
            break;
          case 21:
            throw new GrpcUnaryRequestException(new Error("Transaction was not included in a block before timeout of " + timeout + "ms"), {
              context: 'TxGrpcApi',
              contextModule: 'fetch-tx-poll'
            });
          case 22:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[4, 12]]);
    }));
    function fetchTxPoll(_x2, _x3) {
      return _fetchTxPoll.apply(this, arguments);
    }
    return fetchTxPoll;
  }();
  _proto.simulate = /*#__PURE__*/function () {
    var _simulate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(txRaw) {
      var txService, txRawClone, simulateRequest;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            txService = this.txService;
            txRawClone = txRaw.clone();
            simulateRequest = new SimulateRequest();
            if (txRawClone.getSignaturesList().length === 0) {
              txRawClone.setSignaturesList([new Uint8Array(0)]);
            }
            simulateRequest.setTxBytes(txRawClone.serializeBinary());
            _context3.prev = 5;
            _context3.next = 8;
            return new Promise(function (resolve, reject) {
              return txService.simulate(simulateRequest, function (error, response) {
                if (error || !response) {
                  return reject(error);
                }
                var result = response.getResult();
                var gasInfo = response.getGasInfo();
                return resolve({
                  result: result ? result.toObject() : {},
                  gasInfo: gasInfo ? gasInfo.toObject() : {}
                });
              });
            });
          case 8:
            return _context3.abrupt("return", _context3.sent);
          case 11:
            _context3.prev = 11;
            _context3.t0 = _context3["catch"](5);
            throw new TransactionException(new Error(_context3.t0.message));
          case 14:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this, [[5, 11]]);
    }));
    function simulate(_x4) {
      return _simulate.apply(this, arguments);
    }
    return simulate;
  }();
  _proto.broadcast = /*#__PURE__*/function () {
    var _broadcast = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(txRaw, options) {
      var _this = this;
      var txService, _ref, mode, timeout, broadcastTxRequest;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            txService = this.txService;
            _ref = options || {
              mode: BroadcastMode$2.BROADCAST_MODE_SYNC,
              timeout: DEFAULT_TX_BLOCK_INCLUSION_TIMEOUT_IN_MS 
            }, mode = _ref.mode, timeout = _ref.timeout;
            broadcastTxRequest = new BroadcastTxRequest();
            broadcastTxRequest.setTxBytes(txRaw.serializeBinary());
            broadcastTxRequest.setMode(mode);
            _context5.prev = 5;
            _context5.next = 8;
            return new Promise(function (resolve, reject) {
              return txService.broadcastTx(broadcastTxRequest, /*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(error, response) {
                  var txResponse, result;
                  return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                    while (1) switch (_context4.prev = _context4.next) {
                      case 0:
                        if (!(error || !response)) {
                          _context4.next = 2;
                          break;
                        }
                        return _context4.abrupt("return", reject(error));
                      case 2:
                        txResponse = response.getTxResponse();
                        if (!(txResponse.getCode() === 0)) {
                          _context4.next = 5;
                          break;
                        }
                        return _context4.abrupt("return", resolve(_extends({}, txResponse.toObject(), {
                          txHash: txResponse.getTxhash()
                        })));
                      case 5:
                        _context4.next = 7;
                        return _this.fetchTxPoll(txResponse.getTxhash(), timeout);
                      case 7:
                        result = _context4.sent;
                        return _context4.abrupt("return", resolve(result));
                      case 9:
                      case "end":
                        return _context4.stop();
                    }
                  }, _callee4);
                }));
                return function (_x7, _x8) {
                  return _ref2.apply(this, arguments);
                };
              }());
            });
          case 8:
            return _context5.abrupt("return", _context5.sent);
          case 11:
            _context5.prev = 11;
            _context5.t0 = _context5["catch"](5);
            throw new TransactionException(new Error(_context5.t0.message));
          case 14:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this, [[5, 11]]);
    }));
    function broadcast(_x5, _x6) {
      return _broadcast.apply(this, arguments);
    }
    return broadcast;
  }();
  _proto.broadcastBlock = /*#__PURE__*/function () {
    var _broadcastBlock = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(txRaw, broadcastMode) {
      var txService, broadcastTxRequest;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            if (broadcastMode === void 0) {
              broadcastMode = BroadcastMode$2.BROADCAST_MODE_BLOCK;
            }
            txService = this.txService;
            broadcastTxRequest = new BroadcastTxRequest();
            broadcastTxRequest.setTxBytes(txRaw.serializeBinary());
            broadcastTxRequest.setMode(broadcastMode);
            _context6.prev = 5;
            _context6.next = 8;
            return new Promise(function (resolve, reject) {
              return txService.broadcastTx(broadcastTxRequest, function (error, response) {
                if (error || !response) {
                  return reject(error);
                }
                var txResponse = response.getTxResponse();
                if (!txResponse) {
                  return reject(new Error('There was an issue broadcasting the transaction'));
                }
                var result = _extends({}, txResponse.toObject(), {
                  txHash: txResponse.getTxhash()
                });
                if (result.code !== 0) {
                  return reject(new TransactionException(new Error(result.rawLog), {
                    contextCode: result.code,
                    contextModule: result.codespace
                  }));
                }
                return resolve(result);
              });
            });
          case 8:
            return _context6.abrupt("return", _context6.sent);
          case 11:
            _context6.prev = 11;
            _context6.t0 = _context6["catch"](5);
            if (!(_context6.t0 instanceof TransactionException)) {
              _context6.next = 15;
              break;
            }
            throw _context6.t0;
          case 15:
            throw new TransactionException(new Error(_context6.t0.message));
          case 16:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this, [[5, 11]]);
    }));
    function broadcastBlock(_x9, _x10) {
      return _broadcastBlock.apply(this, arguments);
    }
    return broadcastBlock;
  }();
  _proto.request = function request(_request, service) {
    var _this2 = this;
    return new Promise(function (resolve, reject) {
      grpc.unary(service, {
        request: _request,
        host: _this2.endpoint,
        onEnd: function onEnd(res) {
          var statusMessage = res.statusMessage,
            status = res.status,
            message = res.message;
          if (status === grpc.Code.OK && message) {
            resolve(message);
          }
          reject(new Error(statusMessage));
        }
      });
    });
  };
  return TxGrpcClient;
}();

var BroadcastMode$1;
(function (BroadcastMode) {
  BroadcastMode["Sync"] = "BROADCAST_MODE_SYNC";
  BroadcastMode["Async"] = "BROADCAST_MODE_ASYNC";
  BroadcastMode["Block"] = "BROADCAST_MODE_BLOCK";
})(BroadcastMode$1 || (BroadcastMode$1 = {}));

var TxClient = /*#__PURE__*/function () {
  function TxClient() {}
  /**
   * Encode a transaction to base64-encoded protobuf
   * @param tx transaction to encode
   */
  TxClient.encode = function encode(tx) {
    return Buffer.from(tx.serializeBinary()).toString('base64');
  }
  /**
   * Decode a transaction from base64-encoded protobuf
   * @param tx transaction string to decode
   */;
  TxClient.decode = function decode(encodedTx) {
    return TxRaw$1.deserializeBinary(Buffer.from(encodedTx, 'base64'));
  }
  /**
   * Get the transaction's hash
   * @param tx transaction to hash
   */;
  TxClient.hash =
  /*#__PURE__*/
  function () {
    var _hash = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(tx) {
      var txBytes;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return TxClient.encode(tx);
          case 2:
            txBytes = _context.sent;
            return _context.abrupt("return", hashToHex(txBytes));
          case 4:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    function hash(_x) {
      return _hash.apply(this, arguments);
    }
    return hash;
  }();
  return TxClient;
}();

function isTxError(x) {
  return x.code !== undefined && x.code !== 0 && x.code !== '0';
}
var TxRestClient = /*#__PURE__*/function () {
  function TxRestClient(endpoint) {
    this.httpClient = new HttpClient(endpoint);
  }
  var _proto = TxRestClient.prototype;
  _proto.txInfo = /*#__PURE__*/function () {
    var _txInfo = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(txHash, params) {
      var response;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (params === void 0) {
              params = {};
            }
            _context.prev = 1;
            _context.next = 4;
            return this.getRaw("/cosmos/tx/v1beta1/txs/" + txHash, params);
          case 4:
            response = _context.sent;
            return _context.abrupt("return", response);
          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](1);
            throw new Error(_context.t0);
          case 11:
          case "end":
            return _context.stop();
        }
      }, _callee, this, [[1, 8]]);
    }));
    function txInfo(_x, _x2) {
      return _txInfo.apply(this, arguments);
    }
    return txInfo;
  }();
  _proto.txInfosByHeight = /*#__PURE__*/function () {
    var _txInfosByHeight = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(height) {
      var endpoint, blockInfo, txs, txHashes, txInfos, _iterator, _step, txhash, txInfo;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            endpoint = height !== undefined ? "/cosmos/base/tendermint/v1beta1/blocks/" + height : "/cosmos/base/tendermint/v1beta1/blocks/latest";
            _context2.next = 3;
            return this.getRaw(endpoint);
          case 3:
            blockInfo = _context2.sent;
            txs = blockInfo.block.data.txs;
            if (txs) {
              _context2.next = 7;
              break;
            }
            return _context2.abrupt("return", []);
          case 7:
            txHashes = txs.map(function (txData) {
              return hashToHex(txData);
            });
            txInfos = [];
            _iterator = _createForOfIteratorHelperLoose(txHashes);
          case 10:
            if ((_step = _iterator()).done) {
              _context2.next = 18;
              break;
            }
            txhash = _step.value;
            _context2.next = 14;
            return this.txInfo(txhash);
          case 14:
            txInfo = _context2.sent;
            txInfos.push(txInfo.tx_response);
          case 16:
            _context2.next = 10;
            break;
          case 18:
            return _context2.abrupt("return", txInfos);
          case 19:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function txInfosByHeight(_x3) {
      return _txInfosByHeight.apply(this, arguments);
    }
    return txInfosByHeight;
  }();
  _proto.waitTxBroadcast = /*#__PURE__*/function () {
    var _waitTxBroadcast = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(txHash, timeout) {
      var POLL_INTERVAL, i, txInfo, txInfoSearchResponse;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            if (timeout === void 0) {
              timeout = 30000;
            }
            POLL_INTERVAL = 1000;
            i = 0;
          case 3:
            if (!(i <= timeout / POLL_INTERVAL)) {
              _context3.next = 22;
              break;
            }
            _context3.prev = 4;
            _context3.next = 7;
            return this.txInfo(txHash);
          case 7:
            txInfo = _context3.sent;
            txInfoSearchResponse = txInfo.tx_response;
            if (!txInfoSearchResponse) {
              _context3.next = 11;
              break;
            }
            return _context3.abrupt("return", {
              txhash: txInfoSearchResponse.txhash,
              raw_log: txInfoSearchResponse.raw_log,
              gas_wanted: parseInt(txInfoSearchResponse.gas_wanted, 10),
              gas_used: parseInt(txInfoSearchResponse.gas_used, 10),
              height: parseInt(txInfoSearchResponse.height, 10),
              logs: txInfoSearchResponse.logs,
              code: txInfoSearchResponse.code,
              codespace: txInfoSearchResponse.codespace,
              timestamp: txInfoSearchResponse.timestamp
            });
          case 11:
            _context3.next = 17;
            break;
          case 13:
            _context3.prev = 13;
            _context3.t0 = _context3["catch"](4);
            if (_context3.t0.toString().includes('404')) {
              _context3.next = 17;
              break;
            }
            throw _context3.t0;
          case 17:
            _context3.next = 19;
            return new Promise(function (resolve) {
              return setTimeout(resolve, POLL_INTERVAL);
            });
          case 19:
            i += 1;
            _context3.next = 3;
            break;
          case 22:
            throw new Error("Transaction was not included in a block before timeout of " + timeout + "ms");
          case 23:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this, [[4, 13]]);
    }));
    function waitTxBroadcast(_x4, _x5) {
      return _waitTxBroadcast.apply(this, arguments);
    }
    return waitTxBroadcast;
  }();
  _proto.simulateTx = /*#__PURE__*/function () {
    var _simulateTx = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(txRaw) {
      var response;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return this.postRaw('/cosmos/tx/v1beta1/simulate', {
              tx_bytes: TxClient.encode(txRaw)
            });
          case 2:
            response = _context4.sent;
            return _context4.abrupt("return", {
              result: {
                data: response.result.data,
                log: response.result.log,
                eventsList: response.result.events
              },
              gasInfo: {
                gasWanted: parseInt(response.gas_info.gas_wanted, 10),
                gasUsed: parseInt(response.gas_info.gas_used, 10)
              }
            });
          case 4:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this);
    }));
    function simulateTx(_x6) {
      return _simulateTx.apply(this, arguments);
    }
    return simulateTx;
  }();
  _proto.broadcastTx = /*#__PURE__*/function () {
    var _broadcastTx = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(txRaw, mode) {
      var response;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            if (mode === void 0) {
              mode = BroadcastMode$1.Sync;
            }
            _context5.prev = 1;
            _context5.next = 4;
            return this.postRaw('cosmos/tx/v1beta1/txs', {
              tx_bytes: TxClient.encode(txRaw),
              mode: mode
            });
          case 4:
            response = _context5.sent;
            return _context5.abrupt("return", response);
          case 8:
            _context5.prev = 8;
            _context5.t0 = _context5["catch"](1);
            throw new Error(_context5.t0);
          case 11:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this, [[1, 8]]);
    }));
    function broadcastTx(_x7, _x8) {
      return _broadcastTx.apply(this, arguments);
    }
    return broadcastTx;
  }();
  _proto.broadcastTxn = /*#__PURE__*/function () {
    var _broadcastTxn = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(txRaw, mode) {
      var _yield$this$postRaw, txResponse;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            if (mode === void 0) {
              mode = BroadcastMode$1.Sync;
            }
            _context6.prev = 1;
            _context6.next = 4;
            return this.postRaw('cosmos/tx/v1beta1/txs', {
              tx_bytes: TxClient.encode(txRaw),
              mode: mode
            });
          case 4:
            _yield$this$postRaw = _context6.sent;
            txResponse = _yield$this$postRaw.tx_response;
            return _context6.abrupt("return", txResponse);
          case 9:
            _context6.prev = 9;
            _context6.t0 = _context6["catch"](1);
            throw new Error(_context6.t0);
          case 12:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this, [[1, 9]]);
    }));
    function broadcastTxn(_x9, _x10) {
      return _broadcastTxn.apply(this, arguments);
    }
    return broadcastTxn;
  }();
  _proto.broadcast = /*#__PURE__*/function () {
    var _broadcast = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(tx, timeout) {
      var _yield$this$broadcast, txResponse, result;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            if (timeout === void 0) {
              timeout = 30000;
            }
            _context7.next = 3;
            return this.broadcastTx(tx, BroadcastMode$1.Sync);
          case 3:
            _yield$this$broadcast = _context7.sent;
            txResponse = _yield$this$broadcast.tx_response;
            if (!(txResponse.code !== 0)) {
              _context7.next = 8;
              break;
            }
            result = {
              height: txResponse.height,
              txhash: txResponse.txhash,
              raw_log: txResponse.raw_log,
              code: txResponse.code,
              codespace: txResponse.codespace,
              gas_used: 0,
              gas_wanted: 0,
              timestamp: '',
              logs: []
            };
            return _context7.abrupt("return", result);
          case 8:
            return _context7.abrupt("return", this.waitTxBroadcast(txResponse.txhash, timeout));
          case 9:
          case "end":
            return _context7.stop();
        }
      }, _callee7, this);
    }));
    function broadcast(_x11, _x12) {
      return _broadcast.apply(this, arguments);
    }
    return broadcast;
  }()
  /**
   * Broadcast the transaction using the "block" mode, waiting for its inclusion in the blockchain.
   * @param tx transaction to broadcast
   */
  ;
  _proto.broadcastBlock =
  /*#__PURE__*/
  function () {
    var _broadcastBlock = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(tx) {
      var response, txResponse;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            _context8.next = 2;
            return this.broadcastTx(tx, BroadcastMode$1.Block);
          case 2:
            response = _context8.sent;
            txResponse = response.tx_response;
            return _context8.abrupt("return", {
              txhash: txResponse.txhash,
              raw_log: txResponse.raw_log,
              gas_wanted: txResponse.gas_wanted,
              gas_used: txResponse.gas_used,
              height: txResponse.height,
              logs: txResponse.logs,
              code: txResponse.code,
              codespace: txResponse.codespace,
              data: txResponse.data,
              info: txResponse.info,
              timestamp: txResponse.timestamp
            });
          case 5:
          case "end":
            return _context8.stop();
        }
      }, _callee8, this);
    }));
    function broadcastBlock(_x13) {
      return _broadcastBlock.apply(this, arguments);
    }
    return broadcastBlock;
  }()
  /**
   * NOTE: This is not a synchronous function and is unconventionally named. This function
   * can be await as it returns a `Promise`.
   *
   * Broadcast the transaction using the "sync" mode, returning after CheckTx() is performed.
   * @param tx transaction to broadcast
   */
  ;
  _proto.broadcastSync =
  /*#__PURE__*/
  function () {
    var _broadcastSync = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(tx) {
      var response, txResponse, blockResult;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            _context9.next = 2;
            return this.broadcastTx(tx, BroadcastMode$1.Sync);
          case 2:
            response = _context9.sent;
            txResponse = response.tx_response;
            blockResult = {
              height: txResponse.height,
              txhash: txResponse.txhash,
              raw_log: txResponse.raw_log
            };
            if (txResponse.code) {
              blockResult.code = txResponse.code;
            }
            if (txResponse.codespace) {
              blockResult.codespace = txResponse.codespace;
            }
            return _context9.abrupt("return", blockResult);
          case 8:
          case "end":
            return _context9.stop();
        }
      }, _callee9, this);
    }));
    function broadcastSync(_x14) {
      return _broadcastSync.apply(this, arguments);
    }
    return broadcastSync;
  }()
  /**
   * Search for transactions based on event attributes.
   * @param options
   */
  ;
  _proto.search =
  /*#__PURE__*/
  function () {
    var _search = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(options) {
      var _options$events;
      var params, response;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            params = new URLSearchParams(); // build search params
            (_options$events = options.events) == null ? void 0 : _options$events.forEach(function (v) {
              return params.append('events', v.key === 'tx.height' ? v.key + "=" + v.value : v.key + "='" + v.value + "'");
            });
            delete options.events;
            Object.entries(options).forEach(function (v) {
              params.append(v[0], v[1]);
            });
            _context10.next = 6;
            return this.getRaw("cosmos/tx/v1beta1/txs", params);
          case 6:
            response = _context10.sent;
            return _context10.abrupt("return", response);
          case 8:
          case "end":
            return _context10.stop();
        }
      }, _callee10, this);
    }));
    function search(_x15) {
      return _search.apply(this, arguments);
    }
    return search;
  }();
  _proto.postRaw = /*#__PURE__*/function () {
    var _postRaw = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(endpoint, params) {
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            if (params === void 0) {
              params = {};
            }
            return _context11.abrupt("return", this.httpClient.post(endpoint, params).then(function (d) {
              return d.data;
            }));
          case 2:
          case "end":
            return _context11.stop();
        }
      }, _callee11, this);
    }));
    function postRaw(_x16, _x17) {
      return _postRaw.apply(this, arguments);
    }
    return postRaw;
  }();
  _proto.getRaw = /*#__PURE__*/function () {
    var _getRaw = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(endpoint, params) {
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            if (params === void 0) {
              params = {};
            }
            return _context12.abrupt("return", this.httpClient.get(endpoint, params).then(function (d) {
              return d.data;
            }));
          case 2:
          case "end":
            return _context12.stop();
        }
      }, _callee12, this);
    }));
    function getRaw(_x18, _x19) {
      return _getRaw.apply(this, arguments);
    }
    return getRaw;
  }();
  return TxRestClient;
}();

var TxClientMode;
(function (TxClientMode) {
  TxClientMode["gRpc"] = "grpc";
  TxClientMode["rest"] = "rest";
})(TxClientMode || (TxClientMode = {}));

var StreamOperation;
(function (StreamOperation) {
  StreamOperation["Insert"] = "insert";
  StreamOperation["Delete"] = "delete";
  StreamOperation["Replace"] = "replace";
  StreamOperation["Update"] = "update";
  StreamOperation["Invalidate"] = "invalidate";
})(StreamOperation || (StreamOperation = {}));

var latestBlockQuery = "query getLatestBlocks($limit: Int!, $timeRange:[Int],$offset: Int!){\n  paginatedBlock(sortBy:{_id:desc},filter:{timestamp:{range:$timeRange}},limit:$limit,offset:$offset){\n    totalRecords\n    blocks{\n      _id\n      hash\n      proposer\n      txn_count\n      timestamp\n    }\n  }\n}\n";
var latestBlockQueryWithSignatures = "query getLatestBlocks($limit: Int!, $timeRange:[Int],$offset: Int!){\n  paginatedBlock(sortBy:{_id:desc},filter:{timestamp:{range:$timeRange}},limit:$limit,offset:$offset){\n    totalRecords\n    blocks{\n      _id\n      hash\n      proposer\n      txn_count\n      timestamp\n      signatures{\n      validatorAddress\n      timestamp\n    }\n    }\n  }\n}\n";
var specificBlockQuery = "\n  query getBlockByHeight($height: Int!){\n  block(_id:$height){\n    _id\n    hash\n    proposer\n    txn_count\n    timestamp\n    signatures{\n      validatorAddress\n      timestamp\n    }\n    transactions{\n         _id\n        height\n        sender\n        status\n        receiver\n        timestamp\n        gasWanted\n        gasUsed\n        fee\n        event_logs\n        success\n        rawLog\n        routePrice\n    }\n  }\n}\n";
var latestTransactionsQuery = "\n  query getLatestTransactions($timeRange:[Int], $limit: Int!, $offset: Int!){\n    paginatedTransaction(filter:{timestamp:{range:$timeRange}},sortBy:{height:desc},limit:$limit,offset:$offset){\n    totalRecords\n  transactions{\n     _id\n    height\n    sender\n    status\n    receiver\n    timestamp\n    gasWanted\n    gasUsed\n    fee\n    event_logs\n    success\n    rawLog\n    routePrice\n  }\n  }\n}\n";
var latestTransactionsOfAddressQuery = "\n  query getLatestTransactions($timeRange:[Int], $address: String!,$limit: Int!, $offset: Int!){\n   paginatedTransaction(filter:{timestamp:{range:$timeRange}}, where_or:{sender:$address, receiver:$address}, limit:$limit, offset:$offset){\n    totalRecords\n    transactions{\n      _id\n      height\n      sender\n      status\n      receiver\n      timestamp\n      gasWanted\n      gasUsed\n      fee\n      event_logs\n      success\n      rawLog\n      routePrice\n    }\n  }\n}\n";
var specificTransactionQuery = "\n  query getTransactionByHash($hash: String!){\n  transaction(_id:$hash){\n    _id\n    height\n    sender\n    status\n    receiver\n    timestamp\n    gasWanted\n    gasUsed\n    fee\n    event_logs\n    success\n    rawLog\n    routePrice\n  }\n}\n";
var latestCrosschainsQuery = "\n  query getLatestCrosschains($timeRange:[Int], $limit: Int!, $offset: Int!){\n    paginatedCrosschain(filter:{createdAt:{range:$timeRange}}, sortBy:{createdAt:desc}, limit:$limit, offset:$offset){\n    totalRecords\n    crosschains{\n      id\n      attestationId\n      srcChainId\n      requestIdentifier\n      blockHeight\n      sourceTxHash\n      srcTimestamp\n      srcTxOrigin\n      routeAmount\n      routeRecipient\n      destChainId\n      requestSender\n      requestMetadata{\n        destGasLimit\n        destGasPrice\n        ackGasLimit\n        ackGasPrice\n        ackType\n        isReadCall\n        asmAddress\n      }\n      requestPacket{\n        handler\n        payload\n      }\n      srcChainType\n      destChainType\n      status\n      eventHistory{\n        name\n        height\n        timestamp\n        txnHash\n        height\n      }\n      historyStatus{\n        status\n        txnHash\n        timestamp\n      }\n      eventConfirmSignatures{\n        validator\n        txnHash\n        timestamp\n        blockHeight\n        signature\n        ethSigner\n      }\n      ackRequest{\n        eventAckRequestCreated{\n          attestationId\n          ackSrcChainId\n          ackRequestIdentifier\n          blockHeight\n          destTxHash\n          relayerRouterAddress\n          ackDestChainId\n          requestSender\n          requestIdentifier\n          ackSrcChainType\n          ackDestChainType\n          execData\n          execStatus\n          status\n        }\n        eventAckRequestConfirm{\n          ackSrcChainId\n          ackRequestIdentifier\n          claimHash\n          ethSigner\n          signature\n          orchestrator\n        }\n        status\n        eventHistory{\n          name\n          height\n          timestamp\n          txnHash\n          height\n        }\n        historyStatus{\n          status\n          txnHash\n          timestamp\n        }\n        claimHash\n        txFeeInRoute\n        chainType\n        chainId\n        requestIdentifier\n        customFormAttestationId\n        ackReceiptRequest{\n          ackReceipt{\n            attestationId\n            ackReceiptSrcChainId\n            ackReceiptIdentifier\n            ackReceiptBlockHeight\n            ackReceiptTxHash\n            relayerRouterAddress\n            requestIdentifier\n            status\n          }\n          historyStatus{\n            status\n            txnHash\n            timestamp\n          }\n          relayerFeeInRoute\n          refundFeeInRoute\n          ackReceiptKey\n          status\n          claimHash\n        }\n        ackGasLimit\n        ackGasPrice\n        feePayer\n        relayerFeeInRoute\n        relayerIncentiveInRoute\n        refundFeeInRoute\n        errorResponse\n        eventSignatures{\n          chainType\n          chainId\n          eventNonce\n          voter\n          blockHeight\n          timestamp\n        }\n      }\n      customFormAttestationId\n      destinationTxHash\n      eventAckConfirmSignatures{\n        validator\n        txnHash\n        timestamp\n        blockHeight\n        signature\n        ethSigner\n      }\n      createdAt\n      updatedAt\n      destTxFeeInRoute\n      relayerFee\n\t\t\trelayerFeeInRoute\n      relayerIncentiveInRoute\n      refundFeeInRoute\n      feePayer\n      errorResponse\n      relayerAddress\n      execStatus\n      execData\n      eventSignatures{\n        chainType\n        chainId\n        eventNonce\n        voter\n        blockHeight\n        timestamp\n      }\n    }\n    }\n}\n";
var specificCrosschainQuery = "\n  query getCrosschainByFormAttestationId($formAttestationId: String!){\n  crosschain(id:$formAttestationId){\n    id\n      attestationId\n      srcChainId\n      requestIdentifier\n      blockHeight\n      sourceTxHash\n      srcTimestamp\n      srcTxOrigin\n      routeAmount\n      routeRecipient\n      destChainId\n      requestSender\n      requestMetadata{\n        destGasLimit\n        destGasPrice\n        ackGasLimit\n        ackGasPrice\n        ackType\n        isReadCall\n        asmAddress\n      }\n      requestPacket{\n        handler\n        payload\n      }\n      srcChainType\n      destChainType\n      status\n      eventHistory{\n        name\n        height\n        timestamp\n        txnHash\n        height\n      }\n      historyStatus{\n        status\n        txnHash\n        timestamp\n      }\n      eventConfirmSignatures{\n        validator\n        txnHash\n        timestamp\n        blockHeight\n        signature\n        ethSigner\n      }\n      ackRequest{\n        eventAckRequestCreated{\n          attestationId\n          ackSrcChainId\n          ackRequestIdentifier\n          blockHeight\n          destTxHash\n          relayerRouterAddress\n          ackDestChainId\n          requestSender\n          requestIdentifier\n          ackSrcChainType\n          ackDestChainType\n          execData\n          execStatus\n          status\n        }\n        eventAckRequestConfirm{\n          ackSrcChainId\n          ackRequestIdentifier\n          claimHash\n          ethSigner\n          signature\n          orchestrator\n        }\n        status\n        eventHistory{\n          name\n          height\n          timestamp\n          txnHash\n          height\n        }\n        historyStatus{\n          status\n          txnHash\n          timestamp\n        }\n        claimHash\n        txFeeInRoute\n        chainType\n        chainId\n        requestIdentifier\n        customFormAttestationId\n        ackReceiptRequest{\n          ackReceipt{\n            attestationId\n            ackReceiptSrcChainId\n            ackReceiptIdentifier\n            ackReceiptBlockHeight\n            ackReceiptTxHash\n            relayerRouterAddress\n            requestIdentifier\n            status\n          }\n          historyStatus{\n            status\n            txnHash\n            timestamp\n          }\n          relayerFeeInRoute\n          refundFeeInRoute\n          ackReceiptKey\n          status\n          claimHash\n        }\n        ackGasLimit\n        ackGasPrice\n        feePayer\n        relayerFeeInRoute\n        relayerIncentiveInRoute\n        refundFeeInRoute\n        errorResponse\n        eventSignatures{\n          chainType\n          chainId\n          eventNonce\n          voter\n          blockHeight\n          timestamp\n        }\n      }\n      customFormAttestationId\n      destinationTxHash\n      eventAckConfirmSignatures{\n        validator\n        txnHash\n        timestamp\n        blockHeight\n        signature\n        ethSigner\n      }\n      createdAt\n      updatedAt\n      destTxFeeInRoute\n      relayerFee\n\t\t\trelayerFeeInRoute\n      relayerIncentiveInRoute\n      refundFeeInRoute\n      feePayer\n      errorResponse\n      relayerAddress\n      execStatus\n      execData\n      eventSignatures{\n        chainType\n        chainId\n        eventNonce\n        voter\n        blockHeight\n        timestamp\n      }\n  }\n}\n";
var searchSpecificCrosschainQuery = "\n  query getCrosschainByFormAttestationId($timeRange:[Int], $searchTerm: String! , $handlerAddress: String!, $limit: Int!, $offset: Int!){\n  paginatedCrosschain(filter:{createdAt:{range:$timeRange}},where_or:{sourceTxHash:$searchTerm, srcTxOrigin:$searchTerm, requestSender:$searchTerm},handlerAddress:$handlerAddress,sortBy:{createdAt:desc},limit:$limit,offset:$offset){\n    totalRecords\n    crosschains{\n      id\n      attestationId\n      srcChainId\n      requestIdentifier\n      blockHeight\n      sourceTxHash\n      srcTimestamp\n      srcTxOrigin\n      routeAmount\n      routeRecipient\n      destChainId\n      requestSender\n      requestMetadata{\n        destGasLimit\n        destGasPrice\n        ackGasLimit\n        ackGasPrice\n        ackType\n        isReadCall\n        asmAddress\n      }\n      requestPacket{\n        handler\n        payload\n      }\n      srcChainType\n      destChainType\n      status\n      eventHistory{\n        name\n        height\n        timestamp\n        txnHash\n        height\n      }\n      historyStatus{\n        status\n        txnHash\n        timestamp\n      }\n      eventConfirmSignatures{\n        validator\n        txnHash\n        timestamp\n        blockHeight\n        signature\n        ethSigner\n      }\n      ackRequest{\n        eventAckRequestCreated{\n          attestationId\n          ackSrcChainId\n          ackRequestIdentifier\n          blockHeight\n          destTxHash\n          relayerRouterAddress\n          ackDestChainId\n          requestSender\n          requestIdentifier\n          ackSrcChainType\n          ackDestChainType\n          execData\n          execStatus\n          status\n        }\n        eventAckRequestConfirm{\n          ackSrcChainId\n          ackRequestIdentifier\n          claimHash\n          ethSigner\n          signature\n          orchestrator\n        }\n        status\n        eventHistory{\n          name\n          height\n          timestamp\n          txnHash\n          height\n        }\n        historyStatus{\n          status\n          txnHash\n          timestamp\n        }\n        claimHash\n        txFeeInRoute\n        chainType\n        chainId\n        requestIdentifier\n        customFormAttestationId\n        ackReceiptRequest{\n          ackReceipt{\n            attestationId\n            ackReceiptSrcChainId\n            ackReceiptIdentifier\n            ackReceiptBlockHeight\n            ackReceiptTxHash\n            relayerRouterAddress\n            requestIdentifier\n            status\n          }\n          historyStatus{\n            status\n            txnHash\n            timestamp\n          }\n          relayerFeeInRoute\n          refundFeeInRoute\n          ackReceiptKey\n          status\n          claimHash\n        }\n        ackGasLimit\n        ackGasPrice\n        feePayer\n        relayerFeeInRoute\n        relayerIncentiveInRoute\n        refundFeeInRoute\n        errorResponse\n        eventSignatures{\n          chainType\n          chainId\n          eventNonce\n          voter\n          blockHeight\n          timestamp\n        }\n      }\n      customFormAttestationId\n      destinationTxHash\n      eventAckConfirmSignatures{\n        validator\n        txnHash\n        timestamp\n        blockHeight\n        signature\n        ethSigner\n      }\n      createdAt\n      updatedAt\n      destTxFeeInRoute\n      relayerFee\n\t\t\trelayerFeeInRoute\n      relayerIncentiveInRoute\n      refundFeeInRoute\n      feePayer\n      errorResponse\n      relayerAddress\n      execStatus\n      execData\n      eventSignatures{\n        chainType\n        chainId\n        eventNonce\n        voter\n        blockHeight\n        timestamp\n      }\n    }\n    }\n}\n";
var searchSpecificCrosschainSrcChainIdQuery = "\n  query getCrosschainByFormAttestationId($timeRange:[Int],$sourceChainIds: [String],$handlerAddress: String!,$searchTerm: String! ,$limit: Int!, $offset: Int!){\n  paginatedCrosschain(filter:{srcChainId:{in:$sourceChainIds}, createdAt:{range:$timeRange}},where_or:{sourceTxHash:$searchTerm, srcTxOrigin:$searchTerm, requestSender:$searchTerm},handlerAddress:$handlerAddress,sortBy:{createdAt:desc},limit:$limit,offset:$offset){\n    totalRecords\n    crosschains{\n      id\n      attestationId\n      srcChainId\n      requestIdentifier\n      blockHeight\n      sourceTxHash\n      srcTimestamp\n      srcTxOrigin\n      routeAmount\n      routeRecipient\n      destChainId\n      requestSender\n      requestMetadata{\n        destGasLimit\n        destGasPrice\n        ackGasLimit\n        ackGasPrice\n        ackType\n        isReadCall\n        asmAddress\n      }\n      requestPacket{\n        handler\n        payload\n      }\n      srcChainType\n      destChainType\n      status\n      eventHistory{\n        name\n        height\n        timestamp\n        txnHash\n        height\n      }\n      historyStatus{\n        status\n        txnHash\n        timestamp\n      }\n      eventConfirmSignatures{\n        validator\n        txnHash\n        timestamp\n        blockHeight\n        signature\n        ethSigner\n      }\n      ackRequest{\n        eventAckRequestCreated{\n          attestationId\n          ackSrcChainId\n          ackRequestIdentifier\n          blockHeight\n          destTxHash\n          relayerRouterAddress\n          ackDestChainId\n          requestSender\n          requestIdentifier\n          ackSrcChainType\n          ackDestChainType\n          execData\n          execStatus\n          status\n        }\n        eventAckRequestConfirm{\n          ackSrcChainId\n          ackRequestIdentifier\n          claimHash\n          ethSigner\n          signature\n          orchestrator\n        }\n        status\n        eventHistory{\n          name\n          height\n          timestamp\n          txnHash\n          height\n        }\n        historyStatus{\n          status\n          txnHash\n          timestamp\n        }\n        claimHash\n        txFeeInRoute\n        chainType\n        chainId\n        requestIdentifier\n        customFormAttestationId\n        ackReceiptRequest{\n          ackReceipt{\n            attestationId\n            ackReceiptSrcChainId\n            ackReceiptIdentifier\n            ackReceiptBlockHeight\n            ackReceiptTxHash\n            relayerRouterAddress\n            requestIdentifier\n            status\n          }\n          historyStatus{\n            status\n            txnHash\n            timestamp\n          }\n          relayerFeeInRoute\n          refundFeeInRoute\n          ackReceiptKey\n          status\n          claimHash\n        }\n        ackGasLimit\n        ackGasPrice\n        feePayer\n        relayerFeeInRoute\n        relayerIncentiveInRoute\n        refundFeeInRoute\n        errorResponse\n        eventSignatures{\n          chainType\n          chainId\n          eventNonce\n          voter\n          blockHeight\n          timestamp\n        }\n      }\n      customFormAttestationId\n      destinationTxHash\n      eventAckConfirmSignatures{\n        validator\n        txnHash\n        timestamp\n        blockHeight\n        signature\n        ethSigner\n      }\n      createdAt\n      updatedAt\n      destTxFeeInRoute\n      relayerFee\n\t\t\trelayerFeeInRoute\n      relayerIncentiveInRoute\n      refundFeeInRoute\n      feePayer\n      errorResponse\n      relayerAddress\n      execStatus\n      execData\n      eventSignatures{\n        chainType\n        chainId\n        eventNonce\n        voter\n        blockHeight\n        timestamp\n      }\n    }\n    }\n}\n";
var searchSpecificCrosschainDestChainIdQuery = "\n  query getCrosschainByFormAttestationId($timeRange:[Int],$destinationChainIds: [String],$searchTerm: String! , $handlerAddress: String!,$limit: Int!, $offset: Int!){\n  paginatedCrosschain(filter:{destChainId:{in:$destinationChainIds},createdAt:{range:$timeRange}},where_or:{sourceTxHash:$searchTerm, srcTxOrigin:$searchTerm, requestSender:$searchTerm},handlerAddress:$handlerAddress,sortBy:{createdAt:desc},limit:$limit,offset:$offset){\n    totalRecords\n    crosschains{\n     id\n      attestationId\n      srcChainId\n      requestIdentifier\n      blockHeight\n      sourceTxHash\n      srcTimestamp\n      srcTxOrigin\n      routeAmount\n      routeRecipient\n      destChainId\n      requestSender\n      requestMetadata{\n        destGasLimit\n        destGasPrice\n        ackGasLimit\n        ackGasPrice\n        ackType\n        isReadCall\n        asmAddress\n      }\n      requestPacket{\n        handler\n        payload\n      }\n      srcChainType\n      destChainType\n      status\n      eventHistory{\n        name\n        height\n        timestamp\n        txnHash\n        height\n      }\n      historyStatus{\n        status\n        txnHash\n        timestamp\n      }\n      eventConfirmSignatures{\n        validator\n        txnHash\n        timestamp\n        blockHeight\n        signature\n        ethSigner\n      }\n      ackRequest{\n        eventAckRequestCreated{\n          attestationId\n          ackSrcChainId\n          ackRequestIdentifier\n          blockHeight\n          destTxHash\n          relayerRouterAddress\n          ackDestChainId\n          requestSender\n          requestIdentifier\n          ackSrcChainType\n          ackDestChainType\n          execData\n          execStatus\n          status\n        }\n        eventAckRequestConfirm{\n          ackSrcChainId\n          ackRequestIdentifier\n          claimHash\n          ethSigner\n          signature\n          orchestrator\n        }\n        status\n        eventHistory{\n          name\n          height\n          timestamp\n          txnHash\n          height\n        }\n        historyStatus{\n          status\n          txnHash\n          timestamp\n        }\n        claimHash\n        txFeeInRoute\n        chainType\n        chainId\n        requestIdentifier\n        customFormAttestationId\n        ackReceiptRequest{\n          ackReceipt{\n            attestationId\n            ackReceiptSrcChainId\n            ackReceiptIdentifier\n            ackReceiptBlockHeight\n            ackReceiptTxHash\n            relayerRouterAddress\n            requestIdentifier\n            status\n          }\n          historyStatus{\n            status\n            txnHash\n            timestamp\n          }\n          relayerFeeInRoute\n          refundFeeInRoute\n          ackReceiptKey\n          status\n          claimHash\n        }\n        ackGasLimit\n        ackGasPrice\n        feePayer\n        relayerFeeInRoute\n        relayerIncentiveInRoute\n        refundFeeInRoute\n        errorResponse\n        eventSignatures{\n          chainType\n          chainId\n          eventNonce\n          voter\n          blockHeight\n          timestamp\n        }\n      }\n      customFormAttestationId\n      destinationTxHash\n      eventAckConfirmSignatures{\n        validator\n        txnHash\n        timestamp\n        blockHeight\n        signature\n        ethSigner\n      }\n      createdAt\n      updatedAt\n      destTxFeeInRoute\n      relayerFee\n\t\t\trelayerFeeInRoute\n      relayerIncentiveInRoute\n      refundFeeInRoute\n      feePayer\n      errorResponse\n      relayerAddress\n      execStatus\n      execData\n      eventSignatures{\n        chainType\n        chainId\n        eventNonce\n        voter\n        blockHeight\n        timestamp\n      }\n    }\n    }\n}\n";
var searchSpecificCrosschainChainIdQuery = "\n  query getCrosschainByFormAttestationId($timeRange:[Int], $sourceChainIds: [String],$destinationChainIds: [String],$searchTerm: String! , $handlerAddress: String!,$limit: Int!, $offset: Int!){\n  paginatedCrosschain(filter:{srcChainId:{in:$sourceChainIds},destChainId:{in:$destinationChainIds}, createdAt:{range:$timeRange}},where_or:{sourceTxHash:$searchTerm, srcTxOrigin:$searchTerm, requestSender:$searchTerm},handlerAddress:$handlerAddress,sortBy:{createdAt:desc},limit:$limit,offset:$offset){\n    totalRecords\n    crosschains{\n      id\n      attestationId\n      srcChainId\n      requestIdentifier\n      blockHeight\n      sourceTxHash\n      srcTimestamp\n      srcTxOrigin\n      routeAmount\n      routeRecipient\n      destChainId\n      requestSender\n      requestMetadata{\n        destGasLimit\n        destGasPrice\n        ackGasLimit\n        ackGasPrice\n        ackType\n        isReadCall\n        asmAddress\n      }\n      requestPacket{\n        handler\n        payload\n      }\n      srcChainType\n      destChainType\n      status\n      eventHistory{\n        name\n        height\n        timestamp\n        txnHash\n        height\n      }\n      historyStatus{\n        status\n        txnHash\n        timestamp\n      }\n      eventConfirmSignatures{\n        validator\n        txnHash\n        timestamp\n        blockHeight\n        signature\n        ethSigner\n      }\n      ackRequest{\n        eventAckRequestCreated{\n          attestationId\n          ackSrcChainId\n          ackRequestIdentifier\n          blockHeight\n          destTxHash\n          relayerRouterAddress\n          ackDestChainId\n          requestSender\n          requestIdentifier\n          ackSrcChainType\n          ackDestChainType\n          execData\n          execStatus\n          status\n        }\n        eventAckRequestConfirm{\n          ackSrcChainId\n          ackRequestIdentifier\n          claimHash\n          ethSigner\n          signature\n          orchestrator\n        }\n        status\n        eventHistory{\n          name\n          height\n          timestamp\n          txnHash\n          height\n        }\n        historyStatus{\n          status\n          txnHash\n          timestamp\n        }\n        claimHash\n        txFeeInRoute\n        chainType\n        chainId\n        requestIdentifier\n        customFormAttestationId\n        ackReceiptRequest{\n          ackReceipt{\n            attestationId\n            ackReceiptSrcChainId\n            ackReceiptIdentifier\n            ackReceiptBlockHeight\n            ackReceiptTxHash\n            relayerRouterAddress\n            requestIdentifier\n            status\n          }\n          historyStatus{\n            status\n            txnHash\n            timestamp\n          }\n          relayerFeeInRoute\n          refundFeeInRoute\n          ackReceiptKey\n          status\n          claimHash\n        }\n        ackGasLimit\n        ackGasPrice\n        feePayer\n        relayerFeeInRoute\n        relayerIncentiveInRoute\n        refundFeeInRoute\n        errorResponse\n        eventSignatures{\n          chainType\n          chainId\n          eventNonce\n          voter\n          blockHeight\n          timestamp\n        }\n      }\n      customFormAttestationId\n      destinationTxHash\n      eventAckConfirmSignatures{\n        validator\n        txnHash\n        timestamp\n        blockHeight\n        signature\n        ethSigner\n      }\n      createdAt\n      updatedAt\n      destTxFeeInRoute\n      relayerFee\n\t\t\trelayerFeeInRoute\n      relayerIncentiveInRoute\n      refundFeeInRoute\n      feePayer\n      errorResponse\n      relayerAddress\n      execStatus\n      execData\n      eventSignatures{\n        chainType\n        chainId\n        eventNonce\n        voter\n        blockHeight\n        timestamp\n      }\n    }\n    }\n}\n";
var inboundOutboundQuery = "\nquery findOutboundsToInbound($middlewareContract:String!,$inboundId:String!){\n  outboundToInboundMap(where:{middlewareContract:$middlewareContract, inboundId:$inboundId}){\n    inboundId\n    outboundId\n    inboundNonce\n    outboundChainId\n    outboundNonce\n    middlewareContract\n    blockHeight\n    timestamp\n  }\n}\n";
var latestFundPaidQuery = "\n  query getLatestFundPaid($timeRange:[Int], $limit: Int!, $offset: Int!){\n    paginatedFundPaid(filter:{createdAt:{range:$timeRange}}, sortBy:{createdAt:desc}, limit:$limit, offset:$offset){\n    totalRecords\n    fundPaid{\n      id\n\t\t\tsrcChainId\n      srcChainType\n      srcTxHash\n      srcTimestamp\n      contract\n      eventNonce\n      blockHeight\n      messageHash\n      forwarder\n      forwarderRouterAddr\n      execResponse\n      errorResponse\n       eventHistory{\n        name\n        height\n        timestamp\n        txnHash\n        height\n      }\n      historyStatus{\n        status\n        txnHash\n        timestamp\n      }\n      eventSignatures{\n        validator\n        txnHash\n        timestamp\n        blockHeight\n        signature\n        ethSigner\n      }\n      status\n      createdAt\n      updatedAt\n    }\n  }\n}\n";
var specificFundPaidQuery = "\n  query getFundPaidById($id:String!){\n  fundPaid(id:$id){\n      id\n\t\t\tsrcChainId\n      srcChainType\n      srcTxHash\n      srcTimestamp\n      contract\n      eventNonce\n      blockHeight\n      messageHash\n      forwarder\n      forwarderRouterAddr\n      execResponse\n      errorResponse\n       eventHistory{\n        name\n        height\n        timestamp\n        txnHash\n        height\n      }\n      historyStatus{\n        status\n        txnHash\n        timestamp\n      }\n      eventSignatures{\n        validator\n        txnHash\n        timestamp\n        blockHeight\n        signature\n        ethSigner\n      }\n      status\n      createdAt\n      updatedAt\n    }\n}\n";
var searchSpecificFundPaidQuery = "\n  query getFundPaidBySearch($timeRange:[Int], $searchTerm: String! ,$limit: Int!, $offset: Int!){\n  paginatedFundPaid(filter:{createdAt:{range:$timeRange}},where_or:{srcTxHash:$searchTerm, contract:$searchTerm, messageHash:$searchTerm, forwarder:$searchTerm, forwarderRouterAddr:$searchTerm},sortBy:{createdAt:desc},limit:$limit,offset:$offset){\n    totalRecords\n    fundPaid{\n      id\n\t\t\tsrcChainId\n      srcChainType\n      srcTxHash\n      srcTimestamp\n      contract\n      eventNonce\n      blockHeight\n      messageHash\n      forwarder\n      forwarderRouterAddr\n      execResponse\n      errorResponse\n       eventHistory{\n        name\n        height\n        timestamp\n        txnHash\n        height\n      }\n      historyStatus{\n        status\n        txnHash\n        timestamp\n      }\n      eventSignatures{\n        validator\n        txnHash\n        timestamp\n        blockHeight\n        signature\n        ethSigner\n      }\n      status\n      createdAt\n      updatedAt\n    }\n";
var searchSpecificFundPaidSrcChainIdQuery = "\n  query getCrosschainBySearch($timeRange:[Int],$sourceChainIds: [String],$searchTerm: String! ,$limit: Int!, $offset: Int!){\n  paginatedFundPaid(filter:{srcChainId:{in:$sourceChainIds}, createdAt:{range:$timeRange}},where_or:{srcTxHash:$searchTerm, contract:$searchTerm, messageHash:$searchTerm, forwarder:$searchTerm, forwarderRouterAddr:$searchTerm},sortBy:{createdAt:desc},limit:$limit,offset:$offset){\n    totalRecords\n    fundPaid{\n      id\n\t\t\tsrcChainId\n      srcChainType\n      srcTxHash\n      srcTimestamp\n      contract\n      eventNonce\n      blockHeight\n      messageHash\n      forwarder\n      forwarderRouterAddr\n      execResponse\n      errorResponse\n       eventHistory{\n        name\n        height\n        timestamp\n        txnHash\n        height\n      }\n      historyStatus{\n        status\n        txnHash\n        timestamp\n      }\n      eventSignatures{\n        validator\n        txnHash\n        timestamp\n        blockHeight\n        signature\n        ethSigner\n      }\n      status\n      createdAt\n      updatedAt\n    }\n  }\n}\n";
var latestFundDepositQuery = "\n  query getLatestFundDeposit($timeRange:[Int], $limit: Int!, $offset: Int!){\n    paginatedFundDeposit(filter:{createdAt:{range:$timeRange}}, sortBy:{createdAt:desc}, limit:$limit, offset:$offset){\n    totalRecords\n    fundDeposit{\n      id\n\t\t\tsrcChainId\n      srcChainType\n      srcTxHash\n      srcTimestamp\n      contract\n      depositId\n      blockHeight\n      destChainId\n      amount\n      relayerFees\n\t\t\tsrcToken\n\t\t\trecipient\n\t\t\tdepositor\n      execResponse\n      errorResponse\n       eventHistory{\n        name\n        height\n        timestamp\n        txnHash\n        height\n      }\n      historyStatus{\n        status\n        txnHash\n        timestamp\n      }\n      eventSignatures{\n        validator\n        txnHash\n        timestamp\n        blockHeight\n        signature\n        ethSigner\n      }\n      status\n      createdAt\n      updatedAt\n    }\n  }\n}\n";
var specificFundDepositQuery = "\n  query getFundDepositById($id:String!){\n  fundDeposit(id:$id){\n      id\n\t\t\tsrcChainId\n      srcChainType\n      srcTxHash\n      srcTimestamp\n      contract\n      depositId\n      blockHeight\n      destChainId\n      amount\n      relayerFees\n\t\t\tsrcToken\n\t\t\trecipient\n\t\t\tdepositor\n      execResponse\n      errorResponse\n       eventHistory{\n        name\n        height\n        timestamp\n        txnHash\n        height\n      }\n      historyStatus{\n        status\n        txnHash\n        timestamp\n      }\n      eventSignatures{\n        validator\n        txnHash\n        timestamp\n        blockHeight\n        signature\n        ethSigner\n      }\n      status\n      createdAt\n      updatedAt\n    }\n}\n";
var searchSpecificFundDepositQuery = "\n  query getFundPaidBySearch($timeRange:[Int], $searchTerm: String! ,$limit: Int!, $offset: Int!){\n  paginatedFundDeposit(filter:{createdAt:{range:$timeRange}},where_or:{srcTxHash:$searchTerm, contract:$searchTerm, srcToken:$searchTerm, recipient:$searchTerm, depositor:$searchTerm},sortBy:{createdAt:desc},limit:$limit,offset:$offset){\n    totalRecords\n    fundDeposit{\n      id\n\t\t\tsrcChainId\n      srcChainType\n      srcTxHash\n      srcTimestamp\n      contract\n      depositId\n      blockHeight\n      destChainId\n      amount\n      relayerFees\n\t\t\tsrcToken\n\t\t\trecipient\n\t\t\tdepositor\n      execResponse\n      errorResponse\n       eventHistory{\n        name\n        height\n        timestamp\n        txnHash\n        height\n      }\n      historyStatus{\n        status\n        txnHash\n        timestamp\n      }\n      eventSignatures{\n        validator\n        txnHash\n        timestamp\n        blockHeight\n        signature\n        ethSigner\n      }\n      status\n      createdAt\n      updatedAt\n    }\n  }\n}\n";
var searchSpecificFundDepositSrcChainIdQuery = "\n  query getCrosschainBySearch($timeRange:[Int],$sourceChainIds: [String],$searchTerm: String! ,$limit: Int!, $offset: Int!){\n  paginatedFundDeposit(filter:{srcChainId:{in:$sourceChainIds}, createdAt:{range:$timeRange}},where_or:{srcTxHash:$searchTerm, contract:$searchTerm, srcToken:$searchTerm, recipient:$searchTerm, depositor:$searchTerm},sortBy:{createdAt:desc},limit:$limit,offset:$offset){\n    totalRecords\n    fundDeposit{\n      id\n\t\t\tsrcChainId\n      srcChainType\n      srcTxHash\n      srcTimestamp\n      contract\n      depositId\n      blockHeight\n      destChainId\n      amount\n      relayerFees\n\t\t\tsrcToken\n\t\t\trecipient\n\t\t\tdepositor\n      execResponse\n      errorResponse\n       eventHistory{\n        name\n        height\n        timestamp\n        txnHash\n        height\n      }\n      historyStatus{\n        status\n        txnHash\n        timestamp\n      }\n      eventSignatures{\n        validator\n        txnHash\n        timestamp\n        blockHeight\n        signature\n        ethSigner\n      }\n      status\n      createdAt\n      updatedAt\n    }\n  }\n}\n";
var searchSpecificFundDepositDestChainIdQuery = "\n query getCrosschainBySearch($timeRange:[Int],$destinationChainIds: [String],$searchTerm: String! ,$limit: Int!, $offset: Int!){\n  paginatedFundDeposit(filter:{destChainId:{in:$destinationChainIds}, createdAt:{range:$timeRange}},where_or:{srcTxHash:$searchTerm, contract:$searchTerm, srcToken:$searchTerm, recipient:$searchTerm, depositor:$searchTerm},sortBy:{createdAt:desc},limit:$limit,offset:$offset){\n    totalRecords\n    fundDeposit{\n      id\n\t\t\tsrcChainId\n      srcChainType\n      srcTxHash\n      srcTimestamp\n      contract\n      depositId\n      blockHeight\n      destChainId\n      amount\n      relayerFees\n\t\t\tsrcToken\n\t\t\trecipient\n\t\t\tdepositor\n      execResponse\n      errorResponse\n       eventHistory{\n        name\n        height\n        timestamp\n        txnHash\n        height\n      }\n      historyStatus{\n        status\n        txnHash\n        timestamp\n      }\n      eventSignatures{\n        validator\n        txnHash\n        timestamp\n        blockHeight\n        signature\n        ethSigner\n      }\n      status\n      createdAt\n      updatedAt\n    }\n  }\n}\n";
var searchSpecificFundDepositChainIdQuery = "\n query getCrosschainBySearch($timeRange:[Int],$sourceChainIds:[String],$destinationChainIds: [String],$searchTerm: String! ,$limit: Int!, $offset: Int!){\n  paginatedFundDeposit(filter:{srcChainId:{in:$sourceChainIds}, destChainId:{in:$destinationChainIds}, createdAt:{range:$timeRange}},where_or:{srcTxHash:$searchTerm, contract:$searchTerm, srcToken:$searchTerm, recipient:$searchTerm, depositor:$searchTerm},sortBy:{createdAt:desc},limit:$limit,offset:$offset){\n    totalRecords\n    fundDeposit{\n      id\n\t\t\tsrcChainId\n      srcChainType\n      srcTxHash\n      srcTimestamp\n      contract\n      depositId\n      blockHeight\n      destChainId\n      amount\n      relayerFees\n\t\t\tsrcToken\n\t\t\trecipient\n\t\t\tdepositor\n      execResponse\n      errorResponse\n       eventHistory{\n        name\n        height\n        timestamp\n        txnHash\n        height\n      }\n      historyStatus{\n        status\n        txnHash\n        timestamp\n      }\n      eventSignatures{\n        validator\n        txnHash\n        timestamp\n        blockHeight\n        signature\n        ethSigner\n      }\n      status\n      createdAt\n      updatedAt\n    }\n  }\n}\n";
var validatorsUptimeQuery = "\nquery getValidatorsUptime{\n  validators{\n    operatorAddress\n    consensusAddress\n    upTime\n  }\n}\n";
//const x = gql(latestBlockQuery) for apollo client DocumentNode

var CancelToken = axios.CancelToken;
var gqlFetcher = /*#__PURE__*/function () {
  var _ref = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(chainEnvironment, queryTag, options, source) {
    var response;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (source === void 0) {
            source = /*#__PURE__*/CancelToken.source();
          }
          _context.prev = 1;
          _context.next = 4;
          return axios.post(getEndpointsForNetwork(chainEnvironment).explorerGql, {
            query: queryTag,
            variables: options
          }, {
            headers: {
              'Content-Type': 'application/json'
            },
            cancelToken: source.token
          });
        case 4:
          response = _context.sent;
          return _context.abrupt("return", response.data.data);
        case 8:
          _context.prev = 8;
          _context.t0 = _context["catch"](1);
          throw _context.t0;
        case 11:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[1, 8]]);
  }));
  return function gqlFetcher(_x, _x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();
var restFetcher = /*#__PURE__*/function () {
  var _ref2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(url) {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return fetch(url);
        case 2:
          _context2.next = 4;
          return _context2.sent.json();
        case 4:
          return _context2.abrupt("return", _context2.sent);
        case 5:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function restFetcher(_x5) {
    return _ref2.apply(this, arguments);
  };
}();

/**
 * @group Router Scan Utility
 */
var RouterExplorer = /*#__PURE__*/function () {
  function RouterExplorer(chainEnvironment, applicationAddress) {
    if (applicationAddress === void 0) {
      applicationAddress = '';
    }
    this.chainEnvironment = getNetworkType(chainEnvironment);
    this.applicationAddress = applicationAddress;
  }
  //Fetch latest blocks from explorer db
  /**
   * Fetches latest Blocks
   * @param {string} timeRange Time Range
   * @param {string} limit Page Limit
   * @param {string} offset Page Number
   * @return {PaginatedBlock}
   * @throws {Error}
   */
  var _proto = RouterExplorer.prototype;
  _proto.getLatestBlocks =
  /*#__PURE__*/
  function () {
    var _getLatestBlocks = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(timeRange, limit, offset, _temp) {
      var _ref, source, data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (timeRange === void 0) {
              timeRange = [];
            }
            if (limit === void 0) {
              limit = 10;
            }
            if (offset === void 0) {
              offset = 1;
            }
            _ref = _temp === void 0 ? {
              source: /*#__PURE__*/CancelToken.source()
            } : _temp, source = _ref.source;
            _context.prev = 4;
            _context.next = 7;
            return gqlFetcher(this.chainEnvironment, latestBlockQuery, {
              timeRange: timeRange,
              limit: limit,
              offset: offset
            }, source);
          case 7:
            data = _context.sent;
            return _context.abrupt("return", data);
          case 11:
            _context.prev = 11;
            _context.t0 = _context["catch"](4);
            throw _context.t0;
          case 14:
          case "end":
            return _context.stop();
        }
      }, _callee, this, [[4, 11]]);
    }));
    function getLatestBlocks(_x, _x2, _x3, _x4) {
      return _getLatestBlocks.apply(this, arguments);
    }
    return getLatestBlocks;
  }();
  _proto.getLatestBlocksWithSignatures = /*#__PURE__*/function () {
    var _getLatestBlocksWithSignatures = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(timeRange, limit, offset, _temp2) {
      var _ref2, source, data;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            if (timeRange === void 0) {
              timeRange = [];
            }
            if (limit === void 0) {
              limit = 10;
            }
            if (offset === void 0) {
              offset = 1;
            }
            _ref2 = _temp2 === void 0 ? {
              source: /*#__PURE__*/CancelToken.source()
            } : _temp2, source = _ref2.source;
            _context2.prev = 4;
            _context2.next = 7;
            return gqlFetcher(this.chainEnvironment, latestBlockQueryWithSignatures, {
              timeRange: timeRange,
              limit: limit,
              offset: offset
            }, source);
          case 7:
            data = _context2.sent;
            return _context2.abrupt("return", data);
          case 11:
            _context2.prev = 11;
            _context2.t0 = _context2["catch"](4);
            throw _context2.t0;
          case 14:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[4, 11]]);
    }));
    function getLatestBlocksWithSignatures(_x5, _x6, _x7, _x8) {
      return _getLatestBlocksWithSignatures.apply(this, arguments);
    }
    return getLatestBlocksWithSignatures;
  }()
  /**
   * Fetches specific Block
   * @param {string} height BlockHeight
   * @return {BlockType}
   * @throws {Error}
   */
  ;
  _proto.getBlockByHeight =
  /*#__PURE__*/
  function () {
    var _getBlockByHeight = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(height, _temp3) {
      var _ref3, source, data;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            _ref3 = _temp3 === void 0 ? {
              source: /*#__PURE__*/CancelToken.source()
            } : _temp3, source = _ref3.source;
            _context3.prev = 1;
            _context3.next = 4;
            return gqlFetcher(this.chainEnvironment, specificBlockQuery, {
              height: height,
              source: source
            });
          case 4:
            data = _context3.sent;
            return _context3.abrupt("return", data);
          case 8:
            _context3.prev = 8;
            _context3.t0 = _context3["catch"](1);
            throw _context3.t0;
          case 11:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this, [[1, 8]]);
    }));
    function getBlockByHeight(_x9, _x10) {
      return _getBlockByHeight.apply(this, arguments);
    }
    return getBlockByHeight;
  }()
  /**
   * Fetches latest Transactions
   * @param {string} timeRange Time Range
   * @param {string} limit Page Limit
   * @param {string} offset Page Number
   * @return {PaginatedTransaction}
   * @throws {Error}
   */
  ;
  _proto.getLatestTransactions =
  /*#__PURE__*/
  function () {
    var _getLatestTransactions = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(timeRange, limit, offset, _temp4) {
      var _ref4, source, data;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            if (timeRange === void 0) {
              timeRange = [];
            }
            if (limit === void 0) {
              limit = 10;
            }
            if (offset === void 0) {
              offset = 1;
            }
            _ref4 = _temp4 === void 0 ? {
              source: /*#__PURE__*/CancelToken.source()
            } : _temp4, source = _ref4.source;
            _context4.prev = 4;
            _context4.next = 7;
            return gqlFetcher(this.chainEnvironment, this.applicationAddress ? latestTransactionsOfAddressQuery : latestTransactionsQuery, {
              timeRange: timeRange,
              limit: limit,
              offset: offset
            }, source);
          case 7:
            data = _context4.sent;
            return _context4.abrupt("return", data);
          case 11:
            _context4.prev = 11;
            _context4.t0 = _context4["catch"](4);
            throw _context4.t0;
          case 14:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this, [[4, 11]]);
    }));
    function getLatestTransactions(_x11, _x12, _x13, _x14) {
      return _getLatestTransactions.apply(this, arguments);
    }
    return getLatestTransactions;
  }()
  /**
   * Fetches latest Transactions for a specific address
   * @param {string} address Address
   * @param {string} limit Page Limit
   * @param {string} offset Page Number
   * @return {PaginatedTransaction}
   * @throws {Error}
   */
  ;
  _proto.getLatestTransactionsByAddress =
  /*#__PURE__*/
  function () {
    var _getLatestTransactionsByAddress = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(address, timeRange, limit, offset, _temp5) {
      var _ref5, source, data;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            if (timeRange === void 0) {
              timeRange = [];
            }
            if (limit === void 0) {
              limit = 10;
            }
            if (offset === void 0) {
              offset = 1;
            }
            _ref5 = _temp5 === void 0 ? {
              source: /*#__PURE__*/CancelToken.source()
            } : _temp5, source = _ref5.source;
            _context5.prev = 4;
            _context5.next = 7;
            return gqlFetcher(this.chainEnvironment, latestTransactionsOfAddressQuery, {
              timeRange: timeRange,
              address: address,
              limit: limit,
              offset: offset
            }, source);
          case 7:
            data = _context5.sent;
            return _context5.abrupt("return", data);
          case 11:
            _context5.prev = 11;
            _context5.t0 = _context5["catch"](4);
            throw _context5.t0;
          case 14:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this, [[4, 11]]);
    }));
    function getLatestTransactionsByAddress(_x15, _x16, _x17, _x18, _x19) {
      return _getLatestTransactionsByAddress.apply(this, arguments);
    }
    return getLatestTransactionsByAddress;
  }()
  /**
   * Fetches specific Transaction
   * @param {string} hash
   * @return {Transaction}
   * @throws {Error}
   */
  ;
  _proto.getTransactionByHash =
  /*#__PURE__*/
  function () {
    var _getTransactionByHash = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(hash, _temp6) {
      var _ref6, source, data;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            _ref6 = _temp6 === void 0 ? {
              source: /*#__PURE__*/CancelToken.source()
            } : _temp6, source = _ref6.source;
            _context6.prev = 1;
            _context6.next = 4;
            return gqlFetcher(this.chainEnvironment, specificTransactionQuery, {
              hash: hash
            }, source);
          case 4:
            data = _context6.sent;
            return _context6.abrupt("return", data);
          case 8:
            _context6.prev = 8;
            _context6.t0 = _context6["catch"](1);
            throw _context6.t0;
          case 11:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this, [[1, 8]]);
    }));
    function getTransactionByHash(_x20, _x21) {
      return _getTransactionByHash.apply(this, arguments);
    }
    return getTransactionByHash;
  }()
  /**
   * Fetches latest Crosschains
   * @param {string} timeRange Time Range
   * @param {string} limit Page Limit
   * @param {string} offset Page Number
   * @return {PaginatedCrosschain}
   * @throws {Error}
   */
  ;
  _proto.getLatestCrosschains =
  /*#__PURE__*/
  function () {
    var _getLatestCrosschains = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(timeRange, limit, offset, _temp7) {
      var _ref7, source, data;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            if (timeRange === void 0) {
              timeRange = [];
            }
            if (limit === void 0) {
              limit = 10;
            }
            if (offset === void 0) {
              offset = 1;
            }
            _ref7 = _temp7 === void 0 ? {
              source: /*#__PURE__*/CancelToken.source()
            } : _temp7, source = _ref7.source;
            _context7.prev = 4;
            _context7.next = 7;
            return gqlFetcher(this.chainEnvironment, latestCrosschainsQuery, {
              address: this.applicationAddress,
              timeRange: timeRange,
              limit: limit,
              offset: offset
            }, source);
          case 7:
            data = _context7.sent;
            return _context7.abrupt("return", data);
          case 11:
            _context7.prev = 11;
            _context7.t0 = _context7["catch"](4);
            throw _context7.t0;
          case 14:
          case "end":
            return _context7.stop();
        }
      }, _callee7, this, [[4, 11]]);
    }));
    function getLatestCrosschains(_x22, _x23, _x24, _x25) {
      return _getLatestCrosschains.apply(this, arguments);
    }
    return getLatestCrosschains;
  }()
  /**
   * Fetches specific Crosschains
   * @param {string} timeRange Time Range
   * @param {string} searchTerm Source Sender or Source Transaction Hash
   * @param {string} limit Page Limit
   * @param {string} offset Page Number
   * @return {PaginatedCrosschain}
   * @throws {Error}
   */
  ;
  _proto.getCrosschainBySearch =
  /*#__PURE__*/
  function () {
    var _getCrosschainBySearch = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(searchTerm, srcChainIds, dstChainIds, timeRange, limit, offset, _temp8) {
      var _ref8, source, data;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            if (srcChainIds === void 0) {
              srcChainIds = [];
            }
            if (dstChainIds === void 0) {
              dstChainIds = [];
            }
            if (timeRange === void 0) {
              timeRange = [];
            }
            if (limit === void 0) {
              limit = 10;
            }
            if (offset === void 0) {
              offset = 1;
            }
            _ref8 = _temp8 === void 0 ? {
              source: /*#__PURE__*/CancelToken.source()
            } : _temp8, source = _ref8.source;
            _context8.prev = 6;
            _context8.next = 9;
            return gqlFetcher(this.chainEnvironment, srcChainIds.length === 0 && dstChainIds.length === 0 ? searchSpecificCrosschainQuery : srcChainIds.length > 0 && dstChainIds.length > 0 ? searchSpecificCrosschainChainIdQuery : srcChainIds.length > 0 ? searchSpecificCrosschainSrcChainIdQuery : dstChainIds.length > 0 ? searchSpecificCrosschainDestChainIdQuery : searchSpecificCrosschainQuery, {
              sourceChainIds: srcChainIds,
              destinationChainIds: dstChainIds,
              searchTerm: searchTerm,
              handlerAddress: this.applicationAddress,
              timeRange: timeRange,
              limit: limit,
              offset: offset
            }, source);
          case 9:
            data = _context8.sent;
            return _context8.abrupt("return", data);
          case 13:
            _context8.prev = 13;
            _context8.t0 = _context8["catch"](6);
            throw _context8.t0;
          case 16:
          case "end":
            return _context8.stop();
        }
      }, _callee8, this, [[6, 13]]);
    }));
    function getCrosschainBySearch(_x26, _x27, _x28, _x29, _x30, _x31, _x32) {
      return _getCrosschainBySearch.apply(this, arguments);
    }
    return getCrosschainBySearch;
  }()
  /**
   * Fetches specific Crosschain
   * @param {string} formAttestationId
   * @return {CrosschainType}
   * @throws {Error}
   */
  ;
  _proto.getCrosschainByAttestationId =
  /*#__PURE__*/
  function () {
    var _getCrosschainByAttestationId = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(formAttestationId, _temp9) {
      var _ref9, source, data;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            _ref9 = _temp9 === void 0 ? {
              source: /*#__PURE__*/CancelToken.source()
            } : _temp9, source = _ref9.source;
            _context9.prev = 1;
            _context9.next = 4;
            return gqlFetcher(this.chainEnvironment, specificCrosschainQuery, {
              formAttestationId: formAttestationId
            }, source);
          case 4:
            data = _context9.sent;
            return _context9.abrupt("return", data);
          case 8:
            _context9.prev = 8;
            _context9.t0 = _context9["catch"](1);
            throw _context9.t0;
          case 11:
          case "end":
            return _context9.stop();
        }
      }, _callee9, this, [[1, 8]]);
    }));
    function getCrosschainByAttestationId(_x33, _x34) {
      return _getCrosschainByAttestationId.apply(this, arguments);
    }
    return getCrosschainByAttestationId;
  }()
  /**
   * Fetches latest Fund Deposits
   * @param {string} timeRange Time Range
   * @param {string} limit Page Limit
   * @param {string} offset Page Number
   * @return {PaginatedFundDeposit}
   * @throws {Error}
   */
  ;
  _proto.getLatestFundDeposits =
  /*#__PURE__*/
  function () {
    var _getLatestFundDeposits = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(timeRange, limit, offset, _temp10) {
      var _ref10, source, data;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            if (timeRange === void 0) {
              timeRange = [];
            }
            if (limit === void 0) {
              limit = 10;
            }
            if (offset === void 0) {
              offset = 1;
            }
            _ref10 = _temp10 === void 0 ? {
              source: /*#__PURE__*/CancelToken.source()
            } : _temp10, source = _ref10.source;
            _context10.prev = 4;
            _context10.next = 7;
            return gqlFetcher(this.chainEnvironment, latestFundDepositQuery, {
              address: this.applicationAddress,
              timeRange: timeRange,
              limit: limit,
              offset: offset
            }, source);
          case 7:
            data = _context10.sent;
            return _context10.abrupt("return", data);
          case 11:
            _context10.prev = 11;
            _context10.t0 = _context10["catch"](4);
            throw new Error("Error | getLatestFundDeposits | " + _context10.t0);
          case 14:
          case "end":
            return _context10.stop();
        }
      }, _callee10, this, [[4, 11]]);
    }));
    function getLatestFundDeposits(_x35, _x36, _x37, _x38) {
      return _getLatestFundDeposits.apply(this, arguments);
    }
    return getLatestFundDeposits;
  }()
  /**
   * Fetches specific Fund Deposits
   * @param {string} timeRange Time Range
   * @param {string} searchTerm srcTxHash or contract or srcToken or recipient or depositor
   * @param {string} limit Page Limit
   * @param {string} offset Page Number
   * @return {PaginatedFundDeposit}
   * @throws {Error}
   */
  ;
  _proto.getFundDepositBySearch =
  /*#__PURE__*/
  function () {
    var _getFundDepositBySearch = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(searchTerm, srcChainIds, dstChainIds, timeRange, limit, offset, _temp11) {
      var _ref11, source, data;
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            if (srcChainIds === void 0) {
              srcChainIds = [];
            }
            if (dstChainIds === void 0) {
              dstChainIds = [];
            }
            if (timeRange === void 0) {
              timeRange = [];
            }
            if (limit === void 0) {
              limit = 10;
            }
            if (offset === void 0) {
              offset = 1;
            }
            _ref11 = _temp11 === void 0 ? {
              source: /*#__PURE__*/CancelToken.source()
            } : _temp11, source = _ref11.source;
            _context11.prev = 6;
            _context11.next = 9;
            return gqlFetcher(this.chainEnvironment, srcChainIds.length === 0 && dstChainIds.length === 0 ? searchSpecificFundDepositQuery : srcChainIds.length > 0 && dstChainIds.length > 0 ? searchSpecificFundDepositChainIdQuery : srcChainIds.length > 0 ? searchSpecificFundDepositSrcChainIdQuery : dstChainIds.length > 0 ? searchSpecificFundDepositDestChainIdQuery : searchSpecificFundDepositQuery, {
              sourceChainIds: srcChainIds,
              destinationChainIds: dstChainIds,
              searchTerm: searchTerm,
              timeRange: timeRange,
              limit: limit,
              offset: offset
            }, source);
          case 9:
            data = _context11.sent;
            return _context11.abrupt("return", data);
          case 13:
            _context11.prev = 13;
            _context11.t0 = _context11["catch"](6);
            throw _context11.t0;
          case 16:
          case "end":
            return _context11.stop();
        }
      }, _callee11, this, [[6, 13]]);
    }));
    function getFundDepositBySearch(_x39, _x40, _x41, _x42, _x43, _x44, _x45) {
      return _getFundDepositBySearch.apply(this, arguments);
    }
    return getFundDepositBySearch;
  }()
  /**
   * Fetches specific Fund Deposit
   * @param {string} id
   * @return {FundDepositType}
   * @throws {Error}
   */
  ;
  _proto.getFundDepositById =
  /*#__PURE__*/
  function () {
    var _getFundDepositById = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(id, _temp12) {
      var _ref12, source, data;
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            _ref12 = _temp12 === void 0 ? {
              source: /*#__PURE__*/CancelToken.source()
            } : _temp12, source = _ref12.source;
            _context12.prev = 1;
            _context12.next = 4;
            return gqlFetcher(this.chainEnvironment, specificFundDepositQuery, {
              id: id
            }, source);
          case 4:
            data = _context12.sent;
            return _context12.abrupt("return", data);
          case 8:
            _context12.prev = 8;
            _context12.t0 = _context12["catch"](1);
            throw _context12.t0;
          case 11:
          case "end":
            return _context12.stop();
        }
      }, _callee12, this, [[1, 8]]);
    }));
    function getFundDepositById(_x46, _x47) {
      return _getFundDepositById.apply(this, arguments);
    }
    return getFundDepositById;
  }()
  /**
   * Fetches latest Fund Paid
   * @param {string} timeRange Time Range
   * @param {string} limit Page Limit
   * @param {string} offset Page Number
   * @return {PaginatedFundPaid}
   * @throws {Error}
   */
  ;
  _proto.getLatestFundPaids =
  /*#__PURE__*/
  function () {
    var _getLatestFundPaids = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(timeRange, limit, offset, _temp13) {
      var _ref13, source, data;
      return _regeneratorRuntime().wrap(function _callee13$(_context13) {
        while (1) switch (_context13.prev = _context13.next) {
          case 0:
            if (timeRange === void 0) {
              timeRange = [];
            }
            if (limit === void 0) {
              limit = 10;
            }
            if (offset === void 0) {
              offset = 1;
            }
            _ref13 = _temp13 === void 0 ? {
              source: /*#__PURE__*/CancelToken.source()
            } : _temp13, source = _ref13.source;
            _context13.prev = 4;
            _context13.next = 7;
            return gqlFetcher(this.chainEnvironment, latestFundPaidQuery, {
              address: this.applicationAddress,
              timeRange: timeRange,
              limit: limit,
              offset: offset
            }, source);
          case 7:
            data = _context13.sent;
            return _context13.abrupt("return", data);
          case 11:
            _context13.prev = 11;
            _context13.t0 = _context13["catch"](4);
            throw _context13.t0;
          case 14:
          case "end":
            return _context13.stop();
        }
      }, _callee13, this, [[4, 11]]);
    }));
    function getLatestFundPaids(_x48, _x49, _x50, _x51) {
      return _getLatestFundPaids.apply(this, arguments);
    }
    return getLatestFundPaids;
  }()
  /**
   * Fetches specific Fund Paids
   * @param {string} timeRange Time Range
   * @param {string} searchTerm srcTxHash or contract or srcToken or recipient or depositor
   * @param {string} limit Page Limit
   * @param {string} offset Page Number
   * @return {PaginatedFundPaid}
   * @throws {Error}
   */
  ;
  _proto.getFundPaidBySearch =
  /*#__PURE__*/
  function () {
    var _getFundPaidBySearch = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(searchTerm, srcChainIds, timeRange, limit, offset, _temp14) {
      var _ref14, source, data;
      return _regeneratorRuntime().wrap(function _callee14$(_context14) {
        while (1) switch (_context14.prev = _context14.next) {
          case 0:
            if (srcChainIds === void 0) {
              srcChainIds = [];
            }
            if (timeRange === void 0) {
              timeRange = [];
            }
            if (limit === void 0) {
              limit = 10;
            }
            if (offset === void 0) {
              offset = 1;
            }
            _ref14 = _temp14 === void 0 ? {
              source: /*#__PURE__*/CancelToken.source()
            } : _temp14, source = _ref14.source;
            _context14.prev = 5;
            _context14.next = 8;
            return gqlFetcher(this.chainEnvironment, srcChainIds.length === 0 ? searchSpecificFundPaidQuery : srcChainIds.length > 0 ? searchSpecificFundPaidSrcChainIdQuery : searchSpecificFundPaidQuery, {
              sourceChainIds: srcChainIds,
              searchTerm: searchTerm,
              timeRange: timeRange,
              limit: limit,
              offset: offset
            }, source);
          case 8:
            data = _context14.sent;
            return _context14.abrupt("return", data);
          case 12:
            _context14.prev = 12;
            _context14.t0 = _context14["catch"](5);
            throw _context14.t0;
          case 15:
          case "end":
            return _context14.stop();
        }
      }, _callee14, this, [[5, 12]]);
    }));
    function getFundPaidBySearch(_x52, _x53, _x54, _x55, _x56, _x57) {
      return _getFundPaidBySearch.apply(this, arguments);
    }
    return getFundPaidBySearch;
  }()
  /**
   * Fetches specific Fund Paid
   * @param {string} id
   * @return {FundDepositType}
   * @throws {Error}
   */
  ;
  _proto.getFundPaidById =
  /*#__PURE__*/
  function () {
    var _getFundPaidById = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(id, _temp15) {
      var _ref15, source, data;
      return _regeneratorRuntime().wrap(function _callee15$(_context15) {
        while (1) switch (_context15.prev = _context15.next) {
          case 0:
            _ref15 = _temp15 === void 0 ? {
              source: /*#__PURE__*/CancelToken.source()
            } : _temp15, source = _ref15.source;
            _context15.prev = 1;
            _context15.next = 4;
            return gqlFetcher(this.chainEnvironment, specificFundPaidQuery, {
              id: id
            }, source);
          case 4:
            data = _context15.sent;
            return _context15.abrupt("return", data);
          case 8:
            _context15.prev = 8;
            _context15.t0 = _context15["catch"](1);
            throw _context15.t0;
          case 11:
          case "end":
            return _context15.stop();
        }
      }, _callee15, this, [[1, 8]]);
    }));
    function getFundPaidById(_x58, _x59) {
      return _getFundPaidById.apply(this, arguments);
    }
    return getFundPaidById;
  }()
  /**
   * Fetches specific Transaction
   * @param {string} middlewareContract
   * @param {string} inboundId
   * @return {InboundOutboundMapType[]}
   * @throws {Error}
   */
  ;
  _proto.getOutboundsForInbound =
  /*#__PURE__*/
  function () {
    var _getOutboundsForInbound = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(inboundId, middlewareContract, _temp16) {
      var _ref16, source, data;
      return _regeneratorRuntime().wrap(function _callee16$(_context16) {
        while (1) switch (_context16.prev = _context16.next) {
          case 0:
            if (middlewareContract === void 0) {
              middlewareContract = this.applicationAddress;
            }
            _ref16 = _temp16 === void 0 ? {
              source: /*#__PURE__*/CancelToken.source()
            } : _temp16, source = _ref16.source;
            _context16.prev = 2;
            _context16.next = 5;
            return gqlFetcher(this.chainEnvironment, inboundOutboundQuery, {
              middlewareContract: middlewareContract,
              inboundId: inboundId
            }, source);
          case 5:
            data = _context16.sent;
            return _context16.abrupt("return", data);
          case 9:
            _context16.prev = 9;
            _context16.t0 = _context16["catch"](2);
            throw _context16.t0;
          case 12:
          case "end":
            return _context16.stop();
        }
      }, _callee16, this, [[2, 9]]);
    }));
    function getOutboundsForInbound(_x60, _x61, _x62) {
      return _getOutboundsForInbound.apply(this, arguments);
    }
    return getOutboundsForInbound;
  }()
  /**
   * Fetches specific Transaction
   * @return {ValidatorUptime[]}
   * @throws {Error}
   */
  ;
  _proto.getValidatorsUptime =
  /*#__PURE__*/
  function () {
    var _getValidatorsUptime = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(_temp17) {
      var _ref17, source, data;
      return _regeneratorRuntime().wrap(function _callee17$(_context17) {
        while (1) switch (_context17.prev = _context17.next) {
          case 0:
            _ref17 = _temp17 === void 0 ? {
              source: /*#__PURE__*/CancelToken.source()
            } : _temp17, source = _ref17.source;
            _context17.prev = 1;
            _context17.next = 4;
            return gqlFetcher(this.chainEnvironment, validatorsUptimeQuery, source);
          case 4:
            data = _context17.sent;
            return _context17.abrupt("return", data);
          case 8:
            _context17.prev = 8;
            _context17.t0 = _context17["catch"](1);
            throw _context17.t0;
          case 11:
          case "end":
            return _context17.stop();
        }
      }, _callee17, this, [[1, 8]]);
    }));
    function getValidatorsUptime(_x63) {
      return _getValidatorsUptime.apply(this, arguments);
    }
    return getValidatorsUptime;
  }()
  /**
   * Fetches specific Transaction
   * @param {string} sourceChainId
   * @param {string} nonce
   * @return {InboundOutboundMapType[]}
   * @throws {Error}
   */
  ;
  _proto.getBlockEventsForCrosschain =
  /*#__PURE__*/
  function () {
    var _getBlockEventsForCrosschain = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(sourceChainId, nonce, crosschainEvent) {
      var _allEventHistory$find, crosschainId, crosschainData, allEventHistory, requiredBlock;
      return _regeneratorRuntime().wrap(function _callee18$(_context18) {
        while (1) switch (_context18.prev = _context18.next) {
          case 0:
            _context18.prev = 0;
            crosschainId = sourceChainId + '-' + nonce;
            _context18.next = 4;
            return this.getCrosschainByAttestationId(crosschainId);
          case 4:
            crosschainData = _context18.sent;
            allEventHistory = [].concat(crosschainData.crosschain.eventHistory, crosschainData.crosschain.ackRequest.eventHistory);
            requiredBlock = (_allEventHistory$find = allEventHistory.find(function (historyEventHistory) {
              return historyEventHistory.name.toLowerCase() === crosschainEvent.toLowerCase();
            })) == null ? void 0 : _allEventHistory$find.height;
            if (requiredBlock) {
              _context18.next = 9;
              break;
            }
            throw new Error("Error | getBlockEventsForCrosschain | " + crosschainEvent + " is not present this crosschain record.");
          case 9:
            return _context18.abrupt("return", this.getBlockEvents(requiredBlock.toString()));
          case 12:
            _context18.prev = 12;
            _context18.t0 = _context18["catch"](0);
            throw new Error("Error | getExecutedBlockEventsForCrosschain | " + _context18.t0);
          case 15:
          case "end":
            return _context18.stop();
        }
      }, _callee18, this, [[0, 12]]);
    }));
    function getBlockEventsForCrosschain(_x64, _x65, _x66) {
      return _getBlockEventsForCrosschain.apply(this, arguments);
    }
    return getBlockEventsForCrosschain;
  }();
  _proto.getBlockEvents = /*#__PURE__*/function () {
    var _getBlockEvents = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(blockNumber) {
      var tmRpc, blockData, decoded_end_block_events, decoded_begin_block_events, decoded_txs_results_events, result;
      return _regeneratorRuntime().wrap(function _callee19$(_context19) {
        while (1) switch (_context19.prev = _context19.next) {
          case 0:
            _context19.prev = 0;
            tmRpc = getEndpointsForNetwork(this.chainEnvironment).tmEndpoint;
            _context19.next = 4;
            return restFetcher(tmRpc + "/block_results?height=" + blockNumber);
          case 4:
            blockData = _context19.sent;
            decoded_end_block_events = blockData.result.end_block_events.map(function (eventData) {
              eventData.attributes = eventData.attributes.map(function (attribute) {
                try {
                  attribute.key = fromBase64ToString(attribute.key);
                  attribute.value = fromBase64ToString(attribute.value);
                } catch (e) {
                  console.log('problematic attribute =>', JSON.stringify(attribute));
                }
                return attribute;
              });
              return eventData;
            });
            decoded_begin_block_events = blockData.result.begin_block_events.map(function (eventData) {
              eventData.attributes = eventData.attributes.map(function (attribute) {
                try {
                  attribute.key = fromBase64ToString(attribute.key);
                  attribute.value = fromBase64ToString(attribute.value);
                } catch (e) {
                  console.log('problematic attribute =>', JSON.stringify(attribute));
                }
                return attribute;
              });
              return eventData;
            });
            decoded_txs_results_events = blockData.result.txs_results.map(function (txn) {
              return txn.events.map(function (eventData) {
                eventData.attributes = eventData.attributes.map(function (attribute) {
                  try {
                    attribute.key = fromBase64ToString(attribute.key);
                    attribute.value = fromBase64ToString(attribute.value);
                  } catch (e) {
                    console.log('problematic attribute =>', JSON.stringify(attribute));
                  }
                  return attribute;
                });
                return eventData;
              });
            });
            result = {
              end_block_events: decoded_end_block_events,
              begin_block_events: decoded_begin_block_events,
              txs_results: decoded_txs_results_events
            };
            return _context19.abrupt("return", result);
          case 12:
            _context19.prev = 12;
            _context19.t0 = _context19["catch"](0);
            throw new Error("Error | getExecutedBlockEventsForCrosschain | " + _context19.t0);
          case 15:
          case "end":
            return _context19.stop();
        }
      }, _callee19, this, [[0, 12]]);
    }));
    function getBlockEvents(_x67) {
      return _getBlockEvents.apply(this, arguments);
    }
    return getBlockEvents;
  }();
  return RouterExplorer;
}();

var CrosschainEvent;
(function (CrosschainEvent) {
  CrosschainEvent["CrosschainRequestCreated"] = "routerprotocol.routerchain.crosschain.EventCrosschainRequestCreated";
  CrosschainEvent["CrosschainRequestConfirm"] = "routerprotocol.routerchain.crosschain.EventCrosschainRequestConfirm";
  CrosschainEvent["CrosschainReadyToExecute"] = "routerprotocol.routerchain.crosschain.EventCrosschainReadyToExecute";
  CrosschainEvent["CrosschainExecuted"] = "routerprotocol.routerchain.crosschain.EventCrosschainExecuted";
  CrosschainEvent["CrosschainAckRequestCreated"] = "routerprotocol.routerchain.crosschain.EventCrosschainAckRequestCreated";
  CrosschainEvent["CrosschainAckRequestConfirm"] = "routerprotocol.routerchain.crosschain.EventCrosschainAckRequestConfirm";
  CrosschainEvent["CrosschainAckReadyToExecute"] = "routerprotocol.routerchain.crosschain.EventCrosschainAckReadyToExecute";
  CrosschainEvent["CrosschainAckExecuted"] = "routerprotocol.routerchain.crosschain.EventCrosschainAckExecuted";
  CrosschainEvent["CrosschainAckReceiptCreated"] = "routerprotocol.routerchain.crosschain.EventCrosschainAckReceiptCreated";
  CrosschainEvent["CrosschainRequestCompleted"] = "routerprotocol.routerchain.crosschain.EventCrosschainRequestCompleted";
  CrosschainEvent["CrosschainAckCompleted"] = "routerprotocol.routerchain.crosschain.EventCrosschainAckCompleted";
  CrosschainEvent["CrosschainReceiptCompleted"] = "routerprotocol.routerchain.crosschain.EventCrosschainReceiptCompleted";
  CrosschainEvent["CrosschainRequestFeeSettlement"] = "routerprotocol.routerchain.crosschain.EventCrosschainRequestFeeSettlement";
  CrosschainEvent["CrosschainAckFeeSettlement"] = "routerprotocol.routerchain.crosschain.EventCrosschainAckFeeSettlement";
  CrosschainEvent["HandleNativeTransfer"] = "routerprotocol.routerchain.crosschain.EventHandleNativeTransfer";
  CrosschainEvent["CrosschainExecutionFailed"] = "routerprotocol.routerchain.crosschain.EventCrosschainExecutionFailed";
  CrosschainEvent["CrosschainAckExecutionFailed"] = "routerprotocol.routerchain.crosschain.EventCrosschainAckExecutionFailed";
  CrosschainEvent["AttestationVote"] = "routerprotocol.routerchain.attestation.EventAttestationVote";
  CrosschainEvent["AttestationObserved"] = "routerprotocol.routerchain.attestation.EventAttestationObserved";
})(CrosschainEvent || (CrosschainEvent = {}));

var gqlApis = {
  testnet: 'https://www.routerexplorer.com/gql/testnet',
  devnet: 'https://www.routerexplorer.com/gql/devnet',
  local: 'http://127.0.0.1:3000/gql/query'
};
//console.log(`Constants.ts empty right now`);

var BaseConcreteStrategy = /*#__PURE__*/function () {
  function BaseConcreteStrategy(_ref) {
    var ethereumOptions = _ref.ethereumOptions,
      chainId = _ref.chainId,
      web3 = _ref.web3;
    this.web3 = web3;
    this.ethereumChainId = ethereumOptions ? ethereumOptions.ethereumChainId : undefined;
    this.chainId = chainId;
  }
  var _proto = BaseConcreteStrategy.prototype;
  _proto.getWeb3 = function getWeb3() {
    var web3 = this.web3;
    if (!web3) {
      throw new GeneralException(new Error('This wallet does not support Web3 (its not Ethereum compatible)'), {
        code: UnspecifiedErrorCode,
        type: ErrorType.ExecutionError
      });
    }
    return web3;
  };
  return BaseConcreteStrategy;
}();

var Wallet;
(function (Wallet) {
  Wallet["Metamask"] = "metamask";
  Wallet["Ledger"] = "ledger";
  Wallet["LedgerLegacy"] = "ledger-legacy";
  Wallet["Keplr"] = "keplr";
  Wallet["WalletConnect"] = "wallet-connect";
  Wallet["Leap"] = "leap";
  Wallet["Cosmostation"] = "cosmostation";
  Wallet["CosmostationEth"] = "cosmostation-eth";
})(Wallet || (Wallet = {}));
var WalletDeviceType;
(function (WalletDeviceType) {
  WalletDeviceType["Browser"] = "browser";
  WalletDeviceType["Hardware"] = "hardware";
  WalletDeviceType["Mobile"] = "mobile";
})(WalletDeviceType || (WalletDeviceType = {}));
var WalletAction = /*#__PURE__*/_extends({}, WalletErrorActionModule);

var GAS_LIMIT_MULTIPLIER = 1.3;
var ROUTER_DEFAULT_GAS_PRICE = '500000001';

//import { ethers } from 'ethers';
var $window = /*#__PURE__*/isServerSide() ? {} :
//@ts-ignore
window;
var Metamask = /*#__PURE__*/function (_BaseConcreteStrategy) {
  _inheritsLoose(Metamask, _BaseConcreteStrategy);
  function Metamask(args) {
    var _this;
    _this = _BaseConcreteStrategy.call(this, args) || this;
    _this.ethereum = $window.ethereum;
    return _this;
  }
  var _proto = Metamask.prototype;
  _proto.getWalletDeviceType = /*#__PURE__*/function () {
    var _getWalletDeviceType = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", Promise.resolve(WalletDeviceType.Browser));
          case 1:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    function getWalletDeviceType() {
      return _getWalletDeviceType.apply(this, arguments);
    }
    return getWalletDeviceType;
  }();
  _proto.getAddresses = /*#__PURE__*/function () {
    var _getAddresses = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var ethereum;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            ethereum = this.getEthereum();
            _context2.prev = 1;
            _context2.next = 4;
            return ethereum.request({
              method: 'eth_requestAccounts'
            });
          case 4:
            return _context2.abrupt("return", _context2.sent);
          case 7:
            _context2.prev = 7;
            _context2.t0 = _context2["catch"](1);
            throw new MetamaskException(new Error(_context2.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetAccounts
            });
          case 10:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[1, 7]]);
    }));
    function getAddresses() {
      return _getAddresses.apply(this, arguments);
    }
    return getAddresses;
  }() // eslint-disable-next-line class-methods-use-this
  ;
  _proto.confirm =
  /*#__PURE__*/
  function () {
    var _confirm = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(address) {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", Promise.resolve("0x" + Buffer.from("Confirmation for " + address + " at time: " + Date.now()).toString('hex')));
          case 1:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    function confirm(_x) {
      return _confirm.apply(this, arguments);
    }
    return confirm;
  }();
  _proto.sendEthereumTransaction = /*#__PURE__*/function () {
    var _sendEthereumTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(transaction, _options) {
      var ethereum;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            ethereum = this.getEthereum();
            _context4.prev = 1;
            _context4.next = 4;
            return ethereum.request({
              method: 'eth_sendTransaction',
              params: [transaction]
            });
          case 4:
            return _context4.abrupt("return", _context4.sent);
          case 7:
            _context4.prev = 7;
            _context4.t0 = _context4["catch"](1);
            throw new MetamaskException(new Error(_context4.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SendEthereumTransaction
            });
          case 10:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this, [[1, 7]]);
    }));
    function sendEthereumTransaction(_x2, _x3) {
      return _sendEthereumTransaction.apply(this, arguments);
    }
    return sendEthereumTransaction;
  }() // eslint-disable-next-line class-methods-use-this
  ;
  _proto.sendTransaction =
  /*#__PURE__*/
  function () {
    var _sendTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(_transaction, _options) {
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            throw new MetamaskException(new Error('sendTransaction is not supported. Metamask only supports sending transaction to Ethereum'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SendTransaction
            });
          case 1:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }));
    function sendTransaction(_x4, _x5) {
      return _sendTransaction.apply(this, arguments);
    }
    return sendTransaction;
  }() /** @deprecated */;
  _proto.signTransaction =
  /*#__PURE__*/
  function () {
    var _signTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(eip712json, address) {
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            return _context6.abrupt("return", this.signEip712TypedData(eip712json, address));
          case 1:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this);
    }));
    function signTransaction(_x6, _x7) {
      return _signTransaction.apply(this, arguments);
    }
    return signTransaction;
  }();
  _proto.signEip712TypedData = /*#__PURE__*/function () {
    var _signEip712TypedData = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(eip712json, address) {
      var ethereum;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            ethereum = this.getEthereum();
            _context7.prev = 1;
            _context7.next = 4;
            return ethereum.request({
              method: 'eth_signTypedData_v4',
              params: [address, eip712json]
            });
          case 4:
            return _context7.abrupt("return", _context7.sent);
          case 7:
            _context7.prev = 7;
            _context7.t0 = _context7["catch"](1);
            throw new MetamaskException(new Error(_context7.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SignTransaction
            });
          case 10:
          case "end":
            return _context7.stop();
        }
      }, _callee7, this, [[1, 7]]);
    }));
    function signEip712TypedData(_x8, _x9) {
      return _signEip712TypedData.apply(this, arguments);
    }
    return signEip712TypedData;
  }() // eslint-disable-next-line class-methods-use-this
  ;
  _proto.signCosmosTransaction =
  /*#__PURE__*/
  function () {
    var _signCosmosTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(_transaction, _address) {
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            throw new WalletException(new Error('This wallet does not support signing Cosmos transactions'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SendTransaction
            });
          case 1:
          case "end":
            return _context8.stop();
        }
      }, _callee8);
    }));
    function signCosmosTransaction(_x10, _x11) {
      return _signCosmosTransaction.apply(this, arguments);
    }
    return signCosmosTransaction;
  }();
  _proto.simulateTransaction = /*#__PURE__*/function () {
    var _simulateTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(signedTx, nodeUrl) {
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            return _context9.abrupt("return", simulateRawTx(signedTx, nodeUrl));
          case 1:
          case "end":
            return _context9.stop();
        }
      }, _callee9);
    }));
    function simulateTransaction(_x12, _x13) {
      return _simulateTransaction.apply(this, arguments);
    }
    return simulateTransaction;
  }();
  _proto.broadcastTransaction = /*#__PURE__*/function () {
    var _broadcastTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(signedTx, nodeUrl) {
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            return _context10.abrupt("return", broadcastRawTx(signedTx, nodeUrl));
          case 1:
          case "end":
            return _context10.stop();
        }
      }, _callee10);
    }));
    function broadcastTransaction(_x14, _x15) {
      return _broadcastTransaction.apply(this, arguments);
    }
    return broadcastTransaction;
  }();
  _proto.simulateSignAndBroadcast = /*#__PURE__*/function () {
    var _simulateSignAndBroadcast = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(_ref) {
      var _accountDetails$pubKe, _accountDetails$pubKe2, _eipData$fee$feePayer, _eipData$fee;
      var ethChainId, cosmosChainId, txMsg, nodeUrl, memo, parsedEthChainId, userAccountInfo, baseAccount, accountDetails, context, eipData, simulatedTxPayload, simulatedTx, simulationResponse, simulatedFee, txPayload, signature, signatureBytes, publicKeyHex, publicKey, txPayloadWithPubKey, signDirect, bodyBytes, authInfoBytes, txRawToSend, broadcastResponse;
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            ethChainId = _ref.ethChainId, cosmosChainId = _ref.cosmosChainId, txMsg = _ref.txMsg, nodeUrl = _ref.nodeUrl, memo = _ref.memo;
            //Account Info
            parsedEthChainId = ethChainId.startsWith('0x') ? parseInt(ethChainId, 16) : parseInt(ethChainId);
            _context11.next = 4;
            return new ChainRestAuthApi(nodeUrl).fetchAccount(getRouterSignerAddress(this.ethereum.selectedAddress));
          case 4:
            userAccountInfo = _context11.sent;
            baseAccount = BaseAccount.fromRestApi(userAccountInfo);
            accountDetails = baseAccount.toAccountDetails();
            context = {
              chain: {
                chainId: parsedEthChainId,
                cosmosChainId: cosmosChainId
              },
              sender: {
                accountAddress: getRouterSignerAddress(this.ethereum.selectedAddress),
                sequence: accountDetails.sequence,
                accountNumber: accountDetails.accountNumber,
                pubkey: (_accountDetails$pubKe = (_accountDetails$pubKe2 = accountDetails.pubKey) == null ? void 0 : _accountDetails$pubKe2.key) != null ? _accountDetails$pubKe : ''
              },
              memo: memo != null ? memo : ''
            }; //EIP DATA
            eipData = {
              msgs: [txMsg],
              tx: {
                accountNumber: accountDetails.accountNumber.toString(),
                sequence: accountDetails.sequence.toString(),
                chainId: cosmosChainId
              },
              ethereumChainId: parsedEthChainId,
              fee: {
                feePayer: getRouterSignerAddress(this.ethereum.selectedAddress)
              }
            }; // Simulationx
            simulatedTxPayload = getEtherMintTxPayload(context, eipData);
            simulatedTx = createTxRawForBroadcast(simulatedTxPayload.signDirect.body.toBinary(), simulatedTxPayload.signDirect.authInfo.toBinary(), [new Uint8Array(2)]);
            _context11.next = 13;
            return this.simulateTransaction(simulatedTx, nodeUrl);
          case 13:
            simulationResponse = _context11.sent;
            simulatedFee = {
              amount: [{
                amount: new BigNumberInBase(ROUTER_DEFAULT_GAS_PRICE).times(parseInt((parseInt(simulationResponse.gas_info.gas_used) * GAS_LIMIT_MULTIPLIER).toString())).toString(),
                denom: ROUTER_DENOM
              }],
              gas: parseInt((parseInt(simulationResponse.gas_info.gas_used) * GAS_LIMIT_MULTIPLIER).toString()).toString(),
              feePayer: (_eipData$fee$feePayer = (_eipData$fee = eipData.fee) == null ? void 0 : _eipData$fee.feePayer) != null ? _eipData$fee$feePayer : getRouterSignerAddress(this.ethereum.selectedAddress)
            };
            eipData.fee = simulatedFee;
            txPayload = getEtherMintTxPayload(context, eipData);
            _context11.next = 19;
            return this.signEip712TypedData(JSON.stringify(txPayload.eipToSign), this.ethereum.selectedAddress);
          case 19:
            signature = _context11.sent;
            signatureBytes = hexToBuff(signature);
            publicKeyHex = recoverTypedSignaturePubKey(txPayload.eipToSign, signature);
            publicKey = hexToBase64(publicKeyHex);
            context.sender.pubkey = publicKey;
            txPayloadWithPubKey = getEtherMintTxPayload(context, eipData);
            signDirect = txPayloadWithPubKey.signDirect;
            bodyBytes = signDirect.body.toBinary();
            authInfoBytes = signDirect.authInfo.toBinary();
            txRawToSend = createTxRawForBroadcast(bodyBytes, authInfoBytes, [signatureBytes]);
            _context11.next = 31;
            return this.broadcastTransaction(txRawToSend, nodeUrl);
          case 31:
            broadcastResponse = _context11.sent;
            return _context11.abrupt("return", broadcastResponse);
          case 33:
          case "end":
            return _context11.stop();
        }
      }, _callee11, this);
    }));
    function simulateSignAndBroadcast(_x16) {
      return _simulateSignAndBroadcast.apply(this, arguments);
    }
    return simulateSignAndBroadcast;
  }();
  _proto.getNetworkId = /*#__PURE__*/function () {
    var _getNetworkId = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
      var ethereum;
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            ethereum = this.getEthereum();
            _context12.prev = 1;
            return _context12.abrupt("return", ethereum.request({
              method: 'net_version'
            }));
          case 5:
            _context12.prev = 5;
            _context12.t0 = _context12["catch"](1);
            throw new MetamaskException(new Error(_context12.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetNetworkId
            });
          case 8:
          case "end":
            return _context12.stop();
        }
      }, _callee12, this, [[1, 5]]);
    }));
    function getNetworkId() {
      return _getNetworkId.apply(this, arguments);
    }
    return getNetworkId;
  }();
  _proto.getChainId = /*#__PURE__*/function () {
    var _getChainId = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
      var ethereum;
      return _regeneratorRuntime().wrap(function _callee13$(_context13) {
        while (1) switch (_context13.prev = _context13.next) {
          case 0:
            ethereum = this.getEthereum();
            _context13.prev = 1;
            return _context13.abrupt("return", ethereum.request({
              method: 'eth_chainId'
            }));
          case 5:
            _context13.prev = 5;
            _context13.t0 = _context13["catch"](1);
            throw new MetamaskException(new Error(_context13.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetChainId
            });
          case 8:
          case "end":
            return _context13.stop();
        }
      }, _callee13, this, [[1, 5]]);
    }));
    function getChainId() {
      return _getChainId.apply(this, arguments);
    }
    return getChainId;
  }();
  _proto.getEthereumTransactionReceipt = /*#__PURE__*/function () {
    var _getEthereumTransactionReceipt = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(txHash) {
      var ethereum, interval, transactionReceiptRetry;
      return _regeneratorRuntime().wrap(function _callee15$(_context15) {
        while (1) switch (_context15.prev = _context15.next) {
          case 0:
            ethereum = this.getEthereum();
            interval = 1000;
            transactionReceiptRetry = /*#__PURE__*/function () {
              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
                var receipt;
                return _regeneratorRuntime().wrap(function _callee14$(_context14) {
                  while (1) switch (_context14.prev = _context14.next) {
                    case 0:
                      _context14.next = 2;
                      return ethereum.request({
                        method: 'eth_getTransactionReceipt',
                        params: [txHash]
                      });
                    case 2:
                      receipt = _context14.sent;
                      if (receipt) {
                        _context14.next = 8;
                        break;
                      }
                      _context14.next = 6;
                      return sleep(interval);
                    case 6:
                      _context14.next = 8;
                      return transactionReceiptRetry();
                    case 8:
                      return _context14.abrupt("return", receipt);
                    case 9:
                    case "end":
                      return _context14.stop();
                  }
                }, _callee14);
              }));
              return function transactionReceiptRetry() {
                return _ref2.apply(this, arguments);
              };
            }();
            _context15.prev = 3;
            _context15.next = 6;
            return transactionReceiptRetry();
          case 6:
            return _context15.abrupt("return", _context15.sent);
          case 9:
            _context15.prev = 9;
            _context15.t0 = _context15["catch"](3);
            throw new MetamaskException(new Error(_context15.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetEthereumTransactionReceipt
            });
          case 12:
          case "end":
            return _context15.stop();
        }
      }, _callee15, this, [[3, 9]]);
    }));
    function getEthereumTransactionReceipt(_x17) {
      return _getEthereumTransactionReceipt.apply(this, arguments);
    }
    return getEthereumTransactionReceipt;
  }() // eslint-disable-next-line class-methods-use-this
  ;
  _proto.getPubKey =
  /*#__PURE__*/
  function () {
    var _getPubKey = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
      return _regeneratorRuntime().wrap(function _callee16$(_context16) {
        while (1) switch (_context16.prev = _context16.next) {
          case 0:
            throw new WalletException(new Error('You can only fetch PubKey from Cosmos native wallets'));
          case 1:
          case "end":
            return _context16.stop();
        }
      }, _callee16);
    }));
    function getPubKey() {
      return _getPubKey.apply(this, arguments);
    }
    return getPubKey;
  }();
  _proto.onChainIdChanged = function onChainIdChanged(callback) {
    var ethereum = this.ethereum;
    if (!ethereum) {
      return;
    }
    ethereum.on('chainChanged', callback);
  };
  _proto.onAccountChange = function onAccountChange(callback) {
    var ethereum = this.ethereum;
    if (!ethereum) {
      return;
    }
    ethereum.on('accountsChanged', callback);
  };
  _proto.cancelOnChainIdChange = function cancelOnChainIdChange() {
  };
  _proto.cancelOnAccountChange = function cancelOnAccountChange() {
  };
  _proto.cancelAllEvents = function cancelAllEvents() {
    var ethereum = this.ethereum;
    if (ethereum) {
      ethereum.removeAllListeners();
    }
  };
  _proto.getEthereum = function getEthereum() {
    var ethereum = this.ethereum;
    if (!ethereum) {
      throw new MetamaskException(new Error('Please install the Metamask wallet extension.'), {
        code: UnspecifiedErrorCode,
        type: ErrorType.WalletNotInstalledError,
        contextModule: WalletAction.GetAccounts
      });
    }
    return ethereum;
  };
  return Metamask;
}(BaseConcreteStrategy);

var _experimentalChainsCo;
var experimentalChainsConfig = (_experimentalChainsCo = {}, _experimentalChainsCo[CosmosChainId.Router] = {
  rpc: /*#__PURE__*/getEndpointsForNetwork( /*#__PURE__*/getNetworkType('mainnet')).tmEndpoint,
  rest: /*#__PURE__*/getEndpointsForNetwork( /*#__PURE__*/getNetworkType('mainnet')).lcdEndpoint,
  rpcConfig: undefined,
  restConfig: undefined,
  chainId: /*#__PURE__*/getChainInfoForNetwork(Network.Mainnet),
  chainName: 'Router',
  stakeCurrency: {
    coinDenom: /*#__PURE__*/ROUTER_DENOM.toUpperCase(),
    coinMinimalDenom: ROUTER_DENOM,
    coinDecimals: 18,
    coinGeckoId: ROUTER_DENOM
  },
  walletUrl: 'https://devnet-hub.routerprotocol.com/staking',
  walletUrlForStaking: 'https://devnet-hub.routerprotocol.com/staking',
  bip44: {
    coinType: 60
  },
  bech32Config: /*#__PURE__*/Bech32Address.defaultBech32Config('router'),
  currencies: [{
    coinDenom: /*#__PURE__*/ROUTER_DENOM.toUpperCase(),
    coinMinimalDenom: ROUTER_DENOM,
    coinDecimals: 18,
    coinGeckoId: ROUTER_DENOM
  }],
  feeCurrencies: [{
    coinDenom: /*#__PURE__*/ROUTER_DENOM.toUpperCase(),
    coinMinimalDenom: ROUTER_DENOM,
    coinDecimals: 18,
    coinGeckoId: ROUTER_DENOM,
    gasPriceStep: {
      low: 5000000000,
      average: 25000000000,
      high: 50000000000
    }
  }],
  features: ['ibc-transfer', 'ibc-go', 'eth-address-gen', 'eth-key-sign'],
  beta: true
}, _experimentalChainsCo[TestnetCosmosChainId.Router] = {
  rpc: /*#__PURE__*/getEndpointsForNetwork( /*#__PURE__*/getNetworkType('testnet')).tmEndpoint,
  rest: /*#__PURE__*/getEndpointsForNetwork( /*#__PURE__*/getNetworkType('testnet')).lcdEndpoint,
  rpcConfig: undefined,
  restConfig: undefined,
  chainId: /*#__PURE__*/getChainInfoForNetwork(Network.Testnet),
  chainName: 'Router Testnet',
  stakeCurrency: {
    coinDenom: /*#__PURE__*/ROUTER_DENOM.toUpperCase(),
    coinMinimalDenom: ROUTER_DENOM,
    coinDecimals: 18,
    coinGeckoId: ROUTER_DENOM
  },
  walletUrl: 'https://devnet-hub.routerprotocol.com/staking',
  walletUrlForStaking: 'https://devnet-hub.routerprotocol.com/staking',
  bip44: {
    coinType: 60
  },
  bech32Config: /*#__PURE__*/Bech32Address.defaultBech32Config('router'),
  currencies: [{
    coinDenom: /*#__PURE__*/ROUTER_DENOM.toUpperCase(),
    coinMinimalDenom: ROUTER_DENOM,
    coinDecimals: 18,
    coinGeckoId: ROUTER_DENOM
  }],
  feeCurrencies: [{
    coinDenom: /*#__PURE__*/ROUTER_DENOM.toUpperCase(),
    coinMinimalDenom: ROUTER_DENOM,
    coinDecimals: 18,
    coinGeckoId: ROUTER_DENOM,
    gasPriceStep: {
      low: 5000000000,
      average: 25000000000,
      high: 40000000000
    }
  }],
  coinType: 60,
  features: ['ibc-transfer', 'ibc-go', 'eth-address-gen', 'eth-key-sign']
}, _experimentalChainsCo[DevnetCosmosChainId.Router] = {
  rpc: /*#__PURE__*/getEndpointsForNetwork( /*#__PURE__*/getNetworkType('devnet')).tmEndpoint,
  rest: /*#__PURE__*/getEndpointsForNetwork( /*#__PURE__*/getNetworkType('devnet')).lcdEndpoint,
  rpcConfig: undefined,
  restConfig: undefined,
  chainId: /*#__PURE__*/getChainInfoForNetwork(Network.Devnet),
  chainName: 'Router-Devnet',
  stakeCurrency: {
    coinDenom: /*#__PURE__*/ROUTER_DENOM.toUpperCase(),
    coinMinimalDenom: ROUTER_DENOM,
    coinDecimals: 18,
    coinGeckoId: ROUTER_DENOM
  },
  walletUrl: 'https://devnet-hub.routerprotocol.com/staking',
  walletUrlForStaking: 'https://devnet-hub.routerprotocol.com/staking',
  bip44: {
    coinType: 60
  },
  bech32Config: /*#__PURE__*/Bech32Address.defaultBech32Config('router'),
  currencies: [{
    coinDenom: /*#__PURE__*/ROUTER_DENOM.toUpperCase(),
    coinMinimalDenom: ROUTER_DENOM,
    coinDecimals: 18,
    coinGeckoId: ROUTER_DENOM
  }],
  feeCurrencies: [{
    coinDenom: /*#__PURE__*/ROUTER_DENOM.toUpperCase(),
    coinMinimalDenom: ROUTER_DENOM,
    coinDecimals: 18,
    coinGeckoId: ROUTER_DENOM,
    gasPriceStep: {
      low: 5000000000,
      average: 25000000000,
      high: 40000000000
    }
  }],
  coinType: 60,
  features: ['ibc-transfer', 'ibc-go', 'eth-address-gen', 'eth-key-sign']
}, _experimentalChainsCo);
var getExperimentalChainConfigBasedOnChainId = function getExperimentalChainConfigBasedOnChainId(chainId) {
  return experimentalChainsConfig[chainId];
};

//@ts-ignore
var $window$1 = typeof window !== 'undefined' ? window : {};
var KeplrWallet = /*#__PURE__*/function () {
  function KeplrWallet(chainId) {
    this.chainId = chainId;
  }
  KeplrWallet.experimentalSuggestChainWithChainData = /*#__PURE__*/function () {
    var _experimentalSuggestChainWithChainData = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(chainData) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (!(!$window$1 || $window$1 && !$window$1.keplr)) {
              _context.next = 2;
              break;
            }
            throw new CosmosWalletException(new Error('Please install Keplr extension'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletNotInstalledError
            });
          case 2:
            _context.prev = 2;
            _context.next = 5;
            return $window$1.keplr.experimentalSuggestChain(chainData);
          case 5:
            _context.next = 10;
            break;
          case 7:
            _context.prev = 7;
            _context.t0 = _context["catch"](2);
            throw new CosmosWalletException(new Error(_context.t0.message));
          case 10:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[2, 7]]);
    }));
    function experimentalSuggestChainWithChainData(_x) {
      return _experimentalSuggestChainWithChainData.apply(this, arguments);
    }
    return experimentalSuggestChainWithChainData;
  }();
  var _proto = KeplrWallet.prototype;
  _proto.getKeplrWallet = /*#__PURE__*/function () {
    var _getKeplrWallet = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var chainId, keplr;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            chainId = this.chainId;
            keplr = this.getKeplr();
            _context2.prev = 2;
            _context2.next = 5;
            return keplr.enable(chainId);
          case 5:
            return _context2.abrupt("return", keplr);
          case 8:
            _context2.prev = 8;
            _context2.t0 = _context2["catch"](2);
            throw new CosmosWalletException(new Error(_context2.t0.message));
          case 11:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[2, 8]]);
    }));
    function getKeplrWallet() {
      return _getKeplrWallet.apply(this, arguments);
    }
    return getKeplrWallet;
  }();
  _proto.experimentalSuggestChain = /*#__PURE__*/function () {
    var _experimentalSuggestChain = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      var chainId, keplr, chainData;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            chainId = this.chainId;
            keplr = this.getKeplr();
            chainData = getExperimentalChainConfigBasedOnChainId(chainId);
            if (chainData) {
              _context3.next = 5;
              break;
            }
            throw new CosmosWalletException(new Error("Keplr doesn't support " + chainId + " chainId. Please use another wallet"));
          case 5:
            _context3.prev = 5;
            _context3.next = 8;
            return keplr.experimentalSuggestChain(chainData);
          case 8:
            _context3.next = 13;
            break;
          case 10:
            _context3.prev = 10;
            _context3.t0 = _context3["catch"](5);
            throw new CosmosWalletException(new Error(_context3.t0.message));
          case 13:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this, [[5, 10]]);
    }));
    function experimentalSuggestChain() {
      return _experimentalSuggestChain.apply(this, arguments);
    }
    return experimentalSuggestChain;
  }();
  _proto.getAccounts = /*#__PURE__*/function () {
    var _getAccounts = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
      var chainId, keplr;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            chainId = this.chainId;
            keplr = this.getKeplr();
            _context4.prev = 2;
            return _context4.abrupt("return", keplr.getOfflineSigner(chainId).getAccounts());
          case 6:
            _context4.prev = 6;
            _context4.t0 = _context4["catch"](2);
            throw new CosmosWalletException(new Error(_context4.t0.message), {
              contextModule: WalletErrorActionModule.GetAccounts
            });
          case 9:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this, [[2, 6]]);
    }));
    function getAccounts() {
      return _getAccounts.apply(this, arguments);
    }
    return getAccounts;
  }();
  _proto.getKey = /*#__PURE__*/function () {
    var _getKey = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
      var keplr;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return this.getKeplrWallet();
          case 2:
            keplr = _context5.sent;
            _context5.prev = 3;
            return _context5.abrupt("return", keplr.getKey(this.chainId));
          case 7:
            _context5.prev = 7;
            _context5.t0 = _context5["catch"](3);
            throw new CosmosWalletException(new Error(_context5.t0.message), {
              contextModule: 'Keplr'
            });
          case 10:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this, [[3, 7]]);
    }));
    function getKey() {
      return _getKey.apply(this, arguments);
    }
    return getKey;
  }();
  _proto.getOfflineSigner = /*#__PURE__*/function () {
    var _getOfflineSigner = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
      var chainId, keplr;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            chainId = this.chainId;
            _context6.next = 3;
            return this.getKeplrWallet();
          case 3:
            keplr = _context6.sent;
            _context6.prev = 4;
            return _context6.abrupt("return", keplr.getOfflineSigner(chainId));
          case 8:
            _context6.prev = 8;
            _context6.t0 = _context6["catch"](4);
            throw new CosmosWalletException(new Error(_context6.t0.message), {
              contextModule: 'Keplr'
            });
          case 11:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this, [[4, 8]]);
    }));
    function getOfflineSigner() {
      return _getOfflineSigner.apply(this, arguments);
    }
    return getOfflineSigner;
  }()
  /**
   * This method is used to broadcast a transaction to the network.
   * Since it uses the `Sync` mode, it will not wait for the transaction to be included in a block,
   * so we have to make sure the transaction is included in a block after its broadcasted
   *
   * @param txRaw - raw transaction to broadcast
   * @returns tx hash
   */
  ;
  _proto.broadcastTx =
  /*#__PURE__*/
  function () {
    var _broadcastTx = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(txRaw) {
      var chainId, keplr, result;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            chainId = this.chainId;
            _context7.next = 3;
            return this.getKeplrWallet();
          case 3:
            keplr = _context7.sent;
            _context7.next = 6;
            return keplr.sendTx(chainId, txRaw.serializeBinary(), BroadcastMode$3.Sync);
          case 6:
            result = _context7.sent;
            if (!(!result || result.length === 0)) {
              _context7.next = 9;
              break;
            }
            throw new TransactionException(new Error('Transaction failed to be broadcasted'), {
              contextModule: 'Keplr'
            });
          case 9:
            return _context7.abrupt("return", Buffer.from(result).toString('hex'));
          case 10:
          case "end":
            return _context7.stop();
        }
      }, _callee7, this);
    }));
    function broadcastTx(_x2) {
      return _broadcastTx.apply(this, arguments);
    }
    return broadcastTx;
  }()
  /**
   * This method is used to broadcast a transaction to the network.
   * Since it uses the `Block` mode, and it will wait for the transaction to be included in a block,
   *
   * @param txRaw - raw transaction to broadcast
   * @returns tx hash
   */
  ;
  _proto.broadcastTxBlock =
  /*#__PURE__*/
  function () {
    var _broadcastTxBlock = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(txRaw) {
      var chainId, keplr, result;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            chainId = this.chainId;
            _context8.next = 3;
            return this.getKeplrWallet();
          case 3:
            keplr = _context8.sent;
            _context8.next = 6;
            return keplr.sendTx(chainId, txRaw.serializeBinary(), BroadcastMode$3.Block);
          case 6:
            result = _context8.sent;
            if (!(!result || result.length === 0)) {
              _context8.next = 9;
              break;
            }
            throw new TransactionException(new Error('Transaction failed to be broadcasted'), {
              contextModule: 'Keplr'
            });
          case 9:
            return _context8.abrupt("return", Buffer.from(result).toString('hex'));
          case 10:
          case "end":
            return _context8.stop();
        }
      }, _callee8, this);
    }));
    function broadcastTxBlock(_x3) {
      return _broadcastTxBlock.apply(this, arguments);
    }
    return broadcastTxBlock;
  }();
  _proto.waitTxBroadcasted = /*#__PURE__*/function () {
    var _waitTxBroadcasted = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(txHash) {
      var endpoints, txClient, result;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            _context9.next = 2;
            return this.getChainEndpoints();
          case 2:
            endpoints = _context9.sent;
            txClient = new TxRestClient(endpoints.rest);
            _context9.next = 6;
            return txClient.waitTxBroadcast(txHash);
          case 6:
            result = _context9.sent;
            return _context9.abrupt("return", result.txhash);
          case 8:
          case "end":
            return _context9.stop();
        }
      }, _callee9, this);
    }));
    function waitTxBroadcasted(_x4) {
      return _waitTxBroadcasted.apply(this, arguments);
    }
    return waitTxBroadcasted;
  }();
  _proto.signEIP712CosmosTx = /*#__PURE__*/function () {
    var _signEIP712CosmosTx = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(_ref) {
      var eip712, signDoc, chainId, keplr, key;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            eip712 = _ref.eip712, signDoc = _ref.signDoc;
            chainId = this.chainId;
            _context10.next = 4;
            return this.getKeplrWallet();
          case 4:
            keplr = _context10.sent;
            _context10.next = 7;
            return this.getKey();
          case 7:
            key = _context10.sent;
            _context10.prev = 8;
            return _context10.abrupt("return", keplr.experimentalSignEIP712CosmosTx_v0(chainId, key.bech32Address, eip712, signDoc));
          case 12:
            _context10.prev = 12;
            _context10.t0 = _context10["catch"](8);
            throw new CosmosWalletException(new Error(_context10.t0.message), {
              contextModule: 'Keplr'
            });
          case 15:
          case "end":
            return _context10.stop();
        }
      }, _callee10, this, [[8, 12]]);
    }));
    function signEIP712CosmosTx(_x5) {
      return _signEIP712CosmosTx.apply(this, arguments);
    }
    return signEIP712CosmosTx;
  }();
  _proto.getChainEndpoints = /*#__PURE__*/function () {
    var _getChainEndpoints = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
      var chainId;
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            chainId = this.chainId;
            _context11.prev = 1;
            return _context11.abrupt("return", getEndpointsFromChainId(chainId));
          case 5:
            _context11.prev = 5;
            _context11.t0 = _context11["catch"](1);
            throw new CosmosWalletException(new Error(_context11.t0.message), {
              contextModule: 'Keplr'
            });
          case 8:
          case "end":
            return _context11.stop();
        }
      }, _callee11, this, [[1, 5]]);
    }));
    function getChainEndpoints() {
      return _getChainEndpoints.apply(this, arguments);
    }
    return getChainEndpoints;
  }();
  _proto.checkChainIdSupport = /*#__PURE__*/function () {
    var _checkChainIdSupport = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
      var chainId, keplr;
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            chainId = this.chainId;
            keplr = this.getKeplr();
            _context12.prev = 2;
            _context12.next = 5;
            return keplr.getKey(chainId);
          case 5:
            return _context12.abrupt("return", true);
          case 8:
            _context12.prev = 8;
            _context12.t0 = _context12["catch"](2);
            return _context12.abrupt("return", false);
          case 11:
          case "end":
            return _context12.stop();
        }
      }, _callee12, this, [[2, 8]]);
    }));
    function checkChainIdSupport() {
      return _checkChainIdSupport.apply(this, arguments);
    }
    return checkChainIdSupport;
  }();
  _proto.getKeplr = function getKeplr() {
    if (!$window$1) {
      throw new CosmosWalletException(new Error('Please install Keplr extension'), {
        code: UnspecifiedErrorCode,
        type: ErrorType.WalletNotInstalledError,
        contextModule: 'Keplr'
      });
    }
    if (!$window$1.keplr) {
      throw new CosmosWalletException(new Error('Please install Keplr extension'), {
        code: UnspecifiedErrorCode,
        type: ErrorType.WalletNotInstalledError,
        contextModule: 'Keplr'
      });
    }
    return $window$1.keplr;
  };
  return KeplrWallet;
}();

var Keplr = /*#__PURE__*/function (_BaseConcreteStrategy) {
  _inheritsLoose(Keplr, _BaseConcreteStrategy);
  function Keplr(args) {
    var _this;
    _this = _BaseConcreteStrategy.call(this, args) || this;
    _this.chainId = args.chainId || CosmosChainId.Router;
    _this.keplrWallet = new KeplrWallet(args.chainId);
    return _this;
  }
  var _proto = Keplr.prototype;
  _proto.simulateTransaction = function simulateTransaction(_signedTx, _nodeUrl) {
    throw new Error('Method not implemented.');
  };
  _proto.broadcastTransaction = function broadcastTransaction(_signedTx, _nodeUrl) {
    throw new Error('Method not implemented.');
  };
  _proto.simulateSignAndBroadcast = function simulateSignAndBroadcast(_args) {
    throw new Error('Method not implemented.');
  };
  _proto.onAccountChange = function onAccountChange(_callback) {
    throw new Error('Method not implemented.');
  };
  _proto.onChainIdChange = function onChainIdChange(_callback) {
    throw new Error('Method not implemented.');
  };
  _proto.cancelOnChainIdChange = function cancelOnChainIdChange() {
    throw new Error('Method not implemented.');
  };
  _proto.cancelOnAccountChange = function cancelOnAccountChange() {
    throw new Error('Method not implemented.');
  };
  _proto.cancelAllEvents = function cancelAllEvents() {
    throw new Error('Method not implemented.');
  };
  _proto.disconnect = function disconnect() {
    throw new Error('Method not implemented.');
  };
  _proto.getWalletDeviceType = /*#__PURE__*/function () {
    var _getWalletDeviceType = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var keplrWallet, key;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            keplrWallet = this.getKeplrWallet();
            _context.next = 3;
            return keplrWallet.getKey();
          case 3:
            key = _context.sent;
            return _context.abrupt("return", key.isNanoLedger ? Promise.resolve(WalletDeviceType.Hardware) : Promise.resolve(WalletDeviceType.Browser));
          case 5:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function getWalletDeviceType() {
      return _getWalletDeviceType.apply(this, arguments);
    }
    return getWalletDeviceType;
  }();
  _proto.getAddresses = /*#__PURE__*/function () {
    var _getAddresses = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var keplrWallet, accounts;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            keplrWallet = this.getKeplrWallet();
            _context2.prev = 1;
            _context2.next = 4;
            return keplrWallet.checkChainIdSupport();
          case 4:
            if (_context2.sent) {
              _context2.next = 7;
              break;
            }
            _context2.next = 7;
            return keplrWallet.experimentalSuggestChain();
          case 7:
            _context2.next = 9;
            return keplrWallet.getAccounts();
          case 9:
            accounts = _context2.sent;
            return _context2.abrupt("return", accounts.map(function (account) {
              return account.address;
            }));
          case 13:
            _context2.prev = 13;
            _context2.t0 = _context2["catch"](1);
            throw new CosmosWalletException(new Error(_context2.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetAccounts
            });
          case 16:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[1, 13]]);
    }));
    function getAddresses() {
      return _getAddresses.apply(this, arguments);
    }
    return getAddresses;
  }();
  _proto.confirm = /*#__PURE__*/function () {
    var _confirm = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(address) {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", Promise.resolve("0x" + Buffer.from("Confirmation for " + address + " at time: " + Date.now()).toString('hex')));
          case 1:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    function confirm(_x) {
      return _confirm.apply(this, arguments);
    }
    return confirm;
  }() // eslint-disable-next-line class-methods-use-this
  ;
  _proto.sendEthereumTransaction =
  /*#__PURE__*/
  function () {
    var _sendEthereumTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_transaction, _options) {
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            throw new CosmosWalletException(new Error('sendEthereumTransaction is not supported. Keplr only supports sending cosmos transactions'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SendEthereumTransaction
            });
          case 1:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    function sendEthereumTransaction(_x2, _x3) {
      return _sendEthereumTransaction.apply(this, arguments);
    }
    return sendEthereumTransaction;
  }();
  _proto.sendTransaction = /*#__PURE__*/function () {
    var _sendTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(transaction, _options) {
      var keplrWallet, txRaw;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            keplrWallet = this.keplrWallet;
            txRaw = transaction instanceof TxRaw$1 ? transaction : createTxRawFromSigResponse(transaction);
            _context5.prev = 2;
            _context5.t0 = keplrWallet;
            _context5.next = 6;
            return keplrWallet.broadcastTx(txRaw);
          case 6:
            _context5.t1 = _context5.sent;
            _context5.next = 9;
            return _context5.t0.waitTxBroadcasted.call(_context5.t0, _context5.t1);
          case 9:
            return _context5.abrupt("return", _context5.sent);
          case 12:
            _context5.prev = 12;
            _context5.t2 = _context5["catch"](2);
            throw new TransactionException(new Error(_context5.t2.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.ChainError,
              contextModule: WalletAction.SendTransaction
            });
          case 15:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this, [[2, 12]]);
    }));
    function sendTransaction(_x4, _x5) {
      return _sendTransaction.apply(this, arguments);
    }
    return sendTransaction;
  }() /** @deprecated */;
  _proto.signTransaction =
  /*#__PURE__*/
  function () {
    var _signTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(transaction, routerAddress) {
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            return _context6.abrupt("return", this.signCosmosTransaction(transaction, routerAddress));
          case 1:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this);
    }));
    function signTransaction(_x6, _x7) {
      return _signTransaction.apply(this, arguments);
    }
    return signTransaction;
  }();
  _proto.signCosmosTransaction = /*#__PURE__*/function () {
    var _signCosmosTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(transaction, routerAddress) {
      var keplrWallet, signer, signDoc;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            keplrWallet = this.getKeplrWallet();
            _context7.next = 3;
            return keplrWallet.getOfflineSigner();
          case 3:
            signer = _context7.sent;
            signDoc = createCosmosSignDocFromTransaction(transaction);
            _context7.prev = 5;
            return _context7.abrupt("return", signer.signDirect(routerAddress, signDoc));
          case 9:
            _context7.prev = 9;
            _context7.t0 = _context7["catch"](5);
            throw new CosmosWalletException(new Error(_context7.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SendTransaction
            });
          case 12:
          case "end":
            return _context7.stop();
        }
      }, _callee7, this, [[5, 9]]);
    }));
    function signCosmosTransaction(_x8, _x9) {
      return _signCosmosTransaction.apply(this, arguments);
    }
    return signCosmosTransaction;
  }();
  _proto.signEip712TypedData = /*#__PURE__*/function () {
    var _signEip712TypedData = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(_transaction, _address) {
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            throw new CosmosWalletException(new Error('This wallet does not support signing Ethereum transactions'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SendTransaction
            });
          case 1:
          case "end":
            return _context8.stop();
        }
      }, _callee8);
    }));
    function signEip712TypedData(_x10, _x11) {
      return _signEip712TypedData.apply(this, arguments);
    }
    return signEip712TypedData;
  }();
  _proto.getNetworkId = /*#__PURE__*/function () {
    var _getNetworkId = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            throw new CosmosWalletException(new Error('getNetworkId is not supported on Keplr'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetNetworkId
            });
          case 1:
          case "end":
            return _context9.stop();
        }
      }, _callee9);
    }));
    function getNetworkId() {
      return _getNetworkId.apply(this, arguments);
    }
    return getNetworkId;
  }();
  _proto.getChainId = /*#__PURE__*/function () {
    var _getChainId = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            throw new CosmosWalletException(new Error('getChainId is not supported on Keplr'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetChainId
            });
          case 1:
          case "end":
            return _context10.stop();
        }
      }, _callee10);
    }));
    function getChainId() {
      return _getChainId.apply(this, arguments);
    }
    return getChainId;
  }();
  _proto.getEthereumTransactionReceipt = /*#__PURE__*/function () {
    var _getEthereumTransactionReceipt = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(_txHash) {
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            throw new CosmosWalletException(new Error('getEthereumTransactionReceipt is not supported on Keplr'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetEthereumTransactionReceipt
            });
          case 1:
          case "end":
            return _context11.stop();
        }
      }, _callee11);
    }));
    function getEthereumTransactionReceipt(_x12) {
      return _getEthereumTransactionReceipt.apply(this, arguments);
    }
    return getEthereumTransactionReceipt;
  }();
  _proto.getPubKey = /*#__PURE__*/function () {
    var _getPubKey = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
      var keplrWallet, key;
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            keplrWallet = this.getKeplrWallet();
            _context12.next = 3;
            return keplrWallet.getKey();
          case 3:
            key = _context12.sent;
            return _context12.abrupt("return", Buffer.from(key.pubKey).toString('base64'));
          case 5:
          case "end":
            return _context12.stop();
        }
      }, _callee12, this);
    }));
    function getPubKey() {
      return _getPubKey.apply(this, arguments);
    }
    return getPubKey;
  }();
  _proto.getKeplrWallet = function getKeplrWallet() {
    var keplrWallet = this.keplrWallet;
    if (!keplrWallet) {
      throw new CosmosWalletException(new Error('Please install the Keplr wallet extension'), {
        code: UnspecifiedErrorCode,
        type: ErrorType.WalletNotInstalledError,
        contextModule: WalletAction.SignTransaction
      });
    }
    return keplrWallet;
  };
  return Keplr;
}(BaseConcreteStrategy);

//@ts-ignore
var $window$2 = typeof window !== 'undefined' ? window : {};
var LeapWallet = /*#__PURE__*/function () {
  function LeapWallet(chainId) {
    var _this = this;
    this.checkChainIdSupport = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var chainId, leap;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            chainId = _this.chainId;
            leap = _this.getLeap();
            _context.prev = 2;
            _context.next = 5;
            return leap.getKey(chainId);
          case 5:
            return _context.abrupt("return", true);
          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](2);
            return _context.abrupt("return", false);
          case 11:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[2, 8]]);
    }));
    this.chainId = chainId;
  }
  var _proto = LeapWallet.prototype;
  _proto.getLeapWallet = /*#__PURE__*/function () {
    var _getLeapWallet = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var chainId, leap;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            chainId = this.chainId;
            leap = this.getLeap();
            _context2.prev = 2;
            _context2.next = 5;
            return leap.enable(chainId);
          case 5:
            return _context2.abrupt("return", leap);
          case 8:
            _context2.prev = 8;
            _context2.t0 = _context2["catch"](2);
            throw new CosmosWalletException(new Error(_context2.t0.message));
          case 11:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[2, 8]]);
    }));
    function getLeapWallet() {
      return _getLeapWallet.apply(this, arguments);
    }
    return getLeapWallet;
  }();
  _proto.getAccounts = /*#__PURE__*/function () {
    var _getAccounts = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      var chainId, leap;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            chainId = this.chainId;
            leap = this.getLeap();
            _context3.prev = 2;
            return _context3.abrupt("return", leap.getOfflineSigner(chainId).getAccounts());
          case 6:
            _context3.prev = 6;
            _context3.t0 = _context3["catch"](2);
            throw new CosmosWalletException(new Error(_context3.t0.message), {
              contextModule: WalletErrorActionModule.GetAccounts
            });
          case 9:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this, [[2, 6]]);
    }));
    function getAccounts() {
      return _getAccounts.apply(this, arguments);
    }
    return getAccounts;
  }();
  _proto.getKey = /*#__PURE__*/function () {
    var _getKey = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
      var leap;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return this.getLeapWallet();
          case 2:
            leap = _context4.sent;
            _context4.prev = 3;
            return _context4.abrupt("return", leap.getKey(this.chainId));
          case 7:
            _context4.prev = 7;
            _context4.t0 = _context4["catch"](3);
            throw new CosmosWalletException(new Error(_context4.t0.message), {
              contextModule: 'Leap'
            });
          case 10:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this, [[3, 7]]);
    }));
    function getKey() {
      return _getKey.apply(this, arguments);
    }
    return getKey;
  }();
  _proto.getOfflineSigner = /*#__PURE__*/function () {
    var _getOfflineSigner = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
      var chainId, leap;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            chainId = this.chainId;
            _context5.next = 3;
            return this.getLeapWallet();
          case 3:
            leap = _context5.sent;
            _context5.prev = 4;
            return _context5.abrupt("return", leap.getOfflineSigner(chainId));
          case 8:
            _context5.prev = 8;
            _context5.t0 = _context5["catch"](4);
            throw new CosmosWalletException(new Error(_context5.t0.message), {
              contextModule: 'Leap'
            });
          case 11:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this, [[4, 8]]);
    }));
    function getOfflineSigner() {
      return _getOfflineSigner.apply(this, arguments);
    }
    return getOfflineSigner;
  }()
  /**
   * This method is used to broadcast a transaction to the network.
   * Since it uses the `Sync` mode, it will not wait for the transaction to be included in a block,
   * so we have to make sure the transaction is included in a block after its broadcasted
   *
   * @param txRaw - raw transaction to broadcast
   * @returns tx hash
   */
  ;
  _proto.broadcastTx =
  /*#__PURE__*/
  function () {
    var _broadcastTx = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(txRaw) {
      var chainId, leap, result;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            chainId = this.chainId;
            _context6.next = 3;
            return this.getLeapWallet();
          case 3:
            leap = _context6.sent;
            _context6.next = 6;
            return leap.sendTx(chainId, txRaw.serializeBinary(), BroadcastMode$3.Sync);
          case 6:
            result = _context6.sent;
            if (!(!result || result.length === 0)) {
              _context6.next = 9;
              break;
            }
            throw new TransactionException(new Error('Transaction failed to be broadcasted'), {
              contextModule: 'Leap'
            });
          case 9:
            return _context6.abrupt("return", Buffer.from(result).toString('hex'));
          case 10:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this);
    }));
    function broadcastTx(_x) {
      return _broadcastTx.apply(this, arguments);
    }
    return broadcastTx;
  }()
  /**
   * This method is used to broadcast a transaction to the network.
   * Since it uses the `Block` mode, and it will wait for the transaction to be included in a block,
   *
   * @param txRaw - raw transaction to broadcast
   * @returns tx hash
   */
  ;
  _proto.broadcastTxBlock =
  /*#__PURE__*/
  function () {
    var _broadcastTxBlock = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(txRaw) {
      var chainId, leap, result;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            chainId = this.chainId;
            _context7.next = 3;
            return this.getLeapWallet();
          case 3:
            leap = _context7.sent;
            _context7.next = 6;
            return leap.sendTx(chainId, txRaw.serializeBinary(), BroadcastMode$3.Block);
          case 6:
            result = _context7.sent;
            if (!(!result || result.length === 0)) {
              _context7.next = 9;
              break;
            }
            throw new TransactionException(new Error('Transaction failed to be broadcasted'), {
              contextModule: 'Leap'
            });
          case 9:
            return _context7.abrupt("return", Buffer.from(result).toString('hex'));
          case 10:
          case "end":
            return _context7.stop();
        }
      }, _callee7, this);
    }));
    function broadcastTxBlock(_x2) {
      return _broadcastTxBlock.apply(this, arguments);
    }
    return broadcastTxBlock;
  }();
  _proto.waitTxBroadcasted = /*#__PURE__*/function () {
    var _waitTxBroadcasted = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(txHash) {
      var endpoints, txClient, result;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            _context8.next = 2;
            return this.getChainEndpoints();
          case 2:
            endpoints = _context8.sent;
            txClient = new TxRestClient(endpoints.rest);
            _context8.next = 6;
            return txClient.waitTxBroadcast(txHash);
          case 6:
            result = _context8.sent;
            return _context8.abrupt("return", result.txhash);
          case 8:
          case "end":
            return _context8.stop();
        }
      }, _callee8, this);
    }));
    function waitTxBroadcasted(_x3) {
      return _waitTxBroadcasted.apply(this, arguments);
    }
    return waitTxBroadcasted;
  }();
  _proto.getChainEndpoints = /*#__PURE__*/function () {
    var _getChainEndpoints = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
      var chainId;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            chainId = this.chainId;
            _context9.prev = 1;
            return _context9.abrupt("return", getEndpointsFromChainId(chainId));
          case 5:
            _context9.prev = 5;
            _context9.t0 = _context9["catch"](1);
            throw new CosmosWalletException(new Error(_context9.t0.message), {
              contextModule: 'Leap'
            });
          case 8:
          case "end":
            return _context9.stop();
        }
      }, _callee9, this, [[1, 5]]);
    }));
    function getChainEndpoints() {
      return _getChainEndpoints.apply(this, arguments);
    }
    return getChainEndpoints;
  }();
  _proto.getLeap = function getLeap() {
    if (!$window$2) {
      throw new CosmosWalletException(new Error('Please install Leap extension'), {
        code: UnspecifiedErrorCode,
        type: ErrorType.WalletNotInstalledError,
        contextModule: 'Leap'
      });
    }
    if (!$window$2.keplr) {
      throw new CosmosWalletException(new Error('Please install Leap extension'), {
        code: UnspecifiedErrorCode,
        type: ErrorType.WalletNotInstalledError,
        contextModule: 'Leap'
      });
    }
    return $window$2.leap;
  };
  return LeapWallet;
}();

var Leap = /*#__PURE__*/function (_BaseConcreteStrategy) {
  _inheritsLoose(Leap, _BaseConcreteStrategy);
  function Leap(args) {
    var _this;
    _this = _BaseConcreteStrategy.call(this, args) || this;
    _this.chainId = args.chainId || CosmosChainId.Router;
    _this.leapWallet = new LeapWallet(args.chainId);
    return _this;
  }
  var _proto = Leap.prototype;
  _proto.simulateTransaction = function simulateTransaction(_signedTx, _nodeUrl) {
    throw new Error('Method not implemented.');
  };
  _proto.broadcastTransaction = function broadcastTransaction(_signedTx, _nodeUrl) {
    throw new Error('Method not implemented.');
  };
  _proto.simulateSignAndBroadcast = function simulateSignAndBroadcast(_args) {
    throw new Error('Method not implemented.');
  };
  _proto.onAccountChange = function onAccountChange(_callback) {
    throw new Error('Method not implemented.');
  };
  _proto.onChainIdChange = function onChainIdChange(_callback) {
    throw new Error('Method not implemented.');
  };
  _proto.cancelOnChainIdChange = function cancelOnChainIdChange() {
    throw new Error('Method not implemented.');
  };
  _proto.cancelOnAccountChange = function cancelOnAccountChange() {
    throw new Error('Method not implemented.');
  };
  _proto.cancelAllEvents = function cancelAllEvents() {
    throw new Error('Method not implemented.');
  };
  _proto.disconnect = function disconnect() {
    throw new Error('Method not implemented.');
  };
  _proto.getWalletDeviceType = /*#__PURE__*/function () {
    var _getWalletDeviceType = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", Promise.resolve(WalletDeviceType.Browser));
          case 1:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    function getWalletDeviceType() {
      return _getWalletDeviceType.apply(this, arguments);
    }
    return getWalletDeviceType;
  }();
  _proto.getAddresses = /*#__PURE__*/function () {
    var _getAddresses = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var chainId, leapWallet, accounts;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            chainId = this.chainId;
            leapWallet = this.getLeapWallet();
            _context2.prev = 2;
            _context2.next = 5;
            return leapWallet.checkChainIdSupport();
          case 5:
            if (_context2.sent) {
              _context2.next = 7;
              break;
            }
            throw new CosmosWalletException(new Error("The " + chainId + " is not supported on Leap."), {
              type: ErrorType.WalletError
            });
          case 7:
            _context2.next = 9;
            return leapWallet.getAccounts();
          case 9:
            accounts = _context2.sent;
            return _context2.abrupt("return", accounts.map(function (account) {
              return account.address;
            }));
          case 13:
            _context2.prev = 13;
            _context2.t0 = _context2["catch"](2);
            throw new CosmosWalletException(new Error(_context2.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetAccounts
            });
          case 16:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[2, 13]]);
    }));
    function getAddresses() {
      return _getAddresses.apply(this, arguments);
    }
    return getAddresses;
  }();
  _proto.confirm = /*#__PURE__*/function () {
    var _confirm = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(address) {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", Promise.resolve("0x" + Buffer.from("Confirmation for " + address + " at time: " + Date.now()).toString('hex')));
          case 1:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    function confirm(_x) {
      return _confirm.apply(this, arguments);
    }
    return confirm;
  }() // eslint-disable-next-line class-methods-use-this
  ;
  _proto.sendEthereumTransaction =
  /*#__PURE__*/
  function () {
    var _sendEthereumTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_transaction, _options) {
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            throw new CosmosWalletException(new Error('sendEthereumTransaction is not supported. Leap only supports sending cosmos transactions'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SendEthereumTransaction
            });
          case 1:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    function sendEthereumTransaction(_x2, _x3) {
      return _sendEthereumTransaction.apply(this, arguments);
    }
    return sendEthereumTransaction;
  }();
  _proto.sendTransaction = /*#__PURE__*/function () {
    var _sendTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(transaction, _options) {
      var leapWallet, txRaw;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            leapWallet = this.leapWallet;
            txRaw = transaction instanceof TxRaw$1 ? transaction : createTxRawFromSigResponse(transaction);
            _context5.prev = 2;
            _context5.t0 = leapWallet;
            _context5.next = 6;
            return leapWallet.broadcastTx(txRaw);
          case 6:
            _context5.t1 = _context5.sent;
            _context5.next = 9;
            return _context5.t0.waitTxBroadcasted.call(_context5.t0, _context5.t1);
          case 9:
            return _context5.abrupt("return", _context5.sent);
          case 12:
            _context5.prev = 12;
            _context5.t2 = _context5["catch"](2);
            throw new TransactionException(new Error(_context5.t2.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.ChainError,
              contextModule: WalletAction.SendTransaction
            });
          case 15:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this, [[2, 12]]);
    }));
    function sendTransaction(_x4, _x5) {
      return _sendTransaction.apply(this, arguments);
    }
    return sendTransaction;
  }() /** @deprecated */;
  _proto.signTransaction =
  /*#__PURE__*/
  function () {
    var _signTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(transaction, routerAddress) {
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            return _context6.abrupt("return", this.signCosmosTransaction(transaction, routerAddress));
          case 1:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this);
    }));
    function signTransaction(_x6, _x7) {
      return _signTransaction.apply(this, arguments);
    }
    return signTransaction;
  }();
  _proto.signCosmosTransaction = /*#__PURE__*/function () {
    var _signCosmosTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(transaction, address) {
      var leapWallet, signer, signDoc;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            leapWallet = this.getLeapWallet();
            _context7.next = 3;
            return leapWallet.getOfflineSigner();
          case 3:
            signer = _context7.sent;
            signDoc = createCosmosSignDocFromTransaction(transaction);
            _context7.prev = 5;
            return _context7.abrupt("return", signer.signDirect(address, signDoc));
          case 9:
            _context7.prev = 9;
            _context7.t0 = _context7["catch"](5);
            throw new CosmosWalletException(new Error(_context7.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SendTransaction
            });
          case 12:
          case "end":
            return _context7.stop();
        }
      }, _callee7, this, [[5, 9]]);
    }));
    function signCosmosTransaction(_x8, _x9) {
      return _signCosmosTransaction.apply(this, arguments);
    }
    return signCosmosTransaction;
  }();
  _proto.signEip712TypedData = /*#__PURE__*/function () {
    var _signEip712TypedData = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(_eip712TypedData, _address) {
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            throw new CosmosWalletException(new Error('This wallet does not support signing Ethereum transactions'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SendTransaction
            });
          case 1:
          case "end":
            return _context8.stop();
        }
      }, _callee8);
    }));
    function signEip712TypedData(_x10, _x11) {
      return _signEip712TypedData.apply(this, arguments);
    }
    return signEip712TypedData;
  }();
  _proto.getNetworkId = /*#__PURE__*/function () {
    var _getNetworkId = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            throw new CosmosWalletException(new Error('getNetworkId is not supported on Leap'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetNetworkId
            });
          case 1:
          case "end":
            return _context9.stop();
        }
      }, _callee9);
    }));
    function getNetworkId() {
      return _getNetworkId.apply(this, arguments);
    }
    return getNetworkId;
  }();
  _proto.getChainId = /*#__PURE__*/function () {
    var _getChainId = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            throw new CosmosWalletException(new Error('getChainId is not supported on Leap'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetChainId
            });
          case 1:
          case "end":
            return _context10.stop();
        }
      }, _callee10);
    }));
    function getChainId() {
      return _getChainId.apply(this, arguments);
    }
    return getChainId;
  }();
  _proto.getEthereumTransactionReceipt = /*#__PURE__*/function () {
    var _getEthereumTransactionReceipt = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(_txHash) {
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            throw new CosmosWalletException(new Error('getEthereumTransactionReceipt is not supported on Leap'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetEthereumTransactionReceipt
            });
          case 1:
          case "end":
            return _context11.stop();
        }
      }, _callee11);
    }));
    function getEthereumTransactionReceipt(_x12) {
      return _getEthereumTransactionReceipt.apply(this, arguments);
    }
    return getEthereumTransactionReceipt;
  }();
  _proto.getPubKey = /*#__PURE__*/function () {
    var _getPubKey = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
      var keplrWallet, key;
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            keplrWallet = this.getLeapWallet();
            _context12.next = 3;
            return keplrWallet.getKey();
          case 3:
            key = _context12.sent;
            return _context12.abrupt("return", Buffer.from(key.pubKey).toString('base64'));
          case 5:
          case "end":
            return _context12.stop();
        }
      }, _callee12, this);
    }));
    function getPubKey() {
      return _getPubKey.apply(this, arguments);
    }
    return getPubKey;
  }();
  _proto.getLeapWallet = function getLeapWallet() {
    var leapWallet = this.leapWallet;
    if (!leapWallet) {
      throw new CosmosWalletException(new Error('Please install the Leap wallet extension'), {
        code: UnspecifiedErrorCode,
        type: ErrorType.WalletNotInstalledError,
        contextModule: WalletAction.SignTransaction
      });
    }
    return leapWallet;
  };
  return Leap;
}(BaseConcreteStrategy);

var ROUTER_CHAIN_NAME = 'router';
var Cosmostation = /*#__PURE__*/function (_BaseConcreteStrategy) {
  _inheritsLoose(Cosmostation, _BaseConcreteStrategy);
  function Cosmostation(args) {
    var _this;
    _this = _BaseConcreteStrategy.call(this, args) || this;
    _this.chainId = args.chainId || CosmosChainId.Router;
    return _this;
  }
  var _proto = Cosmostation.prototype;
  _proto.simulateTransaction = function simulateTransaction(_signedTx, _nodeUrl) {
    throw new Error('Method not implemented.');
  };
  _proto.broadcastTransaction = function broadcastTransaction(_signedTx, _nodeUrl) {
    throw new Error('Method not implemented.');
  };
  _proto.simulateSignAndBroadcast = function simulateSignAndBroadcast(_args) {
    throw new Error('Method not implemented.');
  };
  _proto.onAccountChange = function onAccountChange(_callback) {
    throw new Error('Method not implemented.');
  };
  _proto.onChainIdChange = function onChainIdChange(_callback) {
    throw new Error('Method not implemented.');
  };
  _proto.cancelOnChainIdChange = function cancelOnChainIdChange() {
    throw new Error('Method not implemented.');
  };
  _proto.cancelOnAccountChange = function cancelOnAccountChange() {
    throw new Error('Method not implemented.');
  };
  _proto.cancelAllEvents = function cancelAllEvents() {
    throw new Error('Method not implemented.');
  };
  _proto.disconnect = function disconnect() {
    throw new Error('Method not implemented.');
  };
  _proto.getWalletDeviceType = /*#__PURE__*/function () {
    var _getWalletDeviceType = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", Promise.resolve(WalletDeviceType.Browser));
          case 1:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    function getWalletDeviceType() {
      return _getWalletDeviceType.apply(this, arguments);
    }
    return getWalletDeviceType;
  }();
  _proto.getAddresses = /*#__PURE__*/function () {
    var _getAddresses = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var provider, accounts;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return this.getProvider();
          case 2:
            provider = _context2.sent;
            _context2.prev = 3;
            _context2.next = 6;
            return provider.requestAccount(ROUTER_CHAIN_NAME);
          case 6:
            accounts = _context2.sent;
            return _context2.abrupt("return", [accounts.address]);
          case 10:
            _context2.prev = 10;
            _context2.t0 = _context2["catch"](3);
            if (!(_context2.t0.code === 4001)) {
              _context2.next = 14;
              break;
            }
            throw new CosmosWalletException(new Error('The user rejected the request'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetAccounts
            });
          case 14:
            throw new CosmosWalletException(new Error(_context2.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetAccounts
            });
          case 15:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[3, 10]]);
    }));
    function getAddresses() {
      return _getAddresses.apply(this, arguments);
    }
    return getAddresses;
  }();
  _proto.confirm = /*#__PURE__*/function () {
    var _confirm = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(address) {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", Promise.resolve("0x" + Buffer.from("Confirmation for " + address + " at time: " + Date.now()).toString('hex')));
          case 1:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    function confirm(_x) {
      return _confirm.apply(this, arguments);
    }
    return confirm;
  }() // eslint-disable-next-line class-methods-use-this
  ;
  _proto.sendEthereumTransaction =
  /*#__PURE__*/
  function () {
    var _sendEthereumTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_transaction, _options) {
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            throw new CosmosWalletException(new Error('sendEthereumTransaction is not supported. Cosmostation only supports sending cosmos transactions'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SendEthereumTransaction
            });
          case 1:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    function sendEthereumTransaction(_x2, _x3) {
      return _sendEthereumTransaction.apply(this, arguments);
    }
    return sendEthereumTransaction;
  }();
  _proto.sendTransaction = /*#__PURE__*/function () {
    var _sendTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(transaction, _options) {
      var provider, txRaw, response;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return this.getProvider();
          case 2:
            provider = _context5.sent;
            txRaw = transaction instanceof TxRaw$1 ? transaction : createTxRawFromSigResponse(transaction);
            _context5.prev = 4;
            _context5.next = 7;
            return provider.sendTransaction(ROUTER_CHAIN_NAME, txRaw.serializeBinary(), SEND_TRANSACTION_MODE.ASYNC);
          case 7:
            response = _context5.sent;
            return _context5.abrupt("return", response.tx_response.txhash);
          case 11:
            _context5.prev = 11;
            _context5.t0 = _context5["catch"](4);
            throw new TransactionException(new Error(_context5.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.ChainError,
              contextModule: WalletAction.SendTransaction
            });
          case 14:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this, [[4, 11]]);
    }));
    function sendTransaction(_x4, _x5) {
      return _sendTransaction.apply(this, arguments);
    }
    return sendTransaction;
  }() /** @deprecated * */;
  _proto.signTransaction =
  /*#__PURE__*/
  function () {
    var _signTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(transaction, address) {
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            return _context6.abrupt("return", this.signCosmosTransaction(transaction, address));
          case 1:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this);
    }));
    function signTransaction(_x6, _x7) {
      return _signTransaction.apply(this, arguments);
    }
    return signTransaction;
  }();
  _proto.signCosmosTransaction = /*#__PURE__*/function () {
    var _signCosmosTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(transaction, _address) {
      var chainId, provider, signDoc, signDirectResponse;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            chainId = this.chainId;
            _context7.next = 3;
            return this.getProvider();
          case 3:
            provider = _context7.sent;
            signDoc = createCosmosSignDocFromTransaction(transaction);
            _context7.prev = 5;
            _context7.next = 8;
            return provider.signDirect(ROUTER_CHAIN_NAME, {
              chain_id: chainId,
              body_bytes: signDoc.bodyBytes,
              auth_info_bytes: signDoc.authInfoBytes,
              account_number: signDoc.accountNumber.toString()
            }, {
              fee: true,
              memo: true
            });
          case 8:
            signDirectResponse = _context7.sent;
            return _context7.abrupt("return", {
              signed: makeSignDoc(signDirectResponse.signed_doc.body_bytes, signDirectResponse.signed_doc.auth_info_bytes, signDirectResponse.signed_doc.chain_id, parseInt(signDirectResponse.signed_doc.account_number, 10)),
              signature: {
                signature: signDirectResponse.signature
              }
            });
          case 12:
            _context7.prev = 12;
            _context7.t0 = _context7["catch"](5);
            throw new CosmosWalletException(new Error(_context7.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SendTransaction
            });
          case 15:
          case "end":
            return _context7.stop();
        }
      }, _callee7, this, [[5, 12]]);
    }));
    function signCosmosTransaction(_x8, _x9) {
      return _signCosmosTransaction.apply(this, arguments);
    }
    return signCosmosTransaction;
  }();
  _proto.getPubKey = /*#__PURE__*/function () {
    var _getPubKey = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
      var provider, account;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            _context8.next = 2;
            return this.getProvider();
          case 2:
            provider = _context8.sent;
            _context8.prev = 3;
            _context8.next = 6;
            return provider.requestAccount(ROUTER_CHAIN_NAME);
          case 6:
            account = _context8.sent;
            return _context8.abrupt("return", Buffer.from(account.publicKey).toString('base64'));
          case 10:
            _context8.prev = 10;
            _context8.t0 = _context8["catch"](3);
            if (!(_context8.t0.code === 4001)) {
              _context8.next = 14;
              break;
            }
            throw new CosmosWalletException(new Error('The user rejected the request'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetAccounts
            });
          case 14:
            throw new CosmosWalletException(new Error(_context8.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetAccounts
            });
          case 15:
          case "end":
            return _context8.stop();
        }
      }, _callee8, this, [[3, 10]]);
    }));
    function getPubKey() {
      return _getPubKey.apply(this, arguments);
    }
    return getPubKey;
  }();
  _proto.signEip712TypedData = /*#__PURE__*/function () {
    var _signEip712TypedData = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(_eip712TypedData, _address) {
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            throw new CosmosWalletException(new Error('This wallet does not support signing Ethereum transactions'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SendTransaction
            });
          case 1:
          case "end":
            return _context9.stop();
        }
      }, _callee9);
    }));
    function signEip712TypedData(_x10, _x11) {
      return _signEip712TypedData.apply(this, arguments);
    }
    return signEip712TypedData;
  }();
  _proto.getNetworkId = /*#__PURE__*/function () {
    var _getNetworkId = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            throw new CosmosWalletException(new Error('getNetworkId is not supported on Cosmostation'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetNetworkId
            });
          case 1:
          case "end":
            return _context10.stop();
        }
      }, _callee10);
    }));
    function getNetworkId() {
      return _getNetworkId.apply(this, arguments);
    }
    return getNetworkId;
  }();
  _proto.getChainId = /*#__PURE__*/function () {
    var _getChainId = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            throw new CosmosWalletException(new Error('getChainId is not supported on Cosmostation'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetChainId
            });
          case 1:
          case "end":
            return _context11.stop();
        }
      }, _callee11);
    }));
    function getChainId() {
      return _getChainId.apply(this, arguments);
    }
    return getChainId;
  }();
  _proto.getEthereumTransactionReceipt = /*#__PURE__*/function () {
    var _getEthereumTransactionReceipt = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(_txHash) {
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            throw new CosmosWalletException(new Error('getEthereumTransactionReceipt is not supported on Cosmostation'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetEthereumTransactionReceipt
            });
          case 1:
          case "end":
            return _context12.stop();
        }
      }, _callee12);
    }));
    function getEthereumTransactionReceipt(_x12) {
      return _getEthereumTransactionReceipt.apply(this, arguments);
    }
    return getEthereumTransactionReceipt;
  }();
  _proto.getProvider = /*#__PURE__*/function () {
    var _getProvider = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
      var provider;
      return _regeneratorRuntime().wrap(function _callee13$(_context13) {
        while (1) switch (_context13.prev = _context13.next) {
          case 0:
            if (!this.provider) {
              _context13.next = 2;
              break;
            }
            return _context13.abrupt("return", this.provider);
          case 2:
            _context13.prev = 2;
            _context13.next = 5;
            return cosmos();
          case 5:
            provider = _context13.sent;
            this.provider = provider;
            return _context13.abrupt("return", provider);
          case 10:
            _context13.prev = 10;
            _context13.t0 = _context13["catch"](2);
            if (!(_context13.t0 instanceof InstallError)) {
              _context13.next = 14;
              break;
            }
            throw new CosmosWalletException(new Error('Please install the Cosmostation extension'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletNotInstalledError
            });
          case 14:
            throw new CosmosWalletException(new Error(_context13.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError
            });
          case 15:
          case "end":
            return _context13.stop();
        }
      }, _callee13, this, [[2, 10]]);
    }));
    function getProvider() {
      return _getProvider.apply(this, arguments);
    }
    return getProvider;
  }();
  return Cosmostation;
}(BaseConcreteStrategy);

var LedgerDerivationPathType;
(function (LedgerDerivationPathType) {
  LedgerDerivationPathType["LedgerLive"] = "ledger-live";
  LedgerDerivationPathType["LedgerMew"] = "ledger-mew";
})(LedgerDerivationPathType || (LedgerDerivationPathType = {}));

var DEFAULT_BASE_DERIVATION_PATH = "m/44'/60'";
var DEFAULT_NUM_ADDRESSES_TO_FETCH = 5;
var DEFAULT_ADDRESS_SEARCH_LIMIT = 100;

var addressOfHDKey = function addressOfHDKey(hdKey) {
  var shouldSanitizePublicKey = true;
  var derivedPublicKey = hdKey.publicKey;
  var ethereumAddressWithoutPrefix = publicToAddress(derivedPublicKey, shouldSanitizePublicKey).toString('hex');
  var address = addHexPrefix(ethereumAddressWithoutPrefix);
  return address;
};
var AccountManager = /*#__PURE__*/function () {
  function AccountManager(ledger) {
    this.wallets = [];
    this.getLedgerDerivationPathBasedOnType = function (_ref) {
      var fullBaseDerivationPath = _ref.fullBaseDerivationPath,
        derivationPathType = _ref.derivationPathType,
        index = _ref.index;
      if (derivationPathType === LedgerDerivationPathType.LedgerLive) {
        return fullBaseDerivationPath + "/" + index + "'/0/0";
      }
      return fullBaseDerivationPath + "/0'/" + index;
    };
    this.ledger = ledger;
    this.wallets = [];
  }
  var _proto = AccountManager.prototype;
  _proto.getWallets = /*#__PURE__*/function () {
    var _getWallets = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(baseDerivationPath, derivationPathType) {
      var _this$getOffset, start, end;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _this$getOffset = this.getOffset(), start = _this$getOffset.start, end = _this$getOffset.end;
            /**
             * 1. Wallets are not yet fetched at all,
             * 2. Wallets are not yet fetched for that offset
             */
            if (!(!this.hasWallets() || !this.hasWalletsInOffset(start))) {
              _context.next = 4;
              break;
            }
            _context.next = 4;
            return this.getWalletsBasedOnIndex({
              start: start,
              end: end,
              baseDerivationPath: baseDerivationPath,
              derivationPathType: derivationPathType
            });
          case 4:
            return _context.abrupt("return", this.wallets.slice(start, end));
          case 5:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function getWallets(_x, _x2) {
      return _getWallets.apply(this, arguments);
    }
    return getWallets;
  }();
  _proto.getWalletsBasedOnIndex = /*#__PURE__*/function () {
    var _getWalletsBasedOnIndex = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref2) {
      var start, end, baseDerivationPath, derivationPathType, index, path, result, hdKey, address;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            start = _ref2.start, end = _ref2.end, baseDerivationPath = _ref2.baseDerivationPath, derivationPathType = _ref2.derivationPathType;
            index = start;
          case 2:
            if (!(index < end)) {
              _context2.next = 15;
              break;
            }
            path = this.getLedgerDerivationPathBasedOnType({
              fullBaseDerivationPath: baseDerivationPath,
              derivationPathType: derivationPathType,
              index: index
            });
            _context2.next = 6;
            return this.ledger.getAddress(path);
          case 6:
            result = _context2.sent;
            hdKey = new HDNode();
            hdKey.publicKey = Buffer.from(result.publicKey, 'hex');
            hdKey.chainCode = Buffer.from(result.chainCode || '', 'hex');
            address = result.address || addressOfHDKey(hdKey);
            this.wallets.push({
              hdKey: hdKey,
              baseDerivationPath: baseDerivationPath,
              address: address.toLowerCase(),
              derivationPath: path
            });
          case 12:
            index += 1;
            _context2.next = 2;
            break;
          case 15:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function getWalletsBasedOnIndex(_x3) {
      return _getWalletsBasedOnIndex.apply(this, arguments);
    }
    return getWalletsBasedOnIndex;
  }();
  _proto.hasWallets = function hasWallets() {
    return this.wallets.length > 0;
  };
  _proto.hasWalletsInOffset = function hasWalletsInOffset(offset) {
    return this.wallets.length > offset;
  };
  _proto.getOffset = function getOffset() {
    var totalWallets = this.wallets.length;
    var nextBatchStart = totalWallets;
    var nextBatchEnd = totalWallets + DEFAULT_NUM_ADDRESSES_TO_FETCH;
    return {
      start: nextBatchStart,
      end: nextBatchEnd
    };
  };
  _proto.hasWalletForAddress = function hasWalletForAddress(address) {
    return this.wallets.find(function (wallet) {
      return wallet.address.toLowerCase() === address.toLowerCase();
    }) !== undefined;
  };
  _proto.getWalletForAddress = /*#__PURE__*/function () {
    var _getWalletForAddress = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(address) {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", this.wallets.find(function (wallet) {
              return wallet.address.toLowerCase() === address.toLowerCase();
            }));
          case 1:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function getWalletForAddress(_x4) {
      return _getWalletForAddress.apply(this, arguments);
    }
    return getWalletForAddress;
  }();
  return AccountManager;
}();

var LedgerTransport = /*#__PURE__*/function () {
  function LedgerTransport() {
    this.ledger = null;
    this.accountManager = null;
  }
  LedgerTransport.getTransport = /*#__PURE__*/function () {
    var _getTransport = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var list, existing, _existing;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return TransportWebHID.isSupported();
          case 3:
            if (!_context.sent) {
              _context.next = 17;
              break;
            }
            _context.next = 6;
            return TransportWebHID.list();
          case 6:
            list = _context.sent;
            if (!(list.length > 0 && list[0].opened)) {
              _context.next = 9;
              break;
            }
            return _context.abrupt("return", new TransportWebHID(list[0]));
          case 9:
            _context.next = 11;
            return TransportWebHID.openConnected()["catch"](function () {
              return null;
            });
          case 11:
            existing = _context.sent;
            if (!existing) {
              _context.next = 14;
              break;
            }
            return _context.abrupt("return", existing);
          case 14:
            _context.next = 16;
            return TransportWebHID.request();
          case 16:
            return _context.abrupt("return", _context.sent);
          case 17:
            _context.next = 19;
            return TransportWebUSB.isSupported();
          case 19:
            if (!_context.sent) {
              _context.next = 28;
              break;
            }
            _context.next = 22;
            return TransportWebUSB.openConnected()["catch"](function () {
              return null;
            });
          case 22:
            _existing = _context.sent;
            if (!_existing) {
              _context.next = 25;
              break;
            }
            return _context.abrupt("return", _existing);
          case 25:
            _context.next = 27;
            return TransportWebUSB.request();
          case 27:
            return _context.abrupt("return", _context.sent);
          case 28:
            _context.next = 33;
            break;
          case 30:
            _context.prev = 30;
            _context.t0 = _context["catch"](0);
            throw new LedgerException(new Error(_context.t0.message));
          case 33:
            return _context.abrupt("return", TransportU2F.create());
          case 34:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[0, 30]]);
    }));
    function getTransport() {
      return _getTransport.apply(this, arguments);
    }
    return getTransport;
  }();
  var _proto = LedgerTransport.prototype;
  _proto.getInstance = /*#__PURE__*/function () {
    var _getInstance = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var _this = this;
      var transport;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            if (this.ledger) {
              _context2.next = 6;
              break;
            }
            _context2.next = 3;
            return LedgerTransport.getTransport();
          case 3:
            transport = _context2.sent;
            //@ts-ignore
            this.ledger = new EthereumApp(transport);
            transport.on('disconnect', function () {
              _this.ledger = null;
              _this.accountManager = null;
            });
          case 6:
            return _context2.abrupt("return", this.ledger);
          case 7:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function getInstance() {
      return _getInstance.apply(this, arguments);
    }
    return getInstance;
  }();
  _proto.getAccountManager = /*#__PURE__*/function () {
    var _getAccountManager = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            if (this.accountManager) {
              _context3.next = 6;
              break;
            }
            _context3.t0 = AccountManager;
            _context3.next = 4;
            return this.getInstance();
          case 4:
            _context3.t1 = _context3.sent;
            this.accountManager = new _context3.t0(_context3.t1);
          case 6:
            return _context3.abrupt("return", this.accountManager);
          case 7:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function getAccountManager() {
      return _getAccountManager.apply(this, arguments);
    }
    return getAccountManager;
  }();
  return LedgerTransport;
}();

var domainHash = function domainHash(message) {
  return TypedDataUtils$1.hashStruct('EIP712Domain', message.domain, message.types, true);
};
var messageHash = function messageHash(message) {
  return TypedDataUtils$1.hashStruct(message.primaryType, message.message, message.types, true);
};

var getNetworkFromChainId = function getNetworkFromChainId(chainId) {
  if (chainId === EthereumChainId.Goerli) {
    return Chain.Goerli;
  }
  if (chainId === EthereumChainId.Kovan) {
    return Chain.Kovan;
  }
  return Chain.Mainnet;
};
var LedgerBase = /*#__PURE__*/function (_BaseConcreteStrategy) {
  _inheritsLoose(LedgerBase, _BaseConcreteStrategy);
  function LedgerBase(args) {
    var _this;
    _this = _BaseConcreteStrategy.call(this, args) || this;
    _this.baseDerivationPath = DEFAULT_BASE_DERIVATION_PATH;
    _this.derivationPathType = args.derivationPathType;
    _this.ledger = new LedgerTransport();
    return _this;
  }
  var _proto = LedgerBase.prototype;
  _proto.simulateTransaction = function simulateTransaction(_signedTx, _nodeUrl) {
    throw new Error('Method not implemented.');
  };
  _proto.broadcastTransaction = function broadcastTransaction(_signedTx, _nodeUrl) {
    throw new Error('Method not implemented.');
  };
  _proto.simulateSignAndBroadcast = function simulateSignAndBroadcast(_args) {
    throw new Error('Method not implemented.');
  };
  _proto.onAccountChange = function onAccountChange(_callback) {
    throw new Error('Method not implemented.');
  };
  _proto.onChainIdChange = function onChainIdChange(_callback) {
    throw new Error('Method not implemented.');
  };
  _proto.cancelOnChainIdChange = function cancelOnChainIdChange() {
    throw new Error('Method not implemented.');
  };
  _proto.cancelOnAccountChange = function cancelOnAccountChange() {
    throw new Error('Method not implemented.');
  };
  _proto.cancelAllEvents = function cancelAllEvents() {
    throw new Error('Method not implemented.');
  };
  _proto.disconnect = function disconnect() {
    throw new Error('Method not implemented.');
  };
  _proto.getWalletDeviceType = /*#__PURE__*/function () {
    var _getWalletDeviceType = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", Promise.resolve(WalletDeviceType.Hardware));
          case 1:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    function getWalletDeviceType() {
      return _getWalletDeviceType.apply(this, arguments);
    }
    return getWalletDeviceType;
  }();
  _proto.getAddresses = /*#__PURE__*/function () {
    var _getAddresses = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var baseDerivationPath, derivationPathType, accountManager, wallets;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            baseDerivationPath = this.baseDerivationPath, derivationPathType = this.derivationPathType;
            _context2.prev = 1;
            _context2.next = 4;
            return this.ledger.getAccountManager();
          case 4:
            accountManager = _context2.sent;
            _context2.next = 7;
            return accountManager.getWallets(baseDerivationPath, derivationPathType);
          case 7:
            wallets = _context2.sent;
            return _context2.abrupt("return", wallets.map(function (k) {
              return k.address;
            }));
          case 11:
            _context2.prev = 11;
            _context2.t0 = _context2["catch"](1);
            throw new LedgerException(new Error(_context2.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetAccounts
            });
          case 14:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[1, 11]]);
    }));
    function getAddresses() {
      return _getAddresses.apply(this, arguments);
    }
    return getAddresses;
  }();
  _proto.confirm = /*#__PURE__*/function () {
    var _confirm = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(address) {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", Promise.resolve("0x" + Buffer.from("Confirmation for " + address + " at time: " + Date.now()).toString('hex')));
          case 1:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    function confirm(_x) {
      return _confirm.apply(this, arguments);
    }
    return confirm;
  }();
  _proto.sendEthereumTransaction = /*#__PURE__*/function () {
    var _sendEthereumTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(txData, options) {
      var signedTransaction, txReceipt;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return this.signEthereumTransaction(txData, options);
          case 2:
            signedTransaction = _context4.sent;
            _context4.prev = 3;
            _context4.next = 6;
            return this.getWeb3().eth.sendSignedTransaction(addHexPrefix(signedTransaction.serialize().toString('hex')));
          case 6:
            txReceipt = _context4.sent;
            return _context4.abrupt("return", txReceipt.transactionHash);
          case 10:
            _context4.prev = 10;
            _context4.t0 = _context4["catch"](3);
            throw new LedgerException(new Error(_context4.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SendEthereumTransaction
            });
          case 13:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this, [[3, 10]]);
    }));
    function sendEthereumTransaction(_x2, _x3) {
      return _sendEthereumTransaction.apply(this, arguments);
    }
    return sendEthereumTransaction;
  }() // eslint-disable-next-line class-methods-use-this
  ;
  _proto.sendTransaction =
  /*#__PURE__*/
  function () {
    var _sendTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(_transaction, _options) {
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            throw new LedgerException(new Error('sendTransaction is not supported. Ledger only supports sending transaction to Ethereum'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SendTransaction
            });
          case 1:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }));
    function sendTransaction(_x4, _x5) {
      return _sendTransaction.apply(this, arguments);
    }
    return sendTransaction;
  }() /** @deprecated */;
  _proto.signTransaction =
  /*#__PURE__*/
  function () {
    var _signTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(eip712json, address) {
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            return _context6.abrupt("return", this.signEip712TypedData(eip712json, address));
          case 1:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this);
    }));
    function signTransaction(_x6, _x7) {
      return _signTransaction.apply(this, arguments);
    }
    return signTransaction;
  }();
  _proto.signEip712TypedData = /*#__PURE__*/function () {
    var _signEip712TypedData = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(eip712json, address) {
      var _yield$this$getWallet, derivationPath, object, ledger, result, combined;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return this.getWalletForAddress(address);
          case 2:
            _yield$this$getWallet = _context7.sent;
            derivationPath = _yield$this$getWallet.derivationPath;
            object = JSON.parse(eip712json);
            _context7.prev = 5;
            _context7.next = 8;
            return this.ledger.getInstance();
          case 8:
            ledger = _context7.sent;
            _context7.next = 11;
            return ledger.signEIP712HashedMessage(derivationPath, bufferToHex(domainHash(object)), bufferToHex(messageHash(object)));
          case 11:
            result = _context7.sent;
            combined = "" + result.r + result.s + result.v.toString(16);
            return _context7.abrupt("return", combined.startsWith('0x') ? combined : "0x" + combined);
          case 16:
            _context7.prev = 16;
            _context7.t0 = _context7["catch"](5);
            throw new LedgerException(new Error(_context7.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SignTransaction
            });
          case 19:
          case "end":
            return _context7.stop();
        }
      }, _callee7, this, [[5, 16]]);
    }));
    function signEip712TypedData(_x8, _x9) {
      return _signEip712TypedData.apply(this, arguments);
    }
    return signEip712TypedData;
  }() // eslint-disable-next-line class-methods-use-this
  ;
  _proto.signCosmosTransaction =
  /*#__PURE__*/
  function () {
    var _signCosmosTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(_transaction, _address) {
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            throw new WalletException(new Error('This wallet does not support signing Cosmos transactions'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SendTransaction
            });
          case 1:
          case "end":
            return _context8.stop();
        }
      }, _callee8);
    }));
    function signCosmosTransaction(_x10, _x11) {
      return _signCosmosTransaction.apply(this, arguments);
    }
    return signCosmosTransaction;
  }();
  _proto.getNetworkId = /*#__PURE__*/function () {
    var _getNetworkId = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            _context9.next = 2;
            return this.getWeb3().eth.net.getId();
          case 2:
            return _context9.abrupt("return", _context9.sent.toString());
          case 3:
          case "end":
            return _context9.stop();
        }
      }, _callee9, this);
    }));
    function getNetworkId() {
      return _getNetworkId.apply(this, arguments);
    }
    return getNetworkId;
  }();
  _proto.getChainId = /*#__PURE__*/function () {
    var _getChainId = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            _context10.next = 2;
            return this.getWeb3().eth.getChainId();
          case 2:
            return _context10.abrupt("return", _context10.sent.toString());
          case 3:
          case "end":
            return _context10.stop();
        }
      }, _callee10, this);
    }));
    function getChainId() {
      return _getChainId.apply(this, arguments);
    }
    return getChainId;
  }();
  _proto.getEthereumTransactionReceipt = /*#__PURE__*/function () {
    var _getEthereumTransactionReceipt = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(txHash) {
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            return _context11.abrupt("return", Promise.resolve(txHash));
          case 1:
          case "end":
            return _context11.stop();
        }
      }, _callee11);
    }));
    function getEthereumTransactionReceipt(_x12) {
      return _getEthereumTransactionReceipt.apply(this, arguments);
    }
    return getEthereumTransactionReceipt;
  }() // eslint-disable-next-line class-methods-use-this
  ;
  _proto.getPubKey =
  /*#__PURE__*/
  function () {
    var _getPubKey = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            throw new WalletException(new Error('You can only fetch PubKey from Cosmos native wallets'));
          case 1:
          case "end":
            return _context12.stop();
        }
      }, _callee12);
    }));
    function getPubKey() {
      return _getPubKey.apply(this, arguments);
    }
    return getPubKey;
  }();
  _proto.signEthereumTransaction = /*#__PURE__*/function () {
    var _signEthereumTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(txData, options) {
      var chainId, nonce, common, eip1559TxData, tx, msg, encodedMessageHex, ledger, _yield$this$getWallet2, derivationPath, resolution, txSig, signedTxData;
      return _regeneratorRuntime().wrap(function _callee13$(_context13) {
        while (1) switch (_context13.prev = _context13.next) {
          case 0:
            chainId = parseInt(options.ethereumChainId.toString(), 10);
            _context13.next = 3;
            return this.getWeb3().eth.getTransactionCount(options.address);
          case 3:
            nonce = _context13.sent;
            common = new Common({
              chain: getNetworkFromChainId(chainId),
              hardfork: Hardfork.London
            });
            eip1559TxData = {
              from: txData.from,
              data: txData.data,
              to: txData.to,
              nonce: addHexPrefix(nonce.toString(16)),
              gas: addHexPrefix(txData.gas),
              gasLimit: addHexPrefix(txData.gas),
              maxFeePerGas: addHexPrefix(txData.gasPrice || txData.maxFeePerGas),
              maxPriorityFeePerGas: addHexPrefix(txData.maxPriorityFeePerGas || '0x77359400' /* 2 Gwei in HEX */)
            };
            tx = FeeMarketEIP1559Transaction.fromTxData(eip1559TxData, {
              common: common
            });
            msg = tx.getMessageToSign(false); // const encodedMessage = msg
            encodedMessageHex = msg.toString('hex');
            _context13.prev = 9;
            _context13.next = 12;
            return this.ledger.getInstance();
          case 12:
            ledger = _context13.sent;
            _context13.next = 15;
            return this.getWalletForAddress(options.address);
          case 15:
            _yield$this$getWallet2 = _context13.sent;
            derivationPath = _yield$this$getWallet2.derivationPath;
            _context13.next = 19;
            return ledgerService.resolveTransaction(encodedMessageHex, {}, {});
          case 19:
            resolution = _context13.sent;
            _context13.next = 22;
            return ledger.signTransaction(derivationPath, encodedMessageHex, resolution);
          case 22:
            txSig = _context13.sent;
            signedTxData = _extends({}, eip1559TxData, {
              v: "0x" + txSig.v,
              r: "0x" + txSig.r,
              s: "0x" + txSig.s
            });
            return _context13.abrupt("return", FeeMarketEIP1559Transaction.fromTxData(signedTxData, {
              common: common
            }));
          case 27:
            _context13.prev = 27;
            _context13.t0 = _context13["catch"](9);
            throw new LedgerException(new Error(_context13.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SignEthereumTransaction
            });
          case 30:
          case "end":
            return _context13.stop();
        }
      }, _callee13, this, [[9, 27]]);
    }));
    function signEthereumTransaction(_x13, _x14) {
      return _signEthereumTransaction.apply(this, arguments);
    }
    return signEthereumTransaction;
  }();
  _proto.getWalletForAddress = /*#__PURE__*/function () {
    var _getWalletForAddress = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(address) {
      var baseDerivationPath, derivationPathType, accountManager, i;
      return _regeneratorRuntime().wrap(function _callee14$(_context14) {
        while (1) switch (_context14.prev = _context14.next) {
          case 0:
            baseDerivationPath = this.baseDerivationPath, derivationPathType = this.derivationPathType;
            _context14.next = 3;
            return this.ledger.getAccountManager();
          case 3:
            accountManager = _context14.sent;
            if (accountManager.hasWalletForAddress(address)) {
              _context14.next = 16;
              break;
            }
            i = 0;
          case 6:
            if (!(i < DEFAULT_ADDRESS_SEARCH_LIMIT / DEFAULT_NUM_ADDRESSES_TO_FETCH)) {
              _context14.next = 16;
              break;
            }
            _context14.next = 9;
            return accountManager.getWallets(baseDerivationPath, derivationPathType);
          case 9:
            if (!accountManager.hasWalletForAddress(address)) {
              _context14.next = 13;
              break;
            }
            _context14.next = 12;
            return accountManager.getWalletForAddress(address);
          case 12:
            return _context14.abrupt("return", _context14.sent);
          case 13:
            i += 1;
            _context14.next = 6;
            break;
          case 16:
            _context14.next = 18;
            return accountManager.getWalletForAddress(address);
          case 18:
            return _context14.abrupt("return", _context14.sent);
          case 19:
          case "end":
            return _context14.stop();
        }
      }, _callee14, this);
    }));
    function getWalletForAddress(_x15) {
      return _getWalletForAddress.apply(this, arguments);
    }
    return getWalletForAddress;
  }();
  return LedgerBase;
}(BaseConcreteStrategy);

var LedgerLive = /*#__PURE__*/function (_LedgerBase) {
  _inheritsLoose(LedgerLive, _LedgerBase);
  function LedgerLive(args) {
    return _LedgerBase.call(this, _extends({}, args, {
      derivationPathType: LedgerDerivationPathType.LedgerLive
    })) || this;
  }
  return LedgerLive;
}(LedgerBase);

var LedgerLegacy = /*#__PURE__*/function (_LedgerBase) {
  _inheritsLoose(LedgerLegacy, _LedgerBase);
  function LedgerLegacy(args) {
    return _LedgerBase.call(this, _extends({}, args, {
      derivationPathType: LedgerDerivationPathType.LedgerMew
    })) || this;
  }
  return LedgerLegacy;
}(LedgerBase);

var WalletConnect = /*#__PURE__*/function (_BaseConcreteStrategy) {
  _inheritsLoose(WalletConnect, _BaseConcreteStrategy);
  function WalletConnect(args) {
    var _this;
    _this = _BaseConcreteStrategy.call(this, args) || this;
    _this.ethereumOptions = args.ethereumOptions;
    _this.createWalletConnectProvider();
    return _this;
  }
  var _proto = WalletConnect.prototype;
  _proto.createWalletConnectProvider = function createWalletConnectProvider() {
    var _rpc;
    var ethereumOptions = this.ethereumOptions;
    if (!ethereumOptions) {
      throw new WalletException(new Error('Please provide Ethereum options'));
    }
    this.walletConnectProvider = new WalletConnectProvider({
      rpc: (_rpc = {}, _rpc[ethereumOptions.ethereumChainId] = ethereumOptions.rpcUrl, _rpc)
    });
    this.web3 = new Web3(this.walletConnectProvider);
  };
  _proto.simulateTransaction = function simulateTransaction(signedTx, nodeUrl) {
    return simulateRawTx(signedTx, nodeUrl);
  };
  _proto.broadcastTransaction = function broadcastTransaction(signedTx, nodeUrl) {
    return broadcastRawTx(signedTx, nodeUrl);
  };
  _proto.simulateSignAndBroadcast = /*#__PURE__*/function () {
    var _simulateSignAndBroadcast = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
      var _this$walletConnectPr, _this$walletConnectPr2, _accountDetails$pubKe, _accountDetails$pubKe2, _this$walletConnectPr3, _eipData$fee$feePayer, _eipData$fee, _this$walletConnectPr4, _this$walletConnectPr5;
      var ethChainId, cosmosChainId, txMsg, nodeUrl, memo, parsedEthChainId, userAccountInfo, baseAccount, accountDetails, context, eipData, simulatedTxPayload, simulatedTx, simulationResponse, simulatedFee, txPayload, signature, signatureBytes, publicKeyHex, publicKey, txPayloadWithPubKey, signDirect, bodyBytes, authInfoBytes, txRawToSend, broadcastResponse;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            ethChainId = _ref.ethChainId, cosmosChainId = _ref.cosmosChainId, txMsg = _ref.txMsg, nodeUrl = _ref.nodeUrl, memo = _ref.memo;
            //Account Info
            parsedEthChainId = ethChainId.startsWith('0x') ? parseInt(ethChainId, 16) : parseInt(ethChainId);
            _context.next = 4;
            return new ChainRestAuthApi(nodeUrl).fetchAccount(getRouterSignerAddress((_this$walletConnectPr = this.walletConnectProvider) == null ? void 0 : _this$walletConnectPr.selectedAddress));
          case 4:
            userAccountInfo = _context.sent;
            baseAccount = BaseAccount.fromRestApi(userAccountInfo);
            accountDetails = baseAccount.toAccountDetails();
            context = {
              chain: {
                chainId: parsedEthChainId,
                cosmosChainId: cosmosChainId
              },
              sender: {
                accountAddress: getRouterSignerAddress((_this$walletConnectPr2 = this.walletConnectProvider) == null ? void 0 : _this$walletConnectPr2.selectedAddress),
                sequence: accountDetails.sequence,
                accountNumber: accountDetails.accountNumber,
                pubkey: (_accountDetails$pubKe = (_accountDetails$pubKe2 = accountDetails.pubKey) == null ? void 0 : _accountDetails$pubKe2.key) != null ? _accountDetails$pubKe : ''
              },
              memo: memo != null ? memo : ''
            }; //EIP DATA
            eipData = {
              msgs: [txMsg],
              tx: {
                accountNumber: accountDetails.accountNumber.toString(),
                sequence: accountDetails.sequence.toString(),
                chainId: cosmosChainId
              },
              ethereumChainId: parsedEthChainId,
              fee: {
                feePayer: getRouterSignerAddress((_this$walletConnectPr3 = this.walletConnectProvider) == null ? void 0 : _this$walletConnectPr3.selectedAddress)
              }
            }; // Simulationx
            simulatedTxPayload = getEtherMintTxPayload(context, eipData);
            simulatedTx = createTxRawForBroadcast(simulatedTxPayload.signDirect.body.toBinary(), simulatedTxPayload.signDirect.authInfo.toBinary(), [new Uint8Array(2)]);
            _context.next = 13;
            return this.simulateTransaction(simulatedTx, nodeUrl);
          case 13:
            simulationResponse = _context.sent;
            simulatedFee = {
              amount: [{
                amount: new BigNumberInBase(ROUTER_DEFAULT_GAS_PRICE).times(parseInt((parseInt(simulationResponse.gas_info.gas_used) * GAS_LIMIT_MULTIPLIER).toString())).toString(),
                denom: ROUTER_DENOM
              }],
              gas: parseInt((parseInt(simulationResponse.gas_info.gas_used) * GAS_LIMIT_MULTIPLIER).toString()).toString(),
              feePayer: (_eipData$fee$feePayer = (_eipData$fee = eipData.fee) == null ? void 0 : _eipData$fee.feePayer) != null ? _eipData$fee$feePayer : getRouterSignerAddress((_this$walletConnectPr4 = this.walletConnectProvider) == null ? void 0 : _this$walletConnectPr4.selectedAddress)
            };
            eipData.fee = simulatedFee;
            txPayload = getEtherMintTxPayload(context, eipData);
            _context.next = 19;
            return this.signEip712TypedData(JSON.stringify(txPayload.eipToSign), (_this$walletConnectPr5 = this.walletConnectProvider) == null ? void 0 : _this$walletConnectPr5.selectedAddress);
          case 19:
            signature = _context.sent;
            signatureBytes = hexToBuff(signature);
            publicKeyHex = recoverTypedSignaturePubKey(txPayload.eipToSign, signature);
            publicKey = hexToBase64(publicKeyHex);
            context.sender.pubkey = publicKey;
            txPayloadWithPubKey = getEtherMintTxPayload(context, eipData);
            signDirect = txPayloadWithPubKey.signDirect;
            bodyBytes = signDirect.body.toBinary();
            authInfoBytes = signDirect.authInfo.toBinary();
            txRawToSend = createTxRawForBroadcast(bodyBytes, authInfoBytes, [signatureBytes]);
            _context.next = 31;
            return this.broadcastTransaction(txRawToSend, nodeUrl);
          case 31:
            broadcastResponse = _context.sent;
            return _context.abrupt("return", broadcastResponse);
          case 33:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function simulateSignAndBroadcast(_x) {
      return _simulateSignAndBroadcast.apply(this, arguments);
    }
    return simulateSignAndBroadcast;
  }();
  _proto.onChainIdChange = function onChainIdChange(_callback) {
    throw new Error('Method not implemented.');
  };
  _proto.cancelOnChainIdChange = function cancelOnChainIdChange() {
    throw new Error('Method not implemented.');
  };
  _proto.cancelOnAccountChange = function cancelOnAccountChange() {
    throw new Error('Method not implemented.');
  };
  _proto.cancelAllEvents = function cancelAllEvents() {
    throw new Error('Method not implemented.');
  };
  _proto.getWalletDeviceType = /*#__PURE__*/function () {
    var _getWalletDeviceType = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.abrupt("return", Promise.resolve(WalletDeviceType.Browser));
          case 1:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    function getWalletDeviceType() {
      return _getWalletDeviceType.apply(this, arguments);
    }
    return getWalletDeviceType;
  }();
  _proto.connect = /*#__PURE__*/function () {
    var _connect = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      var _this$walletConnectPr6;
      var _this$walletConnectPr7;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            if ((_this$walletConnectPr6 = this.walletConnectProvider) != null && _this$walletConnectPr6.connected) {
              _context3.next = 4;
              break;
            }
            // WalletConnect seems to have a problem with connecting multiple times with the same instance, hence it's necessary
            // to create a new one each time user wants to connect
            this.createWalletConnectProvider();
            _context3.next = 4;
            return (_this$walletConnectPr7 = this.walletConnectProvider) == null ? void 0 : _this$walletConnectPr7.enable();
          case 4:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function connect() {
      return _connect.apply(this, arguments);
    }
    return connect;
  }();
  _proto.disconnect = /*#__PURE__*/function () {
    var _disconnect = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
      var _this$walletConnectPr8;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return (_this$walletConnectPr8 = this.walletConnectProvider) == null ? void 0 : _this$walletConnectPr8.disconnect();
          case 2:
            // walletConnect will not display QRModal again with the same instance for some reason, so it's necessary to destroy the instance
            this.createWalletConnectProvider();
          case 3:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this);
    }));
    function disconnect() {
      return _disconnect.apply(this, arguments);
    }
    return disconnect;
  }();
  _proto.getAddresses = /*#__PURE__*/function () {
    var _getAddresses = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return this.connect();
          case 2:
            _context5.prev = 2;
            _context5.next = 5;
            return this.getWeb3().eth.getAccounts();
          case 5:
            return _context5.abrupt("return", _context5.sent);
          case 8:
            _context5.prev = 8;
            _context5.t0 = _context5["catch"](2);
            throw new MetamaskException(new Error(_context5.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetAccounts
            });
          case 11:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this, [[2, 8]]);
    }));
    function getAddresses() {
      return _getAddresses.apply(this, arguments);
    }
    return getAddresses;
  }();
  _proto.confirm = /*#__PURE__*/function () {
    var _confirm = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(address) {
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return this.connect();
          case 2:
            return _context6.abrupt("return", Promise.resolve("0x" + Buffer.from("Confirmation for " + address + " at time: " + Date.now()).toString('hex')));
          case 3:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this);
    }));
    function confirm(_x2) {
      return _confirm.apply(this, arguments);
    }
    return confirm;
  }() /** @deprecated */;
  _proto.signTransaction =
  /*#__PURE__*/
  function () {
    var _signTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(eip712json, address) {
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            return _context7.abrupt("return", this.signEip712TypedData(eip712json, address));
          case 1:
          case "end":
            return _context7.stop();
        }
      }, _callee7, this);
    }));
    function signTransaction(_x3, _x4) {
      return _signTransaction.apply(this, arguments);
    }
    return signTransaction;
  }();
  _proto.signEip712TypedData = /*#__PURE__*/function () {
    var _signEip712TypedData = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(eip712json, address) {
      var _this$walletConnectPr9;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            _context8.next = 2;
            return this.connect();
          case 2:
            _context8.prev = 2;
            _context8.next = 5;
            return (_this$walletConnectPr9 = this.walletConnectProvider) == null ? void 0 : _this$walletConnectPr9.request({
              method: 'eth_signTypedData',
              params: [address, eip712json]
            });
          case 5:
            return _context8.abrupt("return", _context8.sent);
          case 8:
            _context8.prev = 8;
            _context8.t0 = _context8["catch"](2);
            throw new MetamaskException(new Error(_context8.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SignTransaction
            });
          case 11:
          case "end":
            return _context8.stop();
        }
      }, _callee8, this, [[2, 8]]);
    }));
    function signEip712TypedData(_x5, _x6) {
      return _signEip712TypedData.apply(this, arguments);
    }
    return signEip712TypedData;
  }();
  _proto.sendEthereumTransaction = /*#__PURE__*/function () {
    var _sendEthereumTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(transaction, _options) {
      var transactionConfig, txHash;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            _context9.next = 2;
            return this.connect();
          case 2:
            transactionConfig = transaction;
            transactionConfig.gas = parseInt(transactionConfig.gas, 16).toString(10);
            transactionConfig.maxFeePerGas = parseInt(transactionConfig.maxFeePerGas, 16).toString(10);
            // walletConnect doesn't seem to support hex format, so it's necessay to convert to decimal
            _context9.prev = 5;
            _context9.next = 8;
            return this.getWeb3().eth.sendTransaction(transactionConfig);
          case 8:
            txHash = _context9.sent;
            return _context9.abrupt("return", txHash.transactionHash);
          case 12:
            _context9.prev = 12;
            _context9.t0 = _context9["catch"](5);
            throw new MetamaskException(new Error(_context9.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SendEthereumTransaction
            });
          case 15:
          case "end":
            return _context9.stop();
        }
      }, _callee9, this, [[5, 12]]);
    }));
    function sendEthereumTransaction(_x7, _x8) {
      return _sendEthereumTransaction.apply(this, arguments);
    }
    return sendEthereumTransaction;
  }() // eslint-disable-next-line class-methods-use-this
  ;
  _proto.sendTransaction =
  /*#__PURE__*/
  function () {
    var _sendTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(_transaction, _options) {
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            throw new MetamaskException(new Error('sendTransaction is not supported. WalletConnect only supports sending transaction to Ethereum'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SendTransaction
            });
          case 1:
          case "end":
            return _context10.stop();
        }
      }, _callee10);
    }));
    function sendTransaction(_x9, _x10) {
      return _sendTransaction.apply(this, arguments);
    }
    return sendTransaction;
  }() // eslint-disable-next-line class-methods-use-this
  ;
  _proto.signCosmosTransaction =
  /*#__PURE__*/
  function () {
    var _signCosmosTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(_transaction, _address) {
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            throw new WalletException(new Error('This wallet does not support signing Cosmos transactions'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SendTransaction
            });
          case 1:
          case "end":
            return _context11.stop();
        }
      }, _callee11);
    }));
    function signCosmosTransaction(_x11, _x12) {
      return _signCosmosTransaction.apply(this, arguments);
    }
    return signCosmosTransaction;
  }();
  _proto.getEthereumTransactionReceipt = /*#__PURE__*/function () {
    var _getEthereumTransactionReceipt = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(txHash) {
      var _this2 = this;
      var interval, transactionReceiptRetry;
      return _regeneratorRuntime().wrap(function _callee13$(_context13) {
        while (1) switch (_context13.prev = _context13.next) {
          case 0:
            _context13.next = 2;
            return this.connect();
          case 2:
            interval = 1000;
            transactionReceiptRetry = /*#__PURE__*/function () {
              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
                var receipt;
                return _regeneratorRuntime().wrap(function _callee12$(_context12) {
                  while (1) switch (_context12.prev = _context12.next) {
                    case 0:
                      _context12.next = 2;
                      return _this2.walletConnectProvider.request({
                        method: 'eth_getTransactionReceipt',
                        params: [txHash]
                      });
                    case 2:
                      receipt = _context12.sent;
                      if (receipt) {
                        _context12.next = 8;
                        break;
                      }
                      _context12.next = 6;
                      return sleep(interval);
                    case 6:
                      _context12.next = 8;
                      return transactionReceiptRetry();
                    case 8:
                      return _context12.abrupt("return", receipt);
                    case 9:
                    case "end":
                      return _context12.stop();
                  }
                }, _callee12);
              }));
              return function transactionReceiptRetry() {
                return _ref2.apply(this, arguments);
              };
            }();
            _context13.prev = 4;
            _context13.next = 7;
            return transactionReceiptRetry();
          case 7:
            return _context13.abrupt("return", _context13.sent);
          case 10:
            _context13.prev = 10;
            _context13.t0 = _context13["catch"](4);
            throw new MetamaskException(new Error(_context13.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetEthereumTransactionReceipt
            });
          case 13:
          case "end":
            return _context13.stop();
        }
      }, _callee13, this, [[4, 10]]);
    }));
    function getEthereumTransactionReceipt(_x13) {
      return _getEthereumTransactionReceipt.apply(this, arguments);
    }
    return getEthereumTransactionReceipt;
  }();
  _proto.getNetworkId = /*#__PURE__*/function () {
    var _getNetworkId = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
      var result;
      return _regeneratorRuntime().wrap(function _callee14$(_context14) {
        while (1) switch (_context14.prev = _context14.next) {
          case 0:
            _context14.next = 2;
            return this.connect();
          case 2:
            _context14.prev = 2;
            _context14.next = 5;
            return this.getWeb3().eth.net.getId();
          case 5:
            result = _context14.sent;
            return _context14.abrupt("return", result.toString());
          case 9:
            _context14.prev = 9;
            _context14.t0 = _context14["catch"](2);
            throw new MetamaskException(new Error(_context14.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetNetworkId
            });
          case 12:
          case "end":
            return _context14.stop();
        }
      }, _callee14, this, [[2, 9]]);
    }));
    function getNetworkId() {
      return _getNetworkId.apply(this, arguments);
    }
    return getNetworkId;
  }();
  _proto.getChainId = /*#__PURE__*/function () {
    var _getChainId = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
      var result;
      return _regeneratorRuntime().wrap(function _callee15$(_context15) {
        while (1) switch (_context15.prev = _context15.next) {
          case 0:
            _context15.next = 2;
            return this.connect();
          case 2:
            _context15.prev = 2;
            _context15.next = 5;
            return this.getWeb3().eth.getChainId();
          case 5:
            result = _context15.sent;
            return _context15.abrupt("return", result.toString());
          case 9:
            _context15.prev = 9;
            _context15.t0 = _context15["catch"](2);
            throw new MetamaskException(new Error(_context15.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetChainId
            });
          case 12:
          case "end":
            return _context15.stop();
        }
      }, _callee15, this, [[2, 9]]);
    }));
    function getChainId() {
      return _getChainId.apply(this, arguments);
    }
    return getChainId;
  }() // eslint-disable-next-line class-methods-use-this
  ;
  _proto.getPubKey =
  /*#__PURE__*/
  function () {
    var _getPubKey = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
      return _regeneratorRuntime().wrap(function _callee16$(_context16) {
        while (1) switch (_context16.prev = _context16.next) {
          case 0:
            throw new WalletException(new Error('You can only fetch PubKey from Cosmos native wallets'));
          case 1:
          case "end":
            return _context16.stop();
        }
      }, _callee16);
    }));
    function getPubKey() {
      return _getPubKey.apply(this, arguments);
    }
    return getPubKey;
  }();
  _proto.onAccountChange = function onAccountChange(callback) {
    var _this$walletConnectPr10;
    (_this$walletConnectPr10 = this.walletConnectProvider) == null ? void 0 : _this$walletConnectPr10.on('accountsChanged', callback);
  };
  return WalletConnect;
}(BaseConcreteStrategy);

var CosmostationEth = /*#__PURE__*/function (_BaseConcreteStrategy) {
  _inheritsLoose(CosmostationEth, _BaseConcreteStrategy);
  function CosmostationEth(args) {
    var _this;
    _this = _BaseConcreteStrategy.call(this, args) || this;
    _this.chainId = args.chainId || CosmosChainId.Router;
    return _this;
  }
  var _proto = CosmostationEth.prototype;
  _proto.simulateTransaction = function simulateTransaction(_signedTx, _nodeUrl) {
    throw new Error('Method not implemented.');
  };
  _proto.broadcastTransaction = function broadcastTransaction(_signedTx, _nodeUrl) {
    throw new Error('Method not implemented.');
  };
  _proto.simulateSignAndBroadcast = function simulateSignAndBroadcast(_args) {
    throw new Error('Method not implemented.');
  };
  _proto.onAccountChange = function onAccountChange(_callback) {
    throw new Error('Method not implemented.');
  };
  _proto.onChainIdChange = function onChainIdChange(_callback) {
    throw new Error('Method not implemented.');
  };
  _proto.cancelOnChainIdChange = function cancelOnChainIdChange() {
    throw new Error('Method not implemented.');
  };
  _proto.cancelOnAccountChange = function cancelOnAccountChange() {
    throw new Error('Method not implemented.');
  };
  _proto.cancelAllEvents = function cancelAllEvents() {
    throw new Error('Method not implemented.');
  };
  _proto.disconnect = function disconnect() {
    throw new Error('Method not implemented.');
  };
  _proto.getWalletDeviceType = /*#__PURE__*/function () {
    var _getWalletDeviceType = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", Promise.resolve(WalletDeviceType.Browser));
          case 1:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    function getWalletDeviceType() {
      return _getWalletDeviceType.apply(this, arguments);
    }
    return getWalletDeviceType;
  }();
  _proto.getAddresses = /*#__PURE__*/function () {
    var _getAddresses = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var ethereum;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return this.getEthereum();
          case 2:
            ethereum = _context2.sent;
            _context2.prev = 3;
            _context2.next = 6;
            return ethereum.request({
              method: 'eth_requestAccounts'
            });
          case 6:
            return _context2.abrupt("return", _context2.sent);
          case 9:
            _context2.prev = 9;
            _context2.t0 = _context2["catch"](3);
            if (!(_context2.t0.code === 4001)) {
              _context2.next = 13;
              break;
            }
            throw new WalletException(new Error('The user rejected the request'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetAccounts
            });
          case 13:
            throw new WalletException(new Error(_context2.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetAccounts
            });
          case 14:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[3, 9]]);
    }));
    function getAddresses() {
      return _getAddresses.apply(this, arguments);
    }
    return getAddresses;
  }();
  _proto.confirm = /*#__PURE__*/function () {
    var _confirm = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(address) {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", Promise.resolve("0x" + Buffer.from("Confirmation for " + address + " at time: " + Date.now()).toString('hex')));
          case 1:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    function confirm(_x) {
      return _confirm.apply(this, arguments);
    }
    return confirm;
  }();
  _proto.sendEthereumTransaction = /*#__PURE__*/function () {
    var _sendEthereumTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(transaction, _options) {
      var ethereum;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return this.getEthereum();
          case 2:
            ethereum = _context4.sent;
            _context4.prev = 3;
            _context4.next = 6;
            return ethereum.request({
              method: 'eth_sendTransaction',
              params: [transaction]
            });
          case 6:
            return _context4.abrupt("return", _context4.sent);
          case 9:
            _context4.prev = 9;
            _context4.t0 = _context4["catch"](3);
            throw new WalletException(new Error(_context4.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SendEthereumTransaction
            });
          case 12:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this, [[3, 9]]);
    }));
    function sendEthereumTransaction(_x2, _x3) {
      return _sendEthereumTransaction.apply(this, arguments);
    }
    return sendEthereumTransaction;
  }() // eslint-disable-next-line class-methods-use-this
  ;
  _proto.sendTransaction =
  /*#__PURE__*/
  function () {
    var _sendTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(_transaction, _options) {
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            throw new WalletException(new Error('sendTransaction is not supported. Metamask only supports sending transaction to Ethereum'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SendTransaction
            });
          case 1:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }));
    function sendTransaction(_x4, _x5) {
      return _sendTransaction.apply(this, arguments);
    }
    return sendTransaction;
  }() /** @deprecated */;
  _proto.signTransaction =
  /*#__PURE__*/
  function () {
    var _signTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(eip712json, address) {
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            return _context6.abrupt("return", this.signEip712TypedData(eip712json, address));
          case 1:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this);
    }));
    function signTransaction(_x6, _x7) {
      return _signTransaction.apply(this, arguments);
    }
    return signTransaction;
  }();
  _proto.signEip712TypedData = /*#__PURE__*/function () {
    var _signEip712TypedData = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(eip712json, address) {
      var ethereum;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return this.getEthereum();
          case 2:
            ethereum = _context7.sent;
            _context7.prev = 3;
            _context7.next = 6;
            return ethereum.request({
              method: 'eth_signTypedData_v4',
              params: [address, eip712json]
            });
          case 6:
            return _context7.abrupt("return", _context7.sent);
          case 9:
            _context7.prev = 9;
            _context7.t0 = _context7["catch"](3);
            throw new WalletException(new Error(_context7.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SignTransaction
            });
          case 12:
          case "end":
            return _context7.stop();
        }
      }, _callee7, this, [[3, 9]]);
    }));
    function signEip712TypedData(_x8, _x9) {
      return _signEip712TypedData.apply(this, arguments);
    }
    return signEip712TypedData;
  }() // eslint-disable-next-line class-methods-use-this
  ;
  _proto.signCosmosTransaction =
  /*#__PURE__*/
  function () {
    var _signCosmosTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(_transaction, _address) {
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            throw new WalletException(new Error('This wallet does not support signing Cosmos transactions'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SendTransaction
            });
          case 1:
          case "end":
            return _context8.stop();
        }
      }, _callee8);
    }));
    function signCosmosTransaction(_x10, _x11) {
      return _signCosmosTransaction.apply(this, arguments);
    }
    return signCosmosTransaction;
  }();
  _proto.getNetworkId = /*#__PURE__*/function () {
    var _getNetworkId = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
      var ethereum;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            _context9.next = 2;
            return this.getEthereum();
          case 2:
            ethereum = _context9.sent;
            _context9.prev = 3;
            _context9.next = 6;
            return ethereum.request({
              method: 'net_version'
            });
          case 6:
            return _context9.abrupt("return", _context9.sent);
          case 9:
            _context9.prev = 9;
            _context9.t0 = _context9["catch"](3);
            throw new WalletException(new Error(_context9.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetNetworkId
            });
          case 12:
          case "end":
            return _context9.stop();
        }
      }, _callee9, this, [[3, 9]]);
    }));
    function getNetworkId() {
      return _getNetworkId.apply(this, arguments);
    }
    return getNetworkId;
  }();
  _proto.getChainId = /*#__PURE__*/function () {
    var _getChainId = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
      var ethereum;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            _context10.next = 2;
            return this.getEthereum();
          case 2:
            ethereum = _context10.sent;
            _context10.prev = 3;
            _context10.next = 6;
            return ethereum.request({
              method: 'eth_chainId'
            });
          case 6:
            return _context10.abrupt("return", _context10.sent);
          case 9:
            _context10.prev = 9;
            _context10.t0 = _context10["catch"](3);
            throw new WalletException(new Error(_context10.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetChainId
            });
          case 12:
          case "end":
            return _context10.stop();
        }
      }, _callee10, this, [[3, 9]]);
    }));
    function getChainId() {
      return _getChainId.apply(this, arguments);
    }
    return getChainId;
  }();
  _proto.getEthereumTransactionReceipt = /*#__PURE__*/function () {
    var _getEthereumTransactionReceipt = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(txHash) {
      var ethereum, interval, transactionReceiptRetry;
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            _context12.next = 2;
            return this.getEthereum();
          case 2:
            ethereum = _context12.sent;
            interval = 1000;
            transactionReceiptRetry = /*#__PURE__*/function () {
              var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
                var receipt;
                return _regeneratorRuntime().wrap(function _callee11$(_context11) {
                  while (1) switch (_context11.prev = _context11.next) {
                    case 0:
                      _context11.next = 2;
                      return ethereum.request({
                        method: 'eth_getTransactionReceipt',
                        params: [txHash]
                      });
                    case 2:
                      receipt = _context11.sent;
                      if (receipt) {
                        _context11.next = 8;
                        break;
                      }
                      _context11.next = 6;
                      return sleep(interval);
                    case 6:
                      _context11.next = 8;
                      return transactionReceiptRetry();
                    case 8:
                      return _context11.abrupt("return", receipt);
                    case 9:
                    case "end":
                      return _context11.stop();
                  }
                }, _callee11);
              }));
              return function transactionReceiptRetry() {
                return _ref.apply(this, arguments);
              };
            }();
            _context12.prev = 5;
            _context12.next = 8;
            return transactionReceiptRetry();
          case 8:
            return _context12.abrupt("return", _context12.sent);
          case 11:
            _context12.prev = 11;
            _context12.t0 = _context12["catch"](5);
            throw new WalletException(new Error(_context12.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetEthereumTransactionReceipt
            });
          case 14:
          case "end":
            return _context12.stop();
        }
      }, _callee12, this, [[5, 11]]);
    }));
    function getEthereumTransactionReceipt(_x12) {
      return _getEthereumTransactionReceipt.apply(this, arguments);
    }
    return getEthereumTransactionReceipt;
  }() // eslint-disable-next-line class-methods-use-this
  ;
  _proto.getPubKey =
  /*#__PURE__*/
  function () {
    var _getPubKey = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
      return _regeneratorRuntime().wrap(function _callee13$(_context13) {
        while (1) switch (_context13.prev = _context13.next) {
          case 0:
            throw new WalletException(new Error('You can only fetch PubKey from Cosmos native wallets'));
          case 1:
          case "end":
            return _context13.stop();
        }
      }, _callee13);
    }));
    function getPubKey() {
      return _getPubKey.apply(this, arguments);
    }
    return getPubKey;
  }();
  _proto.getEthereum = /*#__PURE__*/function () {
    var _getEthereum = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
      var provider;
      return _regeneratorRuntime().wrap(function _callee14$(_context14) {
        while (1) switch (_context14.prev = _context14.next) {
          case 0:
            if (!this.ethereum) {
              _context14.next = 2;
              break;
            }
            return _context14.abrupt("return", this.ethereum);
          case 2:
            _context14.prev = 2;
            _context14.next = 5;
            return ethereum();
          case 5:
            provider = _context14.sent;
            this.web3 = new Web3(provider);
            this.ethereum = provider;
            return _context14.abrupt("return", provider);
          case 11:
            _context14.prev = 11;
            _context14.t0 = _context14["catch"](2);
            if (!(_context14.t0 instanceof InstallError)) {
              _context14.next = 15;
              break;
            }
            throw new WalletException(new Error('Please install the Cosmostation extension'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletNotInstalledError
            });
          case 15:
            throw new WalletException(new Error(_context14.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError
            });
          case 16:
          case "end":
            return _context14.stop();
        }
      }, _callee14, this, [[2, 11]]);
    }));
    function getEthereum() {
      return _getEthereum.apply(this, arguments);
    }
    return getEthereum;
  }();
  return CosmostationEth;
}(BaseConcreteStrategy);

var isEthWallet = function isEthWallet(wallet) {
  return [Wallet.Metamask, Wallet.Ledger, Wallet.CosmostationEth].includes(wallet);
};

/**
 * Returns a timeout timestamp in milliseconds so its compatible
 * with the way Cosmos handles transactions
 */
var makeTimeoutTimestamp = function makeTimeoutTimestamp(timeoutInMs) {
  if (timeoutInMs === void 0) {
    timeoutInMs = DEFAULT_TIMESTAMP_TIMEOUT_MS;
  }
  var now = new Date();
  var timestamp = new Date(now.getTime() + timeoutInMs);
  var actualTimestamp = timestamp.getTime();
  return actualTimestamp;
};
/**
 * Returns a timeout timestamp in nanoseconds so its compatible
 * with the way Cosmos handles transactions
 */
var makeTimeoutTimestampInNs = function makeTimeoutTimestampInNs(timeoutInMs) {
  if (timeoutInMs === void 0) {
    timeoutInMs = DEFAULT_TIMESTAMP_TIMEOUT_MS;
  }
  return makeTimeoutTimestamp(timeoutInMs) * 1e6;
};
var isCosmosWallet = function isCosmosWallet(wallet) {
  return [Wallet.Cosmostation, Wallet.Leap, Wallet.Keplr].includes(wallet);
};

var ethereumWalletsDisabled = function ethereumWalletsDisabled(args) {
  var ethereumOptions = args.ethereumOptions;
  if (!ethereumOptions) {
    return true;
  }
  var wsRpcUrl = ethereumOptions.wsRpcUrl,
    rpcUrl = ethereumOptions.rpcUrl,
    ethereumChainId = ethereumOptions.ethereumChainId;
  if (!ethereumChainId) {
    return true;
  }
  if (!wsRpcUrl && !rpcUrl) {
    return true;
  }
  return false;
};
var createStrategy = function createStrategy(_ref) {
  var wallet = _ref.wallet,
    args = _ref.args,
    web3 = _ref.web3;
  var disabledWallets = args.disabledWallets || [];
  if (disabledWallets.includes(wallet)) {
    return undefined;
  }
  /**
   * If we only want to use Cosmos Native Wallets
   * We are not creating strategies for Ethereum Native Wallets
   */
  if (isEthWallet(wallet) && !web3) {
    return undefined;
  }
  var ethWalletArgs = {
    web3: web3,
    chainId: args.chainId,
    ethereumOptions: args.ethereumOptions
  };
  switch (wallet) {
    case Wallet.Metamask:
      return new Metamask(ethWalletArgs);
    case Wallet.Ledger:
      return new LedgerLive(ethWalletArgs);
    case Wallet.LedgerLegacy:
      return new LedgerLegacy(ethWalletArgs);
    case Wallet.CosmostationEth:
      return new CosmostationEth(ethWalletArgs);
    case Wallet.WalletConnect:
      return new WalletConnect(ethWalletArgs);
    case Wallet.Keplr:
      return new Keplr(_extends({}, args));
    case Wallet.Leap:
      return new Leap(_extends({}, args));
    case Wallet.Cosmostation:
      return new Cosmostation(_extends({}, args));
    default:
      throw new GeneralException(new Error("The " + wallet + " concrete wallet strategy is not supported"));
  }
};
var createWeb3 = function createWeb3(args) {
  var ethereumOptions = args.ethereumOptions;
  if (!ethereumOptions) {
    throw new WalletException(new Error('Please provide Ethereum chainId'));
  }
  var wsRpcUrl = ethereumOptions.wsRpcUrl,
    rpcUrl = ethereumOptions.rpcUrl,
    ethereumChainId = ethereumOptions.ethereumChainId;
  if (!ethereumChainId) {
    throw new WalletException(new Error('Please provide Ethereum chainId'));
  }
  if (!wsRpcUrl && !rpcUrl) {
    throw new WalletException(new Error('Please provide Ethereum RPC endpoints'));
  }
  var web3Provider = new Web3(new Web3.providers.HttpProvider(rpcUrl));
  web3Provider.setProvider(new Web3.providers.WebsocketProvider(wsRpcUrl));
  return web3Provider;
};
var createStrategies = function createStrategies(args) {
  var web3 = ethereumWalletsDisabled(args) ? undefined : createWeb3(args);
  return Object.values(Wallet).reduce(function (strategies, wallet) {
    var _extends2;
    return _extends({}, strategies, (_extends2 = {}, _extends2[wallet] = createStrategy({
      wallet: wallet,
      args: args,
      web3: web3
    }), _extends2));
  }, {});
};
var WalletStrategy = /*#__PURE__*/function () {
  function WalletStrategy(args) {
    this.strategies = createStrategies(args);
    this.wallet = args.wallet || args.ethereumOptions ? Wallet.Metamask : Wallet.Keplr;
  }
  var _proto = WalletStrategy.prototype;
  _proto.getWallet = function getWallet() {
    return this.wallet;
  };
  _proto.setWallet = function setWallet(wallet) {
    this.wallet = wallet;
  };
  _proto.getStrategy = function getStrategy() {
    if (!this.strategies[this.wallet]) {
      throw new GeneralException(new Error("Wallet " + this.wallet + " is not enabled/available!"));
    }
    return this.strategies[this.wallet];
  };
  _proto.getAddresses = function getAddresses() {
    return this.getStrategy().getAddresses();
  };
  _proto.getWalletDeviceType = function getWalletDeviceType() {
    return this.getStrategy().getWalletDeviceType();
  };
  _proto.getPubKey = function getPubKey() {
    return this.getStrategy().getPubKey();
  };
  _proto.getChainId = function getChainId() {
    return this.getStrategy().getChainId();
  };
  _proto.getNetworkId = function getNetworkId() {
    return this.getStrategy().getNetworkId();
  };
  _proto.getEthereumTransactionReceipt = /*#__PURE__*/function () {
    var _getEthereumTransactionReceipt = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(txHash) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", this.getStrategy().getEthereumTransactionReceipt(txHash));
          case 1:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function getEthereumTransactionReceipt(_x) {
      return _getEthereumTransactionReceipt.apply(this, arguments);
    }
    return getEthereumTransactionReceipt;
  }();
  _proto.confirm = /*#__PURE__*/function () {
    var _confirm = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(address) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.abrupt("return", this.getStrategy().confirm(address));
          case 1:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function confirm(_x2) {
      return _confirm.apply(this, arguments);
    }
    return confirm;
  }();
  _proto.disconnectWallet = /*#__PURE__*/function () {
    var _disconnectWallet = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      var strategy;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            strategy = this.getStrategy();
            if (!(strategy.disconnect !== undefined)) {
              _context3.next = 4;
              break;
            }
            _context3.next = 4;
            return strategy.disconnect();
          case 4:
            this.wallet = Wallet.Metamask;
          case 5:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function disconnectWallet() {
      return _disconnectWallet.apply(this, arguments);
    }
    return disconnectWallet;
  }();
  _proto.sendTransaction = /*#__PURE__*/function () {
    var _sendTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(tx, options) {
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            return _context4.abrupt("return", this.getStrategy().sendTransaction(tx, options));
          case 1:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this);
    }));
    function sendTransaction(_x3, _x4) {
      return _sendTransaction.apply(this, arguments);
    }
    return sendTransaction;
  }();
  _proto.sendEthereumTransaction = /*#__PURE__*/function () {
    var _sendEthereumTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(tx /* TODO */, options) {
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            return _context5.abrupt("return", this.getStrategy().sendEthereumTransaction(tx, options));
          case 1:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this);
    }));
    function sendEthereumTransaction(_x5, _x6) {
      return _sendEthereumTransaction.apply(this, arguments);
    }
    return sendEthereumTransaction;
  }() /** @deprecated * */;
  _proto.signTransaction =
  /*#__PURE__*/
  function () {
    var _signTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(data, address) {
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            return _context6.abrupt("return", this.getStrategy().signTransaction(data, address));
          case 1:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this);
    }));
    function signTransaction(_x7, _x8) {
      return _signTransaction.apply(this, arguments);
    }
    return signTransaction;
  }();
  _proto.signEip712TypedData = /*#__PURE__*/function () {
    var _signEip712TypedData = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(eip712TypedData, address) {
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            if (!isCosmosWallet(this.wallet)) {
              _context7.next = 2;
              break;
            }
            throw new WalletException(new Error("You can't sign Ethereum Transaction using " + this.wallet));
          case 2:
            return _context7.abrupt("return", this.getStrategy().signEip712TypedData(eip712TypedData, address));
          case 3:
          case "end":
            return _context7.stop();
        }
      }, _callee7, this);
    }));
    function signEip712TypedData(_x9, _x10) {
      return _signEip712TypedData.apply(this, arguments);
    }
    return signEip712TypedData;
  }();
  _proto.simulateTransaction = /*#__PURE__*/function () {
    var _simulateTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(signedTx, nodeUrl) {
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            return _context8.abrupt("return", this.getStrategy().simulateTransaction(signedTx, nodeUrl));
          case 1:
          case "end":
            return _context8.stop();
        }
      }, _callee8, this);
    }));
    function simulateTransaction(_x11, _x12) {
      return _simulateTransaction.apply(this, arguments);
    }
    return simulateTransaction;
  }();
  _proto.broadcastTransaction = /*#__PURE__*/function () {
    var _broadcastTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(signedTx, nodeUrl) {
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            return _context9.abrupt("return", this.getStrategy().broadcastTransaction(signedTx, nodeUrl));
          case 1:
          case "end":
            return _context9.stop();
        }
      }, _callee9, this);
    }));
    function broadcastTransaction(_x13, _x14) {
      return _broadcastTransaction.apply(this, arguments);
    }
    return broadcastTransaction;
  }();
  _proto.simulateSignAndBroadcast = /*#__PURE__*/function () {
    var _simulateSignAndBroadcast = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(_ref2) {
      var ethChainId, cosmosChainId, txMsg, nodeUrl, memo;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            ethChainId = _ref2.ethChainId, cosmosChainId = _ref2.cosmosChainId, txMsg = _ref2.txMsg, nodeUrl = _ref2.nodeUrl, memo = _ref2.memo;
            return _context10.abrupt("return", this.getStrategy().simulateSignAndBroadcast({
              ethChainId: ethChainId,
              cosmosChainId: cosmosChainId,
              txMsg: txMsg,
              nodeUrl: nodeUrl,
              memo: memo
            }));
          case 2:
          case "end":
            return _context10.stop();
        }
      }, _callee10, this);
    }));
    function simulateSignAndBroadcast(_x15) {
      return _simulateSignAndBroadcast.apply(this, arguments);
    }
    return simulateSignAndBroadcast;
  }();
  _proto.signCosmosTransaction = /*#__PURE__*/function () {
    var _signCosmosTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(transaction, address) {
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            if (!isEthWallet(this.wallet)) {
              _context11.next = 2;
              break;
            }
            throw new WalletException(new Error("You can't sign Cosmos Transaction using " + this.wallet));
          case 2:
            return _context11.abrupt("return", this.getStrategy().signCosmosTransaction(transaction, address));
          case 3:
          case "end":
            return _context11.stop();
        }
      }, _callee11, this);
    }));
    function signCosmosTransaction(_x16, _x17) {
      return _signCosmosTransaction.apply(this, arguments);
    }
    return signCosmosTransaction;
  }();
  _proto.getWeb3 = function getWeb3() {
    return this.getStrategy().getWeb3();
  };
  _proto.onAccountChange = function onAccountChange(callback) {
    if (this.getStrategy().onAccountChange) {
      return this.getStrategy().onAccountChange(callback);
    }
  };
  _proto.onChainIdChange = function onChainIdChange(callback) {
    if (this.getStrategy().onChainIdChange) {
      return this.getStrategy().onChainIdChange(callback);
    }
  };
  _proto.cancelOnChainIdChange = function cancelOnChainIdChange() {
    if (this.getStrategy().cancelOnChainIdChange) {
      return this.getStrategy().cancelOnChainIdChange();
    }
  };
  _proto.cancelAllEvents = function cancelAllEvents() {
    if (this.getStrategy().cancelAllEvents) {
      return this.getStrategy().cancelAllEvents();
    }
  };
  _proto.cancelOnAccountChange = function cancelOnAccountChange() {
    if (this.getStrategy().cancelOnAccountChange) {
      return this.getStrategy().cancelOnAccountChange();
    }
  };
  return WalletStrategy;
}();

var Keplr$1 = /*#__PURE__*/function () {
  function Keplr(args) {
    this.chainId = args.chainId || CosmosChainId.Router;
    this.keplrWallet = new KeplrWallet(args.chainId);
  }
  var _proto = Keplr.prototype;
  _proto.getWalletDeviceType = /*#__PURE__*/function () {
    var _getWalletDeviceType = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var keplrWallet, key;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            keplrWallet = this.getKeplrWallet();
            _context.next = 3;
            return keplrWallet.getKey();
          case 3:
            key = _context.sent;
            return _context.abrupt("return", key.isNanoLedger ? Promise.resolve(WalletDeviceType.Hardware) : Promise.resolve(WalletDeviceType.Browser));
          case 5:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function getWalletDeviceType() {
      return _getWalletDeviceType.apply(this, arguments);
    }
    return getWalletDeviceType;
  }();
  _proto.isChainIdSupported = /*#__PURE__*/function () {
    var _isChainIdSupported = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(chainId) {
      var keplrWallet;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            keplrWallet = chainId ? new KeplrWallet(chainId) : this.getKeplrWallet();
            return _context2.abrupt("return", keplrWallet.checkChainIdSupport());
          case 2:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function isChainIdSupported(_x) {
      return _isChainIdSupported.apply(this, arguments);
    }
    return isChainIdSupported;
  }();
  _proto.getAddresses = /*#__PURE__*/function () {
    var _getAddresses = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      var keplrWallet, accounts;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            keplrWallet = this.getKeplrWallet();
            _context3.prev = 1;
            _context3.next = 4;
            return keplrWallet.checkChainIdSupport();
          case 4:
            if (_context3.sent) {
              _context3.next = 7;
              break;
            }
            _context3.next = 7;
            return keplrWallet.experimentalSuggestChain();
          case 7:
            _context3.next = 9;
            return keplrWallet.getAccounts();
          case 9:
            accounts = _context3.sent;
            return _context3.abrupt("return", accounts.map(function (account) {
              return account.address;
            }));
          case 13:
            _context3.prev = 13;
            _context3.t0 = _context3["catch"](1);
            throw new CosmosWalletException(new Error(_context3.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetAccounts
            });
          case 16:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this, [[1, 13]]);
    }));
    function getAddresses() {
      return _getAddresses.apply(this, arguments);
    }
    return getAddresses;
  }();
  _proto.sendTransaction = /*#__PURE__*/function () {
    var _sendTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(transaction) {
      var keplrWallet, txRaw;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            keplrWallet = this.keplrWallet;
            txRaw = transaction instanceof TxRaw$1 ? transaction : createTxRawFromSigResponse(transaction);
            _context4.prev = 2;
            _context4.t0 = keplrWallet;
            _context4.next = 6;
            return keplrWallet.broadcastTx(txRaw);
          case 6:
            _context4.t1 = _context4.sent;
            _context4.next = 9;
            return _context4.t0.waitTxBroadcasted.call(_context4.t0, _context4.t1);
          case 9:
            return _context4.abrupt("return", _context4.sent);
          case 12:
            _context4.prev = 12;
            _context4.t2 = _context4["catch"](2);
            throw new TransactionException(new Error(_context4.t2.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.ChainError,
              contextModule: WalletAction.SendTransaction
            });
          case 15:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this, [[2, 12]]);
    }));
    function sendTransaction(_x2) {
      return _sendTransaction.apply(this, arguments);
    }
    return sendTransaction;
  }();
  _proto.signTransaction = /*#__PURE__*/function () {
    var _signTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(transaction, address) {
      var keplrWallet, signer, signDoc;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            keplrWallet = this.getKeplrWallet();
            _context5.next = 3;
            return keplrWallet.getOfflineSigner();
          case 3:
            signer = _context5.sent;
            signDoc = createCosmosSignDocFromTransaction(transaction);
            _context5.prev = 5;
            return _context5.abrupt("return", signer.signDirect(address, signDoc));
          case 9:
            _context5.prev = 9;
            _context5.t0 = _context5["catch"](5);
            throw new CosmosWalletException(new Error(_context5.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SendTransaction
            });
          case 12:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this, [[5, 9]]);
    }));
    function signTransaction(_x3, _x4) {
      return _signTransaction.apply(this, arguments);
    }
    return signTransaction;
  }();
  _proto.getPubKey = /*#__PURE__*/function () {
    var _getPubKey = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
      var keplrWallet, key;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            keplrWallet = this.getKeplrWallet();
            _context6.next = 3;
            return keplrWallet.getKey();
          case 3:
            key = _context6.sent;
            return _context6.abrupt("return", Buffer.from(key.pubKey).toString('base64'));
          case 5:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this);
    }));
    function getPubKey() {
      return _getPubKey.apply(this, arguments);
    }
    return getPubKey;
  }();
  _proto.getKeplrWallet = function getKeplrWallet() {
    var keplrWallet = this.keplrWallet;
    if (!keplrWallet) {
      throw new CosmosWalletException(new Error('Please install the Keplr wallet extension'), {
        code: UnspecifiedErrorCode,
        type: ErrorType.WalletNotInstalledError,
        contextModule: WalletAction.SignTransaction
      });
    }
    return keplrWallet;
  };
  return Keplr;
}();

var Leap$1 = /*#__PURE__*/function () {
  function Leap(args) {
    this.chainId = args.chainId || CosmosChainId.Router;
    this.leapWallet = new LeapWallet(args.chainId);
  }
  var _proto = Leap.prototype;
  _proto.getWalletDeviceType = /*#__PURE__*/function () {
    var _getWalletDeviceType = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", Promise.resolve(WalletDeviceType.Browser));
          case 1:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    function getWalletDeviceType() {
      return _getWalletDeviceType.apply(this, arguments);
    }
    return getWalletDeviceType;
  }();
  _proto.isChainIdSupported = /*#__PURE__*/function () {
    var _isChainIdSupported = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(chainId) {
      var leapWallet;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            leapWallet = chainId ? new LeapWallet(chainId) : this.getLeapWallet();
            return _context2.abrupt("return", leapWallet.checkChainIdSupport());
          case 2:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function isChainIdSupported(_x) {
      return _isChainIdSupported.apply(this, arguments);
    }
    return isChainIdSupported;
  }();
  _proto.getAddresses = /*#__PURE__*/function () {
    var _getAddresses = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      var chainId, leapWallet, accounts;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            chainId = this.chainId;
            leapWallet = this.getLeapWallet();
            _context3.prev = 2;
            _context3.next = 5;
            return leapWallet.checkChainIdSupport();
          case 5:
            if (_context3.sent) {
              _context3.next = 7;
              break;
            }
            throw new CosmosWalletException(new Error("The " + chainId + " is not supported on Leap."), {
              type: ErrorType.WalletError
            });
          case 7:
            _context3.next = 9;
            return leapWallet.getAccounts();
          case 9:
            accounts = _context3.sent;
            return _context3.abrupt("return", accounts.map(function (account) {
              return account.address;
            }));
          case 13:
            _context3.prev = 13;
            _context3.t0 = _context3["catch"](2);
            throw new CosmosWalletException(new Error(_context3.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetAccounts
            });
          case 16:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this, [[2, 13]]);
    }));
    function getAddresses() {
      return _getAddresses.apply(this, arguments);
    }
    return getAddresses;
  }();
  _proto.sendTransaction = /*#__PURE__*/function () {
    var _sendTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(transaction) {
      var leapWallet, txRaw;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            leapWallet = this.leapWallet;
            txRaw = transaction instanceof TxRaw$1 ? transaction : createTxRawFromSigResponse(transaction);
            _context4.prev = 2;
            _context4.t0 = leapWallet;
            _context4.next = 6;
            return leapWallet.broadcastTx(txRaw);
          case 6:
            _context4.t1 = _context4.sent;
            _context4.next = 9;
            return _context4.t0.waitTxBroadcasted.call(_context4.t0, _context4.t1);
          case 9:
            return _context4.abrupt("return", _context4.sent);
          case 12:
            _context4.prev = 12;
            _context4.t2 = _context4["catch"](2);
            throw new TransactionException(new Error(_context4.t2.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.ChainError,
              contextModule: WalletAction.SendTransaction
            });
          case 15:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this, [[2, 12]]);
    }));
    function sendTransaction(_x2) {
      return _sendTransaction.apply(this, arguments);
    }
    return sendTransaction;
  }();
  _proto.signTransaction = /*#__PURE__*/function () {
    var _signTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(transaction, address) {
      var leapWallet, signer, signDoc;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            leapWallet = this.getLeapWallet();
            _context5.next = 3;
            return leapWallet.getOfflineSigner();
          case 3:
            signer = _context5.sent;
            signDoc = createCosmosSignDocFromTransaction(transaction);
            _context5.prev = 5;
            return _context5.abrupt("return", signer.signDirect(address, signDoc));
          case 9:
            _context5.prev = 9;
            _context5.t0 = _context5["catch"](5);
            throw new CosmosWalletException(new Error(_context5.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SendTransaction
            });
          case 12:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this, [[5, 9]]);
    }));
    function signTransaction(_x3, _x4) {
      return _signTransaction.apply(this, arguments);
    }
    return signTransaction;
  }();
  _proto.getPubKey = /*#__PURE__*/function () {
    var _getPubKey = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
      var keplrWallet, key;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            keplrWallet = this.getLeapWallet();
            _context6.next = 3;
            return keplrWallet.getKey();
          case 3:
            key = _context6.sent;
            return _context6.abrupt("return", Buffer.from(key.pubKey).toString('base64'));
          case 5:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this);
    }));
    function getPubKey() {
      return _getPubKey.apply(this, arguments);
    }
    return getPubKey;
  }();
  _proto.getLeapWallet = function getLeapWallet() {
    var leapWallet = this.leapWallet;
    if (!leapWallet) {
      throw new CosmosWalletException(new Error('Please install the Leap wallet extension'), {
        code: UnspecifiedErrorCode,
        type: ErrorType.WalletNotInstalledError,
        contextModule: WalletAction.SignTransaction
      });
    }
    return leapWallet;
  };
  return Leap;
}();

var getChainNameFromChainId = function getChainNameFromChainId(chainId) {
  var _chainId$split = chainId.split('-'),
    chainName = _chainId$split[0];
  if (chainName.includes('cosmoshub')) {
    return 'cosmos';
  }
  if (chainName.includes('core')) {
    return 'persistence';
  }
  if (chainName.includes('evmos')) {
    return 'evmos';
  }
  return chainName;
};
var Cosmostation$1 = /*#__PURE__*/function () {
  function Cosmostation(args) {
    this.chainId = args.chainId;
    this.chainName = getChainNameFromChainId(args.chainId);
  }
  var _proto = Cosmostation.prototype;
  _proto.getWalletDeviceType = /*#__PURE__*/function () {
    var _getWalletDeviceType = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", Promise.resolve(WalletDeviceType.Browser));
          case 1:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    function getWalletDeviceType() {
      return _getWalletDeviceType.apply(this, arguments);
    }
    return getWalletDeviceType;
  }();
  _proto.isChainIdSupported = /*#__PURE__*/function () {
    var _isChainIdSupported = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(chainId) {
      var actualChainId, provider, supportedChainIds;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            actualChainId = chainId || this.chainId;
            _context2.next = 3;
            return this.getProvider();
          case 3:
            provider = _context2.sent;
            _context2.next = 6;
            return provider.getSupportedChainIds();
          case 6:
            supportedChainIds = _context2.sent;
            return _context2.abrupt("return", !!supportedChainIds.official.find(function (chainId) {
              return chainId === actualChainId;
            }));
          case 8:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function isChainIdSupported(_x) {
      return _isChainIdSupported.apply(this, arguments);
    }
    return isChainIdSupported;
  }();
  _proto.getAddresses = /*#__PURE__*/function () {
    var _getAddresses = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      var chainName, provider, accounts;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            chainName = this.chainName;
            _context3.next = 3;
            return this.getProvider();
          case 3:
            provider = _context3.sent;
            _context3.prev = 4;
            _context3.next = 7;
            return provider.requestAccount(chainName);
          case 7:
            accounts = _context3.sent;
            return _context3.abrupt("return", [accounts.address]);
          case 11:
            _context3.prev = 11;
            _context3.t0 = _context3["catch"](4);
            if (!(_context3.t0.code === 4001)) {
              _context3.next = 15;
              break;
            }
            throw new CosmosWalletException(new Error('The user rejected the request'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetAccounts
            });
          case 15:
            throw new CosmosWalletException(new Error(_context3.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetAccounts
            });
          case 16:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this, [[4, 11]]);
    }));
    function getAddresses() {
      return _getAddresses.apply(this, arguments);
    }
    return getAddresses;
  }();
  _proto.sendTransaction = /*#__PURE__*/function () {
    var _sendTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(transaction) {
      var chainName, provider, txRaw, response;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            chainName = this.chainName;
            _context4.next = 3;
            return this.getProvider();
          case 3:
            provider = _context4.sent;
            txRaw = transaction instanceof TxRaw$1 ? transaction : createTxRawFromSigResponse(transaction);
            _context4.prev = 5;
            _context4.next = 8;
            return provider.sendTransaction(chainName, txRaw.serializeBinary(), SEND_TRANSACTION_MODE.ASYNC);
          case 8:
            response = _context4.sent;
            return _context4.abrupt("return", response.tx_response.txhash);
          case 12:
            _context4.prev = 12;
            _context4.t0 = _context4["catch"](5);
            throw new TransactionException(new Error(_context4.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.ChainError,
              contextModule: WalletAction.SendTransaction
            });
          case 15:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this, [[5, 12]]);
    }));
    function sendTransaction(_x2) {
      return _sendTransaction.apply(this, arguments);
    }
    return sendTransaction;
  }();
  _proto.signTransaction = /*#__PURE__*/function () {
    var _signTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(transaction) {
      var chainName, chainId, provider, signDoc, signDirectResponse;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            chainName = this.chainName, chainId = this.chainId;
            _context5.next = 3;
            return this.getProvider();
          case 3:
            provider = _context5.sent;
            signDoc = createCosmosSignDocFromTransaction(transaction);
            _context5.prev = 5;
            _context5.next = 8;
            return provider.signDirect(chainName, {
              chain_id: chainId,
              body_bytes: signDoc.bodyBytes,
              auth_info_bytes: signDoc.authInfoBytes,
              account_number: transaction.accountNumber.toString()
            }, {
              fee: true,
              memo: true
            });
          case 8:
            signDirectResponse = _context5.sent;
            return _context5.abrupt("return", {
              signed: makeSignDoc(signDirectResponse.signed_doc.body_bytes, signDirectResponse.signed_doc.auth_info_bytes, signDirectResponse.signed_doc.chain_id, parseInt(signDirectResponse.signed_doc.account_number, 10)),
              signature: {
                signature: signDirectResponse.signature
              }
            });
          case 12:
            _context5.prev = 12;
            _context5.t0 = _context5["catch"](5);
            throw new CosmosWalletException(new Error(_context5.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.SendTransaction
            });
          case 15:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this, [[5, 12]]);
    }));
    function signTransaction(_x3) {
      return _signTransaction.apply(this, arguments);
    }
    return signTransaction;
  }();
  _proto.getPubKey = /*#__PURE__*/function () {
    var _getPubKey = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
      var chainName, provider, account;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            chainName = this.chainName;
            _context6.next = 3;
            return this.getProvider();
          case 3:
            provider = _context6.sent;
            _context6.prev = 4;
            _context6.next = 7;
            return provider.requestAccount(chainName);
          case 7:
            account = _context6.sent;
            return _context6.abrupt("return", Buffer.from(account.publicKey).toString('base64'));
          case 11:
            _context6.prev = 11;
            _context6.t0 = _context6["catch"](4);
            if (!(_context6.t0.code === 4001)) {
              _context6.next = 15;
              break;
            }
            throw new CosmosWalletException(new Error('The user rejected the request'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetAccounts
            });
          case 15:
            throw new CosmosWalletException(new Error(_context6.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError,
              contextModule: WalletAction.GetAccounts
            });
          case 16:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this, [[4, 11]]);
    }));
    function getPubKey() {
      return _getPubKey.apply(this, arguments);
    }
    return getPubKey;
  }();
  _proto.getProvider = /*#__PURE__*/function () {
    var _getProvider = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
      var provider;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            if (!this.provider) {
              _context7.next = 2;
              break;
            }
            return _context7.abrupt("return", this.provider);
          case 2:
            _context7.prev = 2;
            _context7.next = 5;
            return cosmos();
          case 5:
            provider = _context7.sent;
            this.provider = provider;
            return _context7.abrupt("return", provider);
          case 10:
            _context7.prev = 10;
            _context7.t0 = _context7["catch"](2);
            if (!(_context7.t0 instanceof InstallError)) {
              _context7.next = 14;
              break;
            }
            throw new CosmosWalletException(new Error('Please install the Cosmostation extension'), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletNotInstalledError
            });
          case 14:
            throw new CosmosWalletException(new Error(_context7.t0.message), {
              code: UnspecifiedErrorCode,
              type: ErrorType.WalletError
            });
          case 15:
          case "end":
            return _context7.stop();
        }
      }, _callee7, this, [[2, 10]]);
    }));
    function getProvider() {
      return _getProvider.apply(this, arguments);
    }
    return getProvider;
  }();
  return Cosmostation;
}();

var cosmosWallets = [Wallet.Keplr, Wallet.Leap, Wallet.Cosmostation];
var createWallet = function createWallet(_ref) {
  var wallet = _ref.wallet,
    args = _ref.args;
  switch (wallet) {
    case Wallet.Keplr:
      return new Keplr$1(_extends({}, args));
    case Wallet.Leap:
      return new Leap$1(_extends({}, args));
    case Wallet.Cosmostation:
      return new Cosmostation$1(_extends({}, args));
    default:
      throw new GeneralException(new Error("The " + wallet + " concrete wallet strategy is not supported"));
  }
};
var createWallets = function createWallets(args) {
  return cosmosWallets.reduce(function (strategies, wallet) {
    var _extends2;
    return _extends({}, strategies, (_extends2 = {}, _extends2[wallet] = createWallet({
      wallet: wallet,
      args: args
    }), _extends2));
  }, {});
};
var CosmosWalletStrategy = /*#__PURE__*/function () {
  function CosmosWalletStrategy(args) {
    this.strategies = createWallets(args);
    this.wallet = args.wallet || Wallet.Keplr;
  }
  var _proto = CosmosWalletStrategy.prototype;
  _proto.getWallet = function getWallet() {
    return this.wallet;
  };
  _proto.setWallet = function setWallet(wallet) {
    this.wallet = isCosmosWallet(wallet) ? wallet : Wallet.Keplr;
  };
  _proto.getStrategy = function getStrategy() {
    if (!this.strategies[this.wallet]) {
      throw new GeneralException(new Error("Wallet " + this.wallet + " is not enabled/available!"));
    }
    return this.strategies[this.wallet];
  };
  _proto.getWalletDeviceType = function getWalletDeviceType() {
    return this.getStrategy().getWalletDeviceType();
  };
  _proto.getPubKey = function getPubKey() {
    return this.getStrategy().getPubKey();
  };
  _proto.getAddresses = function getAddresses() {
    return this.getStrategy().getAddresses();
  };
  _proto.isChainIdSupported = function isChainIdSupported(chainId) {
    return this.getStrategy().isChainIdSupported(chainId);
  };
  _proto.sendTransaction = /*#__PURE__*/function () {
    var _sendTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(tx) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", this.getStrategy().sendTransaction(tx));
          case 1:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function sendTransaction(_x) {
      return _sendTransaction.apply(this, arguments);
    }
    return sendTransaction;
  }();
  _proto.signTransaction = /*#__PURE__*/function () {
    var _signTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(transaction, address) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.abrupt("return", this.getStrategy().signTransaction(transaction, address));
          case 1:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function signTransaction(_x2, _x3) {
      return _signTransaction.apply(this, arguments);
    }
    return signTransaction;
  }();
  return CosmosWalletStrategy;
}();

/**
 * Executes query on cosmwasm contract on router chain via metamask
 * @param networkEnv - Network Environment of Router Chain
 * @param contractAddress - CosmWasm contract address
 * @param executeMsg - Execution Query
 * @param nodeUrl - LCD node Url
 * @param ethereumAddress - Ethereum address of user
 * @param injectedSigner - Ex- window.ethereum or any injected wallet signer
 * @param funds - if contract requires funds with execution
 * @param memo - String
 * @return {BroadcastResponse}
 * @throws {Error}
 */
var executeQueryInjected = /*#__PURE__*/function () {
  var _ref2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var networkEnv, contractAddress, executeMsg, nodeUrl, ethereumAddress, injectedSigner, funds, memo, _accountDetails$pubKe, _accountDetails$pubKe2, _eipData$fee$feePayer, _eipData$fee, userAccountInfo, baseAccount, accountDetails, context, executeContractMsg, eipData, simulatedTxPayload, simulatedTx, simulationResponse, simulatedFee, txPayload, signature, signatureBytes, publicKeyHex, publicKey, txPayloadWithPubKey, signDirect, bodyBytes, authInfoBytes, txRawToSend, broadcastResponse;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          networkEnv = _ref.networkEnv, contractAddress = _ref.contractAddress, executeMsg = _ref.executeMsg, nodeUrl = _ref.nodeUrl, ethereumAddress = _ref.ethereumAddress, injectedSigner = _ref.injectedSigner, funds = _ref.funds, memo = _ref.memo;
          _context.prev = 1;
          _context.next = 4;
          return new ChainRestAuthApi(nodeUrl).fetchAccount(getRouterSignerAddress(ethereumAddress));
        case 4:
          userAccountInfo = _context.sent;
          baseAccount = BaseAccount.fromRestApi(userAccountInfo);
          accountDetails = baseAccount.toAccountDetails();
          context = {
            chain: {
              chainId: getEthereumChainIdForNetwork(getNetworkType(networkEnv)),
              cosmosChainId: getChainInfoForNetwork(getNetworkType(networkEnv)).chainId
            },
            sender: {
              accountAddress: getRouterSignerAddress(ethereumAddress),
              sequence: accountDetails.sequence,
              accountNumber: accountDetails.accountNumber,
              pubkey: (_accountDetails$pubKe = (_accountDetails$pubKe2 = accountDetails.pubKey) == null ? void 0 : _accountDetails$pubKe2.key) != null ? _accountDetails$pubKe : ''
            },
            memo: memo != null ? memo : ''
          }; // Execution Msg
          executeContractMsg = MsgExecuteCwContract.fromJSON({
            sender: getRouterSignerAddress(ethereumAddress),
            contractAddress: contractAddress,
            msg: executeMsg,
            funds: funds
          }); //EIP DATA
          eipData = {
            msgs: [executeContractMsg],
            tx: {
              accountNumber: accountDetails.accountNumber.toString(),
              sequence: accountDetails.sequence.toString(),
              chainId: getChainInfoForNetwork(getNetworkType(networkEnv)).chainId
            },
            ethereumChainId: getEthereumChainIdForNetwork(getNetworkType(networkEnv)),
            fee: {
              feePayer: getRouterSignerAddress(ethereumAddress)
            }
          }; // Simulationx
          simulatedTxPayload = getEtherMintTxPayload(context, eipData);
          simulatedTx = createTxRawForBroadcast(simulatedTxPayload.signDirect.body.toBinary(), simulatedTxPayload.signDirect.authInfo.toBinary(), [new Uint8Array(2)]);
          _context.next = 14;
          return simulateRawTx(simulatedTx, nodeUrl);
        case 14:
          simulationResponse = _context.sent;
          if (simulationResponse.hasOwnProperty('gas_info')) {
            _context.next = 17;
            break;
          }
          throw new Error(simulationResponse.message);
        case 17:
          simulatedFee = {
            amount: [{
              amount: new BigNumberInBase(ROUTER_DEFAULT_GAS_PRICE).times(parseInt((parseInt(simulationResponse.gas_info.gas_used) * GAS_LIMIT_MULTIPLIER).toString())).toString(),
              denom: ROUTER_DENOM
            }],
            gas: parseInt((parseInt(simulationResponse.gas_info.gas_used) * GAS_LIMIT_MULTIPLIER).toString()).toString(),
            feePayer: (_eipData$fee$feePayer = (_eipData$fee = eipData.fee) == null ? void 0 : _eipData$fee.feePayer) != null ? _eipData$fee$feePayer : getRouterSignerAddress(ethereumAddress)
          }; //Replacing old fee with simulated fee
          eipData.fee = simulatedFee;
          txPayload = getEtherMintTxPayload(context, eipData); //Taking signature from user
          _context.next = 22;
          return injectedSigner.request({
            method: 'eth_signTypedData_v4',
            params: [ethereumAddress, JSON.stringify(txPayload.eipToSign)]
          });
        case 22:
          signature = _context.sent;
          // Deriving signature from public key
          signatureBytes = hexToBuff(signature);
          publicKeyHex = recoverTypedSignaturePubKey(txPayload.eipToSign, signature);
          publicKey = hexToBase64(publicKeyHex); // Placing Public Key in context
          context.sender.pubkey = publicKey;
          // Making new transaction payload with public key
          txPayloadWithPubKey = getEtherMintTxPayload(context, eipData);
          signDirect = txPayloadWithPubKey.signDirect;
          bodyBytes = signDirect.body.toBinary();
          authInfoBytes = signDirect.authInfo.toBinary();
          txRawToSend = createTxRawForBroadcast(bodyBytes, authInfoBytes, [signatureBytes]); // Broadcasting the transaction
          _context.next = 34;
          return broadcastRawTx(txRawToSend, nodeUrl);
        case 34:
          broadcastResponse = _context.sent;
          return _context.abrupt("return", broadcastResponse);
        case 38:
          _context.prev = 38;
          _context.t0 = _context["catch"](1);
          throw new TransactionException(new Error(_context.t0.message));
        case 41:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[1, 38]]);
  }));
  return function executeQueryInjected(_x) {
    return _ref2.apply(this, arguments);
  };
}();
var sendEthTxnToRouterChain = /*#__PURE__*/function () {
  var _ref4 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref3) {
    var _accountDetails$pubKe3, _accountDetails$pubKe4, _eipData$fee$feePayer2, _eipData$fee2;
    var networkEnv, txMsg, nodeUrl, ethereumAddress, injectedSigner, memo, userAccountInfo, baseAccount, accountDetails, context, eipData, simulatedTxPayload, simulatedTx, simulationResponse, simulatedFee, txPayload, signature, signatureBytes, publicKeyHex, publicKey, txPayloadWithPubKey, signDirect, bodyBytes, authInfoBytes, txRawToSend, broadcastResponse;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          networkEnv = _ref3.networkEnv, txMsg = _ref3.txMsg, nodeUrl = _ref3.nodeUrl, ethereumAddress = _ref3.ethereumAddress, injectedSigner = _ref3.injectedSigner, memo = _ref3.memo;
          _context2.next = 3;
          return new ChainRestAuthApi(nodeUrl).fetchAccount(getRouterSignerAddress(ethereumAddress));
        case 3:
          userAccountInfo = _context2.sent;
          baseAccount = BaseAccount.fromRestApi(userAccountInfo);
          accountDetails = baseAccount.toAccountDetails();
          context = {
            chain: {
              chainId: getEthereumChainIdForNetwork(getNetworkType(networkEnv)),
              cosmosChainId: getChainInfoForNetwork(getNetworkType(networkEnv)).chainId
            },
            sender: {
              accountAddress: getRouterSignerAddress(ethereumAddress),
              sequence: accountDetails.sequence,
              accountNumber: accountDetails.accountNumber,
              pubkey: (_accountDetails$pubKe3 = (_accountDetails$pubKe4 = accountDetails.pubKey) == null ? void 0 : _accountDetails$pubKe4.key) != null ? _accountDetails$pubKe3 : ''
            },
            memo: memo != null ? memo : ''
          };
          console.log('Context =>', context);
          //EIP DATA
          eipData = {
            msgs: [txMsg],
            tx: {
              accountNumber: accountDetails.accountNumber.toString(),
              sequence: accountDetails.sequence.toString(),
              chainId: getChainInfoForNetwork(getNetworkType(networkEnv)).chainId
            },
            ethereumChainId: getEthereumChainIdForNetwork(getNetworkType(networkEnv)),
            fee: {
              feePayer: getRouterSignerAddress(ethereumAddress)
            }
          };
          console.log('eipData =>', eipData);
          // Simulationx
          simulatedTxPayload = getEtherMintTxPayload(context, eipData);
          simulatedTx = createTxRawForBroadcast(simulatedTxPayload.signDirect.body.toBinary(), simulatedTxPayload.signDirect.authInfo.toBinary(), [new Uint8Array(2)]);
          _context2.next = 14;
          return simulateRawTx(simulatedTx, nodeUrl);
        case 14:
          simulationResponse = _context2.sent;
          if (simulationResponse.hasOwnProperty('gas_info')) {
            _context2.next = 17;
            break;
          }
          throw new Error(simulationResponse.message);
        case 17:
          simulatedFee = {
            amount: [{
              amount: new BigNumberInBase(ROUTER_DEFAULT_GAS_PRICE).times(parseInt((parseInt(simulationResponse.gas_info.gas_used) * GAS_LIMIT_MULTIPLIER).toString())).toString(),
              denom: ROUTER_DENOM
            }],
            gas: parseInt((parseInt(simulationResponse.gas_info.gas_used) * GAS_LIMIT_MULTIPLIER).toString()).toString(),
            feePayer: (_eipData$fee$feePayer2 = (_eipData$fee2 = eipData.fee) == null ? void 0 : _eipData$fee2.feePayer) != null ? _eipData$fee$feePayer2 : getRouterSignerAddress(ethereumAddress)
          };
          eipData.fee = simulatedFee;
          txPayload = getEtherMintTxPayload(context, eipData); //Taking signature from user
          _context2.next = 22;
          return injectedSigner.request({
            method: 'eth_signTypedData_v4',
            params: [ethereumAddress, JSON.stringify(txPayload.eipToSign)]
          });
        case 22:
          signature = _context2.sent;
          signatureBytes = hexToBuff(signature);
          publicKeyHex = recoverTypedSignaturePubKey(txPayload.eipToSign, signature);
          publicKey = hexToBase64(publicKeyHex);
          context.sender.pubkey = publicKey;
          txPayloadWithPubKey = getEtherMintTxPayload(context, eipData);
          signDirect = txPayloadWithPubKey.signDirect;
          bodyBytes = signDirect.body.toBinary();
          authInfoBytes = signDirect.authInfo.toBinary();
          txRawToSend = createTxRawForBroadcast(bodyBytes, authInfoBytes, [signatureBytes]);
          _context2.next = 34;
          return broadcastRawTx(txRawToSend, nodeUrl);
        case 34:
          broadcastResponse = _context2.sent;
          return _context2.abrupt("return", broadcastResponse);
        case 36:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function sendEthTxnToRouterChain(_x2) {
    return _ref4.apply(this, arguments);
  };
}();

export { Address, AlphaDevnetCosmosChainId, BECH32_ADDR_ACC_PREFIX, BECH32_ADDR_CONS_PREFIX, BECH32_ADDR_VAL_PREFIX, BECH32_PUBKEY_ACC_PREFIX, BECH32_PUBKEY_CONS_PREFIX, BECH32_PUBKEY_VAL_PREFIX, BaseAccount, BigNumber, BigNumberInBase, BigNumberInWei, BondStatus, BroadcastMode$1 as BroadcastMode, CancelToken, ChainGrpcAttestationApi, ChainGrpcAttestationTransformer, ChainGrpcAuthApi, ChainGrpcBankApi, ChainGrpcBankTransformer, ChainGrpcClient, ChainGrpcCrosschainApi, ChainGrpcCrosschainTransformer, ChainGrpcDistributionApi, ChainGrpcDistributionTransformer, ChainGrpcGovApi, ChainGrpcGovTransformer, ChainGrpcIbcApi, ChainGrpcMetastoreTransformer, ChainGrpcMintApi, ChainGrpcMintTransformer, ChainGrpcMultiChainApi, ChainGrpcMultiChainTransformer, ChainGrpcStakingApi, ChainGrpcStakingTransformer, ChainGrpcWasmApi, ChainGrpcWasmTransformer, ChainId, ChainIdByChainType, ChainModule, ChainRestAuthApi, ChainRestClient, ChainRestTendermintApi, ChainType, ChainTypes, CosmosChainId, CosmosWalletStrategy, Cosmostation, CosmostationEth, CrosschainEvent, DEFAULT_BLOCK_TIMEOUT_HEIGHT, DEFAULT_BLOCK_TIME_IN_SECONDS, DEFAULT_BRIDGE_FEE_AMOUNT, DEFAULT_BRIDGE_FEE_DENOM, DEFAULT_BRIDGE_FEE_PRICE, DEFAULT_DERIVATION_PATH, DEFAULT_EXCHANGE_GAS_LIMIT, DEFAULT_EXCHANGE_LIMIT, DEFAULT_FEE_DENOM, DEFAULT_GAS_LIMIT, DEFAULT_GAS_PRICE, DEFAULT_PAGINATION_TOTAL_COUNT, DEFAULT_STD_FEE, DEFAULT_STD_FEE_BY_DENOM, DEFAULT_TIMEOUT_HEIGHT, DEFAULT_TIMESTAMP_TIMEOUT_MS, DEFAULT_TX_BLOCK_INCLUSION_TIMEOUT_IN_MS, DUST_AMOUNT, Denom, DevnetCosmosChainId, EthereumChainId, HttpClient, Keplr, Leap, LedgerDerivationPathType, LedgerLegacy, LedgerLive, LocalStorage, Metamask, MsgApproveFeepayerRequest, MsgExec as MsgAuthzExec, MsgBeginRedelegate, MsgCwStoreCode, MsgDelegate, MsgExecuteContract, MsgExecuteCwContract, MsgDeposit as MsgGovDeposit, MsgGrant, MsgInstantiateContract, MsgInstantiateCwContract, MsgMigrateContract, MsgMigrateCwContract, MsgRevoke, MsgSend, MsgStoreCode, MsgSubmitTextProposal, MsgTransfer, MsgUndelegate, MsgUpdateAdmin, MsgVote, MsgWithdrawDelegatorReward, Network, OrderState, PAGINATION_TOTAL_PAGE_LIMIT, PrivateKey, ProposalDecomposer, ProposalStatus, PublicKey, QueryContractAllowance, QueryContractConfig, QueryRegisteredVaults, QueryVaultMarketId, QueryVaultTotalLpSupply, QueryVaultUserLpBalance, ROUTER_CHAIN_PREFIX, ROUTER_DENOM, RouterExplorer, SECONDS_IN_A_DAY, SIGN_AMINO, SIGN_DIRECT, Status, StatusType, StreamManager, StreamOperation, SupernovaQueryTransformer, TestnetCosmosChainId, TradeDirection, TradeExecutionSide, TradeExecutionType, TxClient, TxClientMode, TxGrpcClient, TxRestClient, VoteOption, Wallet, WalletAction, WalletConnect, WalletDeviceType, WalletStrategy, ZERO_ADDRESS, alphaDevnetChainInfo, amountToCosmosSdkDecAmount, appendTypePrefixToPropertyType, base64ToHexString, broadcastRawTx, checkIsIbcDenomCanonical, convertTimestampToMilliseconds, cosmosSdkDecToBigNumber, createAny, createAnyMessage, createAuthInfo, createBody, createCosmosSignDocFromTransaction, createFee, createSigDoc, createSignerInfo, createSigners, createTransaction, createTransactionAndCosmosSignDoc, createTransactionAndCosmosSignDocForAddressAndMsg, createTransactionForAddressAndMsg, createTransactionFromMsg, createTransactionWithSigners, createTxRawEIP712, createTxRawForBroadcast, createTxRawFromSigResponse, createWeb3Extension, denomAmountFromChainDenomAmount, denomAmountFromChainDenomAmountToFixed, denomAmountFromGrpcChainDenomAmount, denomAmountToChainDenomAmount, denomAmountToChainDenomAmountToFixed, denomAmountToGrpcChainDenomAmount, derivativeMarginFromChainMargin, derivativeMarginFromChainMarginToFixed, derivativeMarginToChainMargin, derivativeMarginToChainMarginToFixed, derivativePriceFromChainPrice, derivativePriceFromChainPriceToFixed, derivativePriceToChainPrice, derivativePriceToChainPriceToFixed, derivativeQuantityFromChainQuantity, derivativeQuantityFromChainQuantityToFixed, derivativeQuantityToChainQuantity, derivativeQuantityToChainQuantityToFixed, devnetChainInfo, dockerChainInfo, encodeBase64ToString, encodeStringToBase64, executeQueryInjected, formatWalletAddress, fromBase64, fromBase64ToString, fromUtf8, generatePagination, getAddressFromRouterAddress, getChainInfoForNetwork, getCrosschainAckClaimHash, getCrosschainAckReceiptClaimHash, getCrosschainClaimHash, getDecimalsFromNumber, getDefaultEip712Types, getEip712Domain, getEip712Fee, getEip712TypedData, getEipTxDetails, getEndDateStringFromTimeInSeconds, getEndpointsForNetwork, getEndpointsFromChainId, getEtherMintTxPayload, getEthereumChainIdForNetwork, getEthereumSignerAddress, getNetworkInfo, getNetworkType, getPublicKey, getRequestMetadata, getRequestMetadataWithAck, getRequestMetadataWithoutAck, getRouterAddress, getRouterSignerAddress, getSignificantDecimalsFromNumber, getTokenTypeFromDenom, getTransactionPartsFromTxRaw, getTransactionTypes, getTriggerPrice, getTypesIncludingFeePayer, getUTCDateFromTimestamp, getValsetUpdatedClaimHash, getWeb3GatewayMessage, gqlApis, gqlFetcher, grpcCoinToUiCoin, grpcPaginationToPagination, hashToHex, hexToBase64, hexToBase64String, hexToBuff, inboundOutboundQuery, internalDevnetChainInfo, isCosmosWallet, isEthWallet, isServerSide, isTxError, isValidAddress, latestBlockQuery, latestBlockQueryWithSignatures, latestCrosschainsQuery, latestFundDepositQuery, latestFundPaidQuery, latestTransactionsOfAddressQuery, latestTransactionsQuery, loadTestChainInfo, localChainInfo, mainnetChainInfo, makeTimeoutTimestamp, makeTimeoutTimestampInNs, mapMultipleComposerResponseMessages, mapValuesToProperValueType, numberToCosmosSdkDecString, numberTypeToReflectionNumberType, objectKeysToEip712Types, objectToJson, pageResponseToPagination, paginationRequestFromPagination, paginationUint8ArrayToString, past24Hours, pastDays, privateKeyHashToPublicKey, privateKeyHashToPublicKeyBase64, privateKeyToPublicKey, privateKeyToPublicKeyBase64, protoObjectToJson, protoTypeToAminoType, recoverTypedSignaturePubKey, restFetcher, searchSpecificCrosschainChainIdQuery, searchSpecificCrosschainDestChainIdQuery, searchSpecificCrosschainQuery, searchSpecificCrosschainSrcChainIdQuery, searchSpecificFundDepositChainIdQuery, searchSpecificFundDepositDestChainIdQuery, searchSpecificFundDepositQuery, searchSpecificFundDepositSrcChainIdQuery, searchSpecificFundPaidQuery, searchSpecificFundPaidSrcChainIdQuery, sendEthTxnToRouterChain, simulateRawTx, sleep, snakeToPascal, specificBlockQuery, specificCrosschainQuery, specificFundDepositQuery, specificFundPaidQuery, specificTransactionQuery, spotPriceFromChainPrice, spotPriceFromChainPriceToFixed, spotPriceToChainPrice, spotPriceToChainPriceToFixed, spotQuantityFromChainQuantity, spotQuantityFromChainQuantityToFixed, spotQuantityToChainQuantity, spotQuantityToChainQuantityToFixed, testnetChainInfo, toBase64, toPascalCase, toUtf8, todayInSeconds, tokenMetaToToken, tomorrow, uint8ArrayToString, validatorToDelegatorAddress, validatorsUptimeQuery };
//# sourceMappingURL=router-chain-sdk-ts.esm.js.map
